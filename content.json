{"pages":[{"title":"","text":"个人简介 大肚能容，容天下难容之事。笑口常开，笑世间可笑之人。 真、善、美 -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事UE4客户端开发 博客信息 博客源码 追求简洁，实用。 在原主题之上进行修改。 更新日志：–2021.01.01：更换博客主题，发布上线 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95% 额外： 追了很多剧 总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}],"posts":[{"title":"leetcode-1-Two Sum","text":"description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. common method 1234567891011121314class Solution { public int[] twoSum(int[] nums, int target) { int[] ret = new int[2]; for(int i =0; i&lt;nums.length-1 ;i++){ for (int j = i+1 ;j &lt; nums.length ;j++ ){ if (nums[i] + nums[j] == target){ ret = new int[]{i, j}; return ret; } } } return ret ; }} best method1234567891011121314151617class Solution { public int[] twoSum(int[] nums, int target) { int len=nums.length; HashMap&lt;Integer, Integer&gt; map=new HashMap&lt;&gt;(); map.put(nums[0], 0); for(int i=1;i&lt;len;i++){ if(map.containsKey(target-nums[i])){ int[] returnArray={map.get(target-nums[i]),i}; return returnArray; } else{ map.put(nums[i], i); } } int[] returnArray={0,0}; return returnArray; }}","link":"/Algorithm/leetcode-1-Two-Sum.html"},{"title":"算法成长之路leetcode13-14","text":"13. Roman to IntegerRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example1234567891011121314151617181920212223Example 1:Input: &quot;III&quot;Output: 3Example 2:Input: &quot;IV&quot;Output: 4Example 3:Input: &quot;IX&quot;Output: 9Example 4:Input: &quot;LVIII&quot;Output: 58Explanation: L = 50, V= 5, III = 3.Example 5:Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package algorithm;import java.util.HashMap;import java.util.Map;/** * 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 * * 字符 数值 * I 1 * V 5 * X 10 * L 50 * C 100 * D 500 * M 1000 * 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 * * 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例， * 例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边， * 所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。 * 这个特殊的规则只适用于以下六种情况： * * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 * 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 * * 示例 1: * * 输入: &quot;III&quot; * 输出: 3 * 示例 2: * * 输入: &quot;IV&quot; * 输出: 4 * 示例 3: * * 输入: &quot;IX&quot; * 输出: 9 * 示例 4: * * 输入: &quot;LVIII&quot; * 输出: 58 * 解释: L = 50, V= 5, III = 3. * 示例 5: * * 输入: &quot;MCMXCIV&quot; * 输出: 1994 * 解释: M = 1000, CM = 900, XC = 90, IV = 4. * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/roman-to-integer * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode13 { public static int romanToInt(String s) { int[] moneys = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; String[] moneyToStr = new String[]{&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;}; char[] chars = s.toCharArray(); int result = 0; int tempJ = 0; for (int i = 0; i &lt; chars.length; ) { for (int j = tempJ; j &lt; moneyToStr.length; ) { // 从左往右开始一个字符一个字符匹配，匹配到一个字符后开始下一个 if (new String(new char[]{chars[i]}).equals(moneyToStr[j])) { result += moneys[j]; i++; // 此时下一次可能还会出现一样的字符如VV=20 tempJ = j; break; // 匹配到两个字符是开始下两个字符 } else if (i + 1 &lt; chars.length &amp;&amp; new String(new char[]{chars[i], chars[i + 1]}).equals(moneyToStr[j])) { result += moneys[j]; i += 2; // 下次出现的一定是一个字符的,如IV下次不会再出现IV 只能出现I tempJ = j + 1; break; } else { j++; } } } return result; } public static int romanToInt1(String s) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;I&quot;, 1); map.put(&quot;IV&quot;, 4); map.put(&quot;V&quot;, 5); map.put(&quot;IX&quot;, 9); map.put(&quot;X&quot;, 10); map.put(&quot;XL&quot;, 40); map.put(&quot;L&quot;, 50); map.put(&quot;XC&quot;, 90); map.put(&quot;C&quot;, 100); map.put(&quot;CD&quot;, 400); map.put(&quot;D&quot;, 500); map.put(&quot;CM&quot;, 900); map.put(&quot;M&quot;, 1000); int ans = 0; // 所有的字符，要么匹配两个要么匹配一个，没有其余的情况 for(int i = 0;i &lt; s.length();) { // 两个匹配的 if(i + 1 &lt; s.length() &amp;&amp; map.containsKey(s.substring(i, i+2))) { ans += map.get(s.substring(i, i+2)); // 匹配上后往后移两个 i += 2; } else { // 一个匹配上的 ans += map.get(s.substring(i, i+1)); // 匹配后往后移一个 i ++; } } return ans; } public static void main(String[] args) { System.out.println(romanToInt(&quot;XIX&quot;)); }} 14. Longest Common PrefixWrite a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. Example12345678910111213Example 1:Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;Example 2:Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings.Note:All given inputs are in lowercase letters a-z. JAVA题解水平扫描 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package algorithm;/** * 编写一个函数来查找字符串数组中的最长公共前缀。 * * 如果不存在公共前缀，返回空字符串 &quot;&quot;。 * * 示例 1: * * 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] * 输出: &quot;fl&quot; * 示例 2: * * 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] * 输出: &quot;&quot; * 解释: 输入不存在公共前缀。 * 说明: * * 所有输入只包含小写字母 a-z 。 * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/longest-common-prefix * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode14 { public static String longestCommonPrefix(String[] strs) { if (strs.length == 0) { return &quot;&quot;; } if (strs.length == 1) { return strs[0]; } int i = 0; String pre = &quot;&quot;; for (; i &lt; strs[0].length(); i++) { pre = strs[0].substring(0, i + 1); int j = 1; boolean end = false; for (; j &lt; strs.length; j++) { if (!strs[j].startsWith(pre)) { break; } if (pre.length() == strs[j].length()) { end = true; } } if (j == strs.length &amp;&amp; !end) { continue; } else if (j != strs.length) { if (pre.length() &gt; 1) { return pre.substring(0, pre.length() - 1); } else { return &quot;&quot;; } } else { return pre; } } return pre; } // 水平扫描法 public static String longestCommonPrefix1(String[] strs) { if (strs.length == 0) return &quot;&quot;; String prefix = strs[0]; // 1,2-&gt;s1,3-&gt;s2,4;前两个中找到前缀公共最长的s1,然后和第3个一起找出s2，以此类推 for (int i = 1; i &lt; strs.length; i++) // 不相等时为-1 while (strs[i].indexOf(prefix) != 0) { // 从后往前缩短，直到找到最长的 prefix = prefix.substring(0, prefix.length() - 1); // 找完都没找到的话返回空 if (prefix.isEmpty()) return &quot;&quot;; } return prefix; } public static void main(String[] args) { System.out.println(longestCommonPrefix1(new String[]{&quot;flower&quot;,&quot;fl&quot;,&quot;flight&quot;})); } // 水平扫描，单个字符逐一进行比较 public static String longestCommonPrefix2(String[] strs) { if (strs == null || strs.length == 0) return &quot;&quot;; for (int i = 0; i &lt; strs[0].length() ; i++){ char c = strs[0].charAt(i); for (int j = 1; j &lt; strs.length; j ++) { // 如果i == strs[j].length() 代表找出最短的，直接返回，或者不相等时直接返回 if (i == strs[j].length() || strs[j].charAt(i) != c) return strs[0].substring(0, i); } } // 到此处已经找完 return strs[0]; }} 分治算法 123456789101112131415161718192021222324252627282930public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return &quot;&quot;; return longestCommonPrefix(strs, 0 , strs.length - 1);}private String longestCommonPrefix(String[] strs, int l, int r) { // 只有一个字符串的时候，返回此字符串 if (l == r) { return strs[l]; } else { int mid = (l + r)/2; // 找出左边最长前缀 String lcpLeft = longestCommonPrefix(strs, l , mid); // 找出右边最长前缀 String lcpRight = longestCommonPrefix(strs, mid + 1,r); // 左边右边中找出最长前缀 return commonPrefix(lcpLeft, lcpRight); }}String commonPrefix(String left,String right) { int min = Math.min(left.length(), right.length()); for (int i = 0; i &lt; min; i++) { // 循环最小的一边字符逐一比较,不相等时跳出 if ( left.charAt(i) != right.charAt(i) ) return left.substring(0, i); } return left.substring(0, min);} 二分查找法 1234567891011121314151617181920212223242526public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return &quot;&quot;; int minLen = Integer.MAX_VALUE; for (String str : strs) minLen = Math.min(minLen, str.length()); int low = 1; int high = minLen; while (low &lt;= high) { int middle = (low + high) / 2; if (isCommonPrefix(strs, middle)) low = middle + 1; else high = middle - 1; } return strs[0].substring(0, (low + high) / 2);}private boolean isCommonPrefix(String[] strs, int len){ String str1 = strs[0].substring(0,len); for (int i = 1; i &lt; strs.length; i++) if (!strs[i].startsWith(str1)) return false; return true;} 字典树给定一些键值字符串 S = [S 1 ,S 2 …S n ]，我们要找到字符串 q 与 S 的最长公共前缀。 这样的查询操作可能会非常频繁。 我们可以通过将所有的键值 S 存储到一颗字典树中来优化最长公共前缀查询操作。 如果你想学习更多关于字典树的内容，可以从 208. 实现 Trie (前缀树)开始。在字典树中，从根向下的每一个节点都代表一些键值的公共前缀。 但是我们需要找到字符串q 和所有键值字符串的最长公共前缀。 这意味着我们需要从根找到一条最深的路径，满足以下条件： 这是所查询的字符串 q 的一个前缀 路径上的每一个节点都有且仅有一个孩子。 否则，找到的路径就不是所有字符串的公共前缀 路径不包含被标记成某一个键值字符串结尾的节点。 因为最长公共前缀不可能比某个字符串本身长 算法 最后的问题就是如何找到字典树中满足上述所有要求的最深节点。 最有效的方法就是建立一颗包含字符串[S 1 …S n ] 的字典树。 然后在这颗树中匹配 q 的前缀。 我们从根节点遍历这颗字典树，直到因为不能满足某个条件而不能再遍历为止。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public String longestCommonPrefix(String q, String[] strs) { if (strs == null || strs.length == 0) return &quot;&quot;; if (strs.length == 1) return strs[0]; Trie trie = new Trie(); for (int i = 1; i &lt; strs.length ; i++) { trie.insert(strs[i]); } return trie.searchLongestPrefix(q);}class TrieNode { // 子节点的链接数组 private TrieNode[] links; private final int R = 26; private boolean isEnd; // 非空子节点的数量 private int size; public void put(char ch, TrieNode node) { links[ch -'a'] = node; size++; } public int getLinks() { return size; } // 假设方法 containsKey、isEnd、get、put 都已经实现了 // 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/}public class Trie { private TrieNode root; public Trie() { root = new TrieNode(); }// 假设方法 insert、search、searchPrefix 都已经实现了// 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/ private String searchLongestPrefix(String word) { TrieNode node = root; StringBuilder prefix = new StringBuilder(); for (int i = 0; i &lt; word.length(); i++) { char curLetter = word.charAt(i); if (node.containsKey(curLetter) &amp;&amp; (node.getLinks() == 1) &amp;&amp; (!node.isEnd())) { prefix.append(curLetter); node = node.get(curLetter); } else return prefix.toString(); } return prefix.toString(); }}","link":"/Algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode13-14.html"},{"title":"leetcode-2-Add Two Numbers","text":"Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example:Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. common 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); // 一点要赋值一个节点，进行操作 ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) { int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; } if (carry &gt; 0) { curr.next = new ListNode(carry); } return dummyHead.next; }} best123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode head = new ListNode(0); int carry = 0; while(l1!=null||l2!=null||carry&gt;0) { ListNode itr = head; while(itr.next!=null) itr = itr.next; // 寻找最后一个节点 int sum = ( (l1==null ? 0 : l1.val) + (l2==null ? 0 : l2.val) + carry); carry = sum/10; ListNode temp = new ListNode(sum%10); itr.next = temp; if(l1!=null) l1 = l1.next; if(l2!=null) l2 = l2.next; } return head.next; }}","link":"/Algorithm/leetcode-2-Add-Two-Numbers.html"},{"title":"算法成长之路leetcode11-12","text":"11. Container With Most WaterGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example1234Example:Input: [1,8,6,2,5,4,8,3,7]Output: 49 JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package algorithm;/** * 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。 * 在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。 * 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 * * 说明：你不能倾斜容器，且 n 的值至少为 2。 * * * * 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 * * * * 示例: * * 输入: [1,8,6,2,5,4,8,3,7] * 输出: 49 * * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/container-with-most-water * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode11 { // 暴力解法 public static int maxArea(int[] height) { int max = 0; for (int i = 0; i &lt; height.length - 1; i++) { for (int j = i + 1; j &lt; height.length; j++) { max = Math.max(max, Math.min(height[i], height[j]) * (j-i)); } } return max; } // 官方 双指针法 /** * 算法 * * 这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。 * * 我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 * 此外，我们会使用变量 maxareamaxarea 来持续存储到目前为止所获得的最大面积。 * 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxareamaxarea，并将指向较短线段的指针向较长线段那端移动一步。 * * 作者：LeetCode * 链接：https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * * 算法流程： 设置双指针 ii,jj 分别位于容器壁两端，根据规则移动指针（后续说明），并且更新面积最大值 res，直到 i == j 时返回 res。 * * 指针移动规则与证明： 每次选定围成水槽两板高度 h[i]h[i],h[j]h[j] 中的短板，向中间收窄 11 格。以下证明： * * 设每一状态下水槽面积为 S(i, j)S(i,j),(0 &lt;= i &lt; j &lt; n)(0&lt;=i&lt;j&lt;n)，由于水槽的实际高度由两板中的短板决定， * 则可得面积公式 S(i, j) = min(h[i], h[j]) × (j - i)S(i,j)=min(h[i],h[j])×(j−i)。 * 在每一个状态下，无论长板或短板收窄 11 格，都会导致水槽 底边宽度 -1−1： * 若向内移动短板，水槽的短板 min(h[i], h[j])min(h[i],h[j]) 可能变大，因此水槽面积 S(i, j)S(i,j) 可能增大。 * 若向内移动长板，水槽的短板 min(h[i], h[j])min(h[i],h[j]) 不变或变小，下个水槽的面积一定小于当前水槽面积。 * 因此，向内收窄短板可以获取面积最大值。换个角度理解： * 若不指定移动规则，所有移动出现的 S(i, j)S(i,j) 的状态数为 C(n, 2)C(n,2)，即暴力枚举出所有状态。 * 在状态 S(i, j)S(i,j) 下向内移动短板至 S(i + 1, j)S(i+1,j)（假设 h[i] &lt; h[j]h[i]&lt;h[j] ）， * 则相当于消去了 {S(i, j - 1), S(i, j - 2), ... , S(i, i + 1)}S(i,j−1),S(i,j−2),...,S(i,i+1) 状态集合。 * 而所有消去状态的面积一定 &lt;= S(i, j)&lt;=S(i,j)： * 短板高度：相比 S(i, j)S(i,j) 相同或更短（&lt;= h[i]&lt;=h[i]）； * 底边宽度：相比 S(i, j)S(i,j) 更短。 * 因此所有消去的状态的面积都 &lt; S(i, j)&lt;S(i,j)。通俗的讲，我们每次向内移动短板，所有的消去状态都不会导致丢失面积最大值 。 * * * 作者：jyd * 链接：https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * @param height * @return */ public static int maxArea1(int[] height) { int maxarea = 0, l = 0, r = height.length - 1; while (l &lt; r) { // 计算面积，取最大值 maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l)); // 小的向大的一方移动，如果左边小于右边，左边向右边移动一位，即左++,l++，否则右移 if (height[l] &lt; height[r]) l++; else r--; } return maxarea; } public static int maxArea2(int[] height) { int i = 0, j = height.length - 1, res = 0; while(i &lt; j){ res = height[i] &lt; height[j] ? Math.max(res, (j - i) * height[i++]): Math.max(res, (j - i) * height[j--]); } return res; } // best one public static int maxArea3(int[] height) { int lastIndex = height.length - 1, max = 0, temp = 0; for (int i = 0; i &lt; lastIndex;) { // 取左右边上的最小的数 temp = Math.min(height[i], height[lastIndex]); // 计算 距离最大面积 if (temp * (lastIndex - i) &gt; max) { max = temp * (lastIndex - i); System.out.println(&quot;&quot; + i + &quot;,&quot; + lastIndex); } // 最小值在右边的话 右边往左边移动 while (temp &gt;= height[lastIndex] &amp;&amp; i &lt; lastIndex) lastIndex--; // 最小值在左边的话 左边往右移动 直到重合 while (temp &gt;= height[i] &amp;&amp; i &lt; lastIndex) i++; } return max; } public static void main(String[] args) { System.out.println(maxArea3(new int[]{10, 8, 6, 2, 5, 4, 8, 3, 7})); }} 12. Integer to RomanRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example1234567891011121314151617181920212223Example 1:Input: 3Output: &quot;III&quot;Example 2:Input: 4Output: &quot;IV&quot;Example 3:Input: 9Output: &quot;IX&quot;Example 4:Input: 58Output: &quot;LVIII&quot;Explanation: L = 50, V = 5, III = 3.Example 5:Input: 1994Output: &quot;MCMXCIV&quot;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160package algorithm;/** * 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 * * 字符 数值 * I 1 * V 5 * X 10 * L 50 * C 100 * D 500 * M 1000 * 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ， * 即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 * * 通常情况下，罗马数字中小的数字在大的数字的右边。 * 但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边， * 所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地， * 数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： * * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 * 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 * * 示例 1: * * 输入: 3 * 输出: &quot;III&quot; * 示例 2: * * 输入: 4 * 输出: &quot;IV&quot; * 示例 3: * * 输入: 9 * 输出: &quot;IX&quot; * 示例 4: * * 输入: 58 * 输出: &quot;LVIII&quot; * 解释: L = 50, V = 5, III = 3. * 示例 5: * * 输入: 1994 * 输出: &quot;MCMXCIV&quot; * 解释: M = 1000, CM = 900, XC = 90, IV = 4. * * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/integer-to-roman * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode12 { /** * 执行用时 :6 ms, 在所有 java 提交中击败了的用户 * 内存消耗 :36.1 MB, 在所有 java 提交中击败了100.00%的用户 * @param num * @return */ public static String intToRoman(int num) { // 个位数 String[] map = new String[]{&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;}; // 十位数 String[] map1 = new String[]{&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;}; // 百位 String[] map2 = new String[]{&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;}; // 千位 String[] map3 = new String[]{&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;}; StringBuilder sb = new StringBuilder(); String[] res = new String[4]; int i = 10; int j = 0; while (num &gt; 0) { int temp = num % i; if (i &gt; 10) { temp = temp / (i / 10); } switch (j) { case 0: res[j++] = map[temp]; break; case 1: res[j++] = map1[temp]; break; case 2: res[j++] = map2[temp]; break; case 3: res[j++] = map3[temp]; break; } i = 10*i; if (j &gt; 3) { break; } } for (int k = res.length - 1; k &gt;= 0; k--) { sb.append(res[k]); } return sb.toString(); } /** * 贪心算法 * * 解题思路 * 参考大佬们的思路 吃透之后 写出来 * 贪心算法 我永远用最接近的去做比较 * * 如果我去小卖部买55元的东西 * * 你可以选择一张面值50的 和一张5块的 * 也可以给一张100的让老板找零 * 贪心算法就是前者 * * 假定我买3块的东西 我先用5块去比较 太多了 老板问 你还有小点的纸币没 我找不开 * 这时候 你给个两块 还差一块 又给了一块 * 看着很蠢 但是这确实有效 * * 作者：guo-tang-feng * 链接：https://leetcode-cn.com/problems/integer-to-roman/solution/tan-xin-suan-fa-by-guo-tang-feng/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * * @param num * @return */ public static String intToRoman1(int num) { StringBuilder stringBuilder = new StringBuilder(); int[] moneys = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; String[] moneyToStr = new String[]{&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;}; int index = 0; while (num &gt; 0) { // 如果大于最大的数 if (num &gt;= moneys[index]) { // 加进去 stringBuilder.append(moneyToStr[index]); // 把加进去的减掉 num -= moneys[index]; // 索引前移，num -= moneys[index] 还可能满足 num &gt;= moneys[index] // ，此时如果只index++，那么就漏掉一部分了，所以要index--，如2000减掉1000还有1000 还是应该和moneys[0]比较 index--; } // 索引后移 index++; } return stringBuilder.toString(); } public static void main(String[] args) { // 第一次超过100%用户的内存，有点小小激动 😂 System.out.println(intToRoman(400)); System.out.println(intToRoman1(1994)); }}","link":"/Algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode11-12.html"},{"title":"算法成长之路leetcode1-4","text":"1.Two SumdescGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. solutions.eg1.12345678910111213141516//24 ms 38 MB s.O(n^2) k.O(1)class Solution { public int[] twoSum(int[] nums, int target) { int[] result =new int[2]; for(int i = 0;i&lt;nums.length-1;i++){ for(int j = i+1;j&lt;nums.length;j++){ if(nums[i]+nums[j] == target){ result[0] = i; result[1] = j; return new int[]{i,j}; } } } return new int[0]; }} eg2.12345678910111213// 3 ms 37.2 MB s.O(n) k.O(n)class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer,Integer&gt; cache = new HashMap(); for(int i = 0;i&lt;nums.length;i++){ if(cache.get(nums[i]) != null){ return new int[]{cache.get(nums[i]),i}; } cache.put(target-nums[i],i); } return new int[0]; }} 2.Add Two NumbersdesYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. solutioneg1.1234567891011121314151617181920212223242526272829// 2 ms 44.7 MBclass Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int carry = 0; // 进位 ListNode head = new ListNode(0); ListNode cur = head; // 一定要用两个链表，不能用一个操作 while(l1 != null ||l2 != null|| carry != 0){ // lastSum当最后一位刚好进1的时候，需要在循环 int l1v = l1 == null?0:l1.val; int l2v = l2 == null?0:l2.val; int temp =l1v+l2v+carry; ListNode node; if(temp&gt;=10){ node = new ListNode(temp-10); lastSum = 1; }else{ node = new ListNode(temp); lastSum = 0; } if(l1 != null) l1 = l1.next; if(l2 != null) l2 = l2.next; cur.next = node; cur = node; } return head.next; }} 3.Longest Substring Without Repeating CharactersdescGiven a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. solutioneg1.123456789101112131415161718192021222324252627282930//2 ms 24.05% 36.9 MB 95.35%class Solution { public int lengthOfLongestSubstring(String s) { Set&lt;Character&gt; strSet = new HashSet(); int maxLen = 0; if(s != null &amp;&amp; s.length() &gt;0){ char ss[] = s.toCharArray(); //利用toCharArray方法转换 for (int i = 0; i &lt; ss.length-1; i++) { strSet.add(ss[i]); for(int j = i+1; j&lt;ss.length; j++){ int oL = strSet.size(); strSet.add(ss[j]); int cL = strSet.size(); if(oL != cL){ // 不相等时记下个数 if(cL &gt; maxLen){ maxLen = cL; } }else{ // 相等时 跳出此次循环 清空set strSet.clear(); break; } } } if(maxLen == 0){ // 全相等时 maxLen = 1; } } return maxLen; }} eg2.123456789101112131415161718// 2 ms 37.3 MBclass Solution { public int lengthOfLongestSubstring(String s) { int maxLength = 0; char[] chars = s.toCharArray(); int leftIndex = 0;//记录最左边相等时的值，然后向右滑动窗口 for (int j = 0; j &lt; chars.length; j++) { for (int innerIndex = leftIndex; innerIndex &lt; j; innerIndex++) { if (chars[innerIndex] == chars[j]) { maxLength = Math.max(maxLength, j - leftIndex); leftIndex = innerIndex + 1; break; } } } return Math.max(chars.length - leftIndex, maxLength); }} 4.Median of Two Sorted ArraysdescThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: 123nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 123nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 solutioneg1.123456789101112131415161718192021222324252627282930// 20 ms 10.07%// 2.2 MB 99.84%class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int maxL = 0; if (nums1.length &gt;= nums2.length) { maxL = nums1.length; } else { maxL = nums2.length; } List&lt;Integer&gt; newList = new ArrayList(maxL); for (int i = 0; i &lt; maxL; i++) { if (i &lt; nums1.length) { newList.add(nums1[i]); } if (i &lt; nums2.length) { newList.add(nums2[i]); } } int size = newList.size(); int index = size / 2; newList.sort(Comparator.comparing(Integer::valueOf)); if (size % 2 == 0) { return (newList.get(index) + newList.get(index - 1)) / 2d; } else { return newList.get(index); } }} eg2.123456789101112131415161718192021222324252627282930313233class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int n = nums1.length + nums2.length; double res = 0.0; if (n &lt;= 0) { return res; } if ((n &amp; 1) == 0) { res = (findKth(nums1, nums2, 0, 0, n / 2) + findKth(nums1, nums2, 0, 0, n / 2 + 1)) / 2.0; } else { res = findKth(nums1, nums2, 0, 0, n / 2 + 1); } return res; } private int findKth(int[] nums1, int[] nums2, int start1, int start2, int k) { if (start1 &gt;= nums1.length) { return nums2[start2 + k - 1]; } if (start2 &gt;= nums2.length) { return nums1[start1 + k - 1]; } if (k == 1) { return Math.min(nums1[start1], nums2[start2]); } int left = start1 + k / 2 - 1 &gt;= nums1.length ? Integer.MAX_VALUE : nums1[start1 + k / 2 - 1]; int right = start2 + k / 2 - 1 &gt;= nums2.length ? Integer.MAX_VALUE : nums2[start2 + k / 2 - 1]; if (left &lt; right) { return findKth(nums1, nums2, start1 + k / 2, start2, k - k / 2); } return findKth(nums1, nums2, start1, start2 + k / 2, k - k / 2); }} eg3.12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 二分查找、分治算法class Solution { public double findMedianSortedArrays(int[] A, int[] B) { //m:A数组的长度 int m = A.length; //n:B数组的长度 int n = B.length; //如果A的长度大于B if (m &gt; n) { // to ensure m&lt;=n //交换AB数组，确保m&lt;=n int[] temp = A; A = B; B = temp; int tmp = m; m = n; n = tmp; } //设置两个指针，iMin为头指针，IMAX为尾指针，halfLen为中位数指针 int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2; //如果头指针走向不大于尾指针，进行循环 while (iMin &lt;= iMax) { //i为中位数 int i = (iMin + iMax) / 2; //j为 int j = halfLen - i; if (i &lt; iMax &amp;&amp; B[j - 1] &gt; A[i]){ iMin = i + 1; // i is too small } else if (i &gt; iMin &amp;&amp; A[i - 1] &gt; B[j]) { iMax = i - 1; // i is too big } else { // i is perfect int maxLeft = 0; if (i == 0) { maxLeft = B[j-1]; } else if (j == 0) { maxLeft = A[i - 1]; } else { maxLeft = Math.max(A[i - 1], B[j - 1]); } if ( (m + n) % 2 == 1 ) { return maxLeft; } int minRight = 0; if (i == m) { minRight = B[j]; } else if (j == n) { minRight = A[i]; } else { minRight = Math.min(B[j], A[i]); } return (maxLeft + minRight) / 2.0; } } return 0d; }}","link":"/Algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode1-4.html"},{"title":"算法成长之路leetcode17-18","text":"17. Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example12345678Example:Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].Note:Although the above answer is in lexicographical order, your answer could be in any order you want. JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package algorithm;import java.util.*;/** * 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 * * 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 * 示例: 输入：&quot;23&quot; 输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. */public class Leetcode17 { public static List&lt;String&gt; letterCombinations(String digits) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); String[] indexToStr = new String[]{&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;}; if (digits == null || &quot;&quot;.equals(digits)) return res; else if(digits.length() == 1) { char[] chars = indexToStr[Integer.parseInt(digits)].toCharArray(); for (int i = 0; i &lt; chars.length; i++) { res.add(new String(new char[]{chars[i]})); } } char[] charArray = digits.toCharArray(); char[] i0Char = indexToStr[(int) charArray[0] - (int) ('0')].toCharArray(); for (int i = 1; i &lt; charArray.length; i++) { for (int i1 = 0; i1 &lt; i0Char.length; i1++) { char[] chars1 = indexToStr[(int) charArray[i] - (int) ('0')].toCharArray(); for (int i2 = 0; i2 &lt; chars1.length; i2++) { res.add(new String(new char[]{i0Char[i1], chars1[i2]})); } } } return res; } Map&lt;String, String&gt; phone = new HashMap&lt;String, String&gt;() {{ put(&quot;2&quot;, &quot;abc&quot;); put(&quot;3&quot;, &quot;def&quot;); put(&quot;4&quot;, &quot;ghi&quot;); put(&quot;5&quot;, &quot;jkl&quot;); put(&quot;6&quot;, &quot;mno&quot;); put(&quot;7&quot;, &quot;pqrs&quot;); put(&quot;8&quot;, &quot;tuv&quot;); put(&quot;9&quot;, &quot;wxyz&quot;); }}; List&lt;String&gt; output = new ArrayList&lt;String&gt;(); public void backtrack(String combination, String next_digits) { // if there is no more digits to check if (next_digits.length() == 0) { // the combination is done output.add(combination); } // if there are still digits to check else { // iterate over all letters which map // the next available digit String digit = next_digits.substring(0, 1); String letters = phone.get(digit); for (int i = 0; i &lt; letters.length(); i++) { String letter = phone.get(digit).substring(i, i + 1); // append the current letter to the combination // and proceed to the next digits backtrack(combination + letter, next_digits.substring(1)); } } } /** * 方法：回溯 * 回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。 * * 给出如下回溯函数 backtrack(combination, next_digits) ，它将一个目前已经产生的组合 combination 和接下来准备要输入的数字 next_digits 作为参数。 * * 如果没有更多的数字需要被输入，那意味着当前的组合已经产生好了。 * 如果还有数字需要被输入： * 遍历下一个数字所对应的所有映射的字母。 * 将当前的字母添加到组合最后，也就是 combination = combination + letter 。 * 重复这个过程，输入剩下的数字： backtrack(combination + letter, next_digits[1:]) 。 * * 有动画图解 * 作者：LeetCode * 链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * @param digits * @return */ public List&lt;String&gt; letterCombinations1(String digits) { if (digits.length() != 0) backtrack(&quot;&quot;, digits); return output; } public static void main(String[] args) { System.out.println(letterCombinations(&quot;3&quot;)); System.out.println(new Leetcode17().letterCombinations1(&quot;234&quot;)); }} 18. 4SumGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example1234567891011Example:Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package algorithm;import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ， * 使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 * * 注意： * * 答案中不可以包含重复的四元组。 * * 示例： * * 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 * * 满足要求的四元组集合为： * [ * [-1, 0, 0, 1], * [-2, -1, 1, 2], * [-2, 0, 0, 2] * ] * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/4sum * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode18 { /** * 思路： * * 四数之和与前面三数之和的思路几乎是一样的，嗝。（刚好前些天才写了三数之和的题解） * 如果前面的三数之和会做了的话，这里其实就是在前面的基础上多添加一个遍历的指针而已。 * 会做三数之和的可以不用看下面的了。。 * * 使用四个指针(a&lt;b&lt;c&lt;d)。固定最小的a和b在左边，c=b+1,d=_size-1 移动两个指针包夹求解。 * 保存使得nums[a]+nums[b]+nums[c]+nums[d]==target的解。偏大时d左移，偏小时c右移。c和d相 * 遇时，表示以当前的a和b为最小值的解已经全部求得。b++,进入下一轮循环b循环，当b循环结束后。 * a++，进入下一轮a循环。 即(a在最外层循环，里面嵌套b循环，再嵌套双指针c,d包夹求解)。 * 准备工作： * * 因为要使用双指针的方法，排序是必须要做der~。 时间复杂度O(NlogN). * * 作者：misakasagiri-2 * 链接：https://leetcode-cn.com/problems/4sum/solution/shuang-zhi-zhen-jie-fa-can-zhao-san-shu-zhi-he-ge-/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * * @param nums * @param target * @return */ public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) { /*定义一个返回值*/ List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); /*当数组为null或元素小于4个时，直接返回*/ if (nums == null || nums.length &lt; 4) { return result; } /*对数组进行从小到大排序*/ Arrays.sort(nums); System.out.println(&quot;-4,-1,-1,0,1,2&quot;); /*数组长度*/ int length = nums.length; /*定义4个指针k，i，j，h k从0开始遍历，i从k+1开始遍历，留下j和h，j指向i+1，h指向数组最大值*/ for (int k = 0; k &lt; length - 3; k++) { /*当k的值与前面的值相等时忽略*/ if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) { continue; } /*获取当前最小值，如果最小值比目标值大，说明后面越来越大的值根本没戏*/ int min1 = nums[k] + nums[k + 1] + nums[k + 2] + nums[k + 3]; if (min1 &gt; target) { break; } /*获取当前最大值，如果最大值比目标值小，说明后面越来越小的值根本没戏，忽略*/ int max1 = nums[k] + nums[length - 1] + nums[length - 2] + nums[length - 3]; if (max1 &lt; target) { continue; } /*第二层循环i，初始值指向k+1*/ for (int i = k + 1; i &lt; length - 2; i++) { /*当i的值与前面的值相等时忽略*/ if (i &gt; k + 1 &amp;&amp; nums[i] == nums[i - 1]) { continue; } /*定义指针j指向i+1*/ int j = i + 1; /*定义指针h指向数组末尾*/ int h = length - 1; /*获取当前最小值，如果最小值比目标值大，说明后面越来越大的值根本没戏，忽略*/ int min = nums[k] + nums[i] + nums[j] + nums[j + 1]; if (min &gt; target) { System.out.println(&quot;m,k=&quot;+k+&quot;,i=&quot;+i+&quot;,j=&quot;+j+&quot;,j+1=&quot;+(j+1)); break; // 此时直接滑动k,因为不管怎么滑动i,min 都会大于target } /*获取当前最大值，如果最大值比目标值小，说明后面越来越小的值根本没戏，忽略*/ int max = nums[k] + nums[i] + nums[h] + nums[h - 1]; if (max &lt; target) { System.out.println(&quot;ma,k=&quot;+k+&quot;,i=&quot;+i+&quot;,j=&quot;+j+&quot;,j+1=&quot;+(j+1)); continue; // 此时continue滑动i 值，nums[i] + nums[h] + nums[h - 1] 变大 ，整个max 会变大 } /** * -4,-1,-1,0,1,2 * ma,k=0,i=1,j=2,j+1=3 * m,k=1,i=3,j=4,j+1=5 * [[-4, 0, 1, 2], [-1, -1, 0, 1]] * * -4,-1,-1,0,1,2 * ma,k=0,i=1,j=2,j+1=3 * m,k=1,i=3,j=4,j+1=5 * [[-1, -1, 0, 1]] */ /*开始j指针和h指针的表演，计算当前和，如果等于目标值，j++并去重，h--并去重，当当前和大于目标值时h--，当当前和小于目标值时j++*/ while (j &lt; h) { int curr = nums[k] + nums[i] + nums[j] + nums[h]; if (curr == target) { result.add(Arrays.asList(nums[k], nums[i], nums[j], nums[h])); j++; while (j &lt; h &amp;&amp; nums[j] == nums[j - 1]) { j++; } h--; while (j &lt; h &amp;&amp; i &lt; h &amp;&amp; nums[h] == nums[h + 1]) { h--; } } else if (curr &gt; target) { h--; } else { j++; } } } } return result; } /* 作者：you-wei-wu 链接：https://leetcode-cn.com/problems/4sum/solution/ji-bai-9994de-yong-hu-you-dai-ma-you-zhu-shi-by-yo/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 */ public static void main(String[] args) { System.out.println(new Leetcode18().fourSum(new int[]{-1,0,1,2,-1,-4},-1)); }}","link":"/Algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode17-18.html"},{"title":"算法成长之路leetcode15-16","text":"15. 3SumGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example123456789Example:Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package algorithm;import java.util.*;/** * 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ， * 使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 * * 注意：答案中不可以包含重复的三元组。 * * 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， * * 满足要求的三元组集合为： * [ * [-1, 0, 1], * [-1, -1, 2] * ] * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/3sum * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode15 { // ❌错解 public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Set&lt;String&gt; ids = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nums.length - 2; i++) { for (int j = i+1; j &lt; nums.length-1; j++) { for (int k = j+1; k &lt; nums.length; k++) { if(nums[i]+nums[j]+nums[k] == 0){ String i2 = nums[i] + &quot;&quot;+nums[j]+nums[k]; System.out.println(nums[i]+&quot;,&quot;+nums[j]+&quot;,&quot;+nums[k]+&quot;=&quot;+i2); if(!ids.contains(i2)){ ids.add(i2); res.add(Arrays.asList(nums[i],nums[j],nums[k])); } } } } } return res; } /** * 思路 * 标签：数组遍历 * 首先对数组进行排序，排序后固定一个数 nums[i]nums[i]，再使用左右指针指向 nums[i]nums[i]后面的两端，数字分别为 nums[L]nums[L] 和 nums[R]nums[R]，计算三个数的和 sumsum 判断是否满足为 00，满足则添加进结果集 * 如果 nums[i]nums[i]大于 00，则三数之和必然无法等于 00，结束循环 * 如果 nums[i]nums[i] == nums[i-1]nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过 * 当 sumsum == 00 时，nums[L]nums[L] == nums[L+1]nums[L+1] 则会导致结果重复，应该跳过，L++L++ * 当 sumsum == 00 时，nums[R]nums[R] == nums[R-1]nums[R−1] 则会导致结果重复，应该跳过，R--R−− * 时间复杂度：O(n^2)，n 为数组长度 * * 作者：guanpengchn * 链接：https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * @param nums * @return */ public static List&lt;List&lt;Integer&gt;&gt; threeSum1(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); int len = nums.length; if (nums == null || len &lt; 3) return ans; Arrays.sort(nums); // 排序 for (int i = 0; i &lt; len; i++) { if (nums[i] &gt; 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; // 去重 int L = i + 1; int R = len - 1; while (L &lt; R) { int sum = nums[i] + nums[L] + nums[R]; if (sum == 0) { ans.add(Arrays.asList(nums[i], nums[L], nums[R])); // 此时nums[L] == nums[L + 1] 会重复，继续跳过一个 while (L &lt; R &amp;&amp; nums[L] == nums[L + 1]) L++; // 去重 while (L &lt; R &amp;&amp; nums[R] == nums[R - 1]) R--; // 去重 L++; R--; } else if (sum &lt; 0) L++; else if (sum &gt; 0) R--; } } return ans; } public static void main(String[] args) { System.out.println(threeSum(new int[]{-4, -2, -2, -2, 0, 1, 2, 2, 2, 3, 3, 4, 4, 6, 6})); }} 16. 3Sum ClosestGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example123456Example:Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). JAVA题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package algorithm;import java.util.Arrays;/** * 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数， * 使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 * * 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. * * 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/3sum-closest * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode16 { // 想到的思路，找出所有的组合以及它们的sum，然后排好序二分法查找sum中最接近的 public int threeSumClosest(int[] nums, int target) { return 0; } /** * 思路 * 标签：排序和双指针 * 本题目因为要计算三个数，如果靠暴力枚举的话时间复杂度会到 O(n^3)，需要降低时间复杂度 * 首先进行数组排序，时间复杂度 O(nlogn)O(nlogn) * 在数组 nums 中，进行遍历，每遍历一个值利用其下标i，形成一个固定值 nums[i] * 再使用前指针指向 start = i + 1 处，后指针指向 end = nums.length - 1 处，也就是结尾处 * 根据 sum = nums[i] + nums[start] + nums[end] 的结果，判断 sum 与目标 target 的距离，如果更近则更新结果 ans * 同时判断 sum 与 target 的大小关系，因为数组有序，如果 sum &gt; target 则 end--，如果 sum &lt; target 则 start++，如果 sum == target 则说明距离为 0 直接返回结果 * 整个遍历过程，固定值为 n 次，双指针为 n 次，时间复杂度为 O(n^2) * 总时间复杂度：O(nlogn) + O(n^2) = O(n^2) * * 作者：guanpengchn * 链接：https://leetcode-cn.com/problems/3sum-closest/solution/hua-jie-suan-fa-16-zui-jie-jin-de-san-shu-zhi-he-b/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * @param nums * @param target * @return */ public int threeSumClosest1(int[] nums, int target) { Arrays.sort(nums); int ans = nums[0] + nums[1] + nums[2]; for(int i=0;i&lt;nums.length;i++) { int start = i+1, end = nums.length - 1; while(start &lt; end) { int sum = nums[start] + nums[end] + nums[i]; // 结果差值更小时，取更小的 if(Math.abs(target - sum) &lt; Math.abs(target - ans)) ans = sum; // 结果大于目标，右边的左移 if(sum &gt; target) end--; else if(sum &lt; target) start++; else // 相等时直接返回结果 return ans; } } return ans; }}","link":"/Algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode15-16.html"},{"title":"算法成长之路leetcode19-20","text":"19. Remove Nth Node From End of ListGiven a linked list, remove the n-th node from the end of list and return its head. Example12345678910111213Example:Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given n will always be valid.Follow up:Could you do this in one pass? JAVA题解方法一：两次遍历算法 思路 我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)(L−n+1) 个结点，其中 LL 是列表的长度。只要我们找到列表的长度 LL，这个问题就很容易解决。 算法 首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 LL。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n)(L−n) 个结点那里。我们把第 (L - n)(L−n) 个结点的 next 指针重新链接至第 (L - n + 2)(L−n+2) 个结点，完成这个算法。 1234567891011121314151617181920212223242526272829/**给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明：给定的 n 保证是有效的。进阶：你能尝试使用一趟扫描实现吗？*/public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; int length = 0; ListNode first = head; while (first != null) { length++; first = first.next; } length -= n; first = dummy; while (length &gt; 0) { length--; first = first.next; } first.next = first.next.next; return dummy.next;} 方法二：一次遍历算法 算法 上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 nn 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 nn 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。 12345678910111213141516171819202122public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; ListNode second = dummy; // Advances first pointer so that the gap between first and second is n nodes apart for (int i = 1; i &lt;= n + 1; i++) { first = first.next; } // Move first to the end, maintaining the gap while (first != null) { first = first.next; second = second.next; } second.next = second.next.next; return dummy.next;}作者：LeetCode链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-by-l/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 20. Valid ParenthesesGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.Note that an empty string is also considered valid. Example123456789101112131415161718192021Example 1:Input: &quot;()&quot;Output: trueExample 2:Input: &quot;()[]{}&quot;Output: trueExample 3:Input: &quot;(]&quot;Output: falseExample 4:Input: &quot;([)]&quot;Output: falseExample 5:Input: &quot;{[]}&quot;Output: true JAVA题解Leetcode20.java >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package algorithm;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 * * 有效字符串需满足： * * 左括号必须用相同类型的右括号闭合。 * 左括号必须以正确的顺序闭合。 * 注意空字符串可被认为是有效字符串。 * * 示例 1: * * 输入: &quot;()&quot; * 输出: true * 示例 2: * * 输入: &quot;()[]{}&quot; * 输出: true * 示例 3: * * 输入: &quot;(]&quot; * 输出: false * 示例 4: * * 输入: &quot;([)]&quot; * 输出: false * 示例 5: * * 输入: &quot;{[]}&quot; * 输出: true * */public class Leetcode20 { // 类似栈的处理 public boolean isValid(String s) { if(s == null || s.equals(&quot;&quot;)){ return true; } // 奇数 if(s.length() % 2 != 0){ return false; } List&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); Map&lt;Character, Integer&gt; cIn = new HashMap&lt;&gt;(); cIn.put('(', 1); cIn.put(')', -1); cIn.put('{', 2); cIn.put('}', -2); cIn.put('[', 3); cIn.put(']', -3); char[] chars = s.toCharArray(); arr.add(cIn.get(chars[0])); for (int i = 1; i &lt; chars.length; i++) { // 相等则移除 int latestIndex = arr.size() - 1; if (latestIndex &gt;= 0 &amp;&amp; arr.get(latestIndex) == -cIn.get(chars[i])) { arr.remove(latestIndex); } else { arr.add(cIn.get(chars[i])); } } if (arr.size() &gt; 0) { return false; } else { return true; } } public static void main(String[] args) { System.out.println(new Leetcode20().isValid(&quot;([])[]&quot;)); }}// 栈的处理class Solution { public boolean isValid(String s) { if(s.isEmpty()) return true; Stack&lt;Character&gt; stack=new Stack&lt;Character&gt;(); for(char c:s.toCharArray()){ if(c=='(') stack.push(')'); else if(c=='{') stack.push('}'); else if(c=='[') stack.push(']'); else if(stack.empty()||c!=stack.pop()) return false; } if(stack.empty()) return true; return false; }}// 栈 官方class Solution { // Hash table that takes care of the mappings. private HashMap&lt;Character, Character&gt; mappings; // Initialize hash map with mappings. This simply makes the code easier to read. public Solution() { this.mappings = new HashMap&lt;Character, Character&gt;(); this.mappings.put(')', '('); this.mappings.put('}', '{'); this.mappings.put(']', '['); } public boolean isValid(String s) { // Initialize a stack to be used in the algorithm. Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); // If the current character is a closing bracket. if (this.mappings.containsKey(c)) { // Get the top element of the stack. If the stack is empty, set a dummy value of '#' char topElement = stack.empty() ? '#' : stack.pop(); // If the mapping for this bracket doesn't match the stack's top element, return false. if (topElement != this.mappings.get(c)) { return false; } } else { // If it was an opening bracket, push to the stack. stack.push(c); } } // If the stack still contains elements, then it is an invalid expression. return stack.isEmpty(); }}","link":"/Algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode19-20.html"},{"title":"算法成长之路leetcode7-8","text":"7. Reverse IntegerGiven a 32-bit signed integer, reverse digits of an integer. Example1234567891011121314Example 1:Input: 123Output: 321Example 2:Input: -123Output: -321Example 3:Input: 120Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package algorithm;public class Leetcode7 { /** * 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 * * 示例 1: * * 输入: 123 * 输出: 321 * 示例 2: * * 输入: -123 * 输出: -321 * 示例 3: * * 输入: 120 * 输出: 21 * 注意: * * 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/reverse-integer * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */ public int reverse(int x) { if (x &gt; Integer.MAX_VALUE || x &lt; Integer.MIN_VALUE) { return 0; } boolean isNe = x &lt; 0 ? true : false; x = Math.abs(x); // 取绝对值时越界了，直接返回0 if (isNe &amp;&amp; x &lt; 0) { return 0; } StringBuilder sb = new StringBuilder(); long m = 10; long base = 1; while (true) { base = m * base; long re = x % base; if (base == 10) { sb.append(re); } else { sb.append((re * m) / base); } if (x &lt; base) { break; } } Long res; if (isNe) { res = 0 - Long.parseLong(sb.toString()); } else { res = Long.parseLong(sb.toString()); } if (res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE) { return 0; } else { return res.intValue(); } } public int reverse1(int x) { int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; // Integer.MAX_VALUE = 2147483647,因为后面 rev = rev * 10 + pop，所以rev &gt;Integer.MAX_VALUE 溢出 // rev == Integer.MAX_VALUE / 10 时，Integer.MAX_VALUE / 10 = 2147483640,so,pop &gt; 7时溢出 if (rev &gt; Integer.MAX_VALUE / 10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) return 0; // Integer.MIN_VALUE = -2147483648 // 同理如上 if (rev &lt; Integer.MIN_VALUE / 10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0; rev = rev * 10 + pop; } return rev; } public static void main(String[] args) { System.out.println(Integer.MAX_VALUE);// System.out.println(reverse1(123)); }} 8. String to Integer (atoi)Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ‘ ‘ is considered as whitespace character.Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned. Example12345678910111213141516171819202122232425262728Example 1:Input: &quot;42&quot;Output: 42Example 2:Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is '-', which is the minus sign. Then take as many numerical digits as possible, which gets 42.Example 3:Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.Example 4:Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.Example 5:Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Thefore INT_MIN (−2^31) is returned. JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package algorithm;public class Leetcode8 { /** * *请你来实现一个 atoi 函数，使其能将字符串转换成整数。 * * 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 * * 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 * * 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 * * 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 * * 在任何情况下，若函数不能进行有效的转换时，请返回 0。 * * 说明： * * 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。 * * 示例 1: * * 输入: &quot;42&quot; * 输出: 42 * 示例 2: * * 输入: &quot; -42&quot; * 输出: -42 * 解释: 第一个非空白字符为 '-', 它是一个负号。 * 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 * 示例 3: * * 输入: &quot;4193 with words&quot; * 输出: 4193 * 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 * 示例 4: * * 输入: &quot;words and 987&quot; * 输出: 0 * 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 * 因此无法执行有效的转换。 * 示例 5: * * 输入: &quot;-91283472332&quot; * 输出: -2147483648 * 解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 * 因此返回 INT_MIN (−2^31) 。 * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/string-to-integer-atoi * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */ public static int myAtoi(String str) { StringBuilder st = new StringBuilder(); for (int i = 0; i &lt; str.length(); i++) { char c = str.charAt(i); if (c == '-') { if (st.length() &gt; 0) { break; } st.append(c); } else if (c == '+') { if (st.length() &gt; 0) { break; } st.append(c); } else if (c == ' ') { if (st.length() &gt; 0) { break; } else { continue; } } else if (c &gt;= 48 &amp;&amp; c &lt;= 57) { st.append(c); } else { break; } if (st.length() &gt; 1) { if (Long.parseLong(st.toString()) &gt; Integer.MAX_VALUE) { return Integer.MAX_VALUE; } if (Long.parseLong(st.toString()) &lt; Integer.MIN_VALUE) { return Integer.MIN_VALUE; } } } if (st.length() == 0) { return 0; } if (st.toString().equals(&quot;-&quot;) || st.toString().equals(&quot;+&quot;)) { return 0; } return Long.valueOf(st.toString()).intValue(); } public int myAtoi1(String str) { if (str.isEmpty()) return 0; char[] mychar = str.toCharArray(); long ans = 0; int index = 0, flag = 1, n = str.length(); //排除字符串开头的空格元素 while (index &lt; n &amp;&amp; mychar[index] == ' ') { index++; } //排除空格后判断首字符是+还是-还是都不是 if (index &lt; n &amp;&amp; mychar[index] == '+') { index++; } else if (index &lt; n &amp;&amp; mychar[index] == '-') { index++; flag = -1; } //重点：只管是数字的时候，其余取0 while (index &lt; n &amp;&amp; (mychar[index] &gt;= '0' &amp;&amp; mychar[index] &lt;= '9')) { if (ans != (int) ans) {//超出int范围 return (flag == 1) ? Integer.MAX_VALUE : Integer.MIN_VALUE;//提前结束 } // 巧妙的加起来值来 如 111 ，第一个1时 ans = 0 * 10 +1,第二个1时 ans = 1*10 + 1 = 11,第三个1时， ans = 11*10 + 1 = 111; ans = ans * 10 + mychar[index++] - '0'; } // 强转long是否等于int 判断是否超界，机智 if (ans != (int) ans) { return (flag == 1) ? Integer.MAX_VALUE : Integer.MIN_VALUE; } return (int) (ans * flag); } public static void main(String[] args) { /** * &quot;42&quot; * &quot;----01&quot; * &quot;0-1&quot; * &quot;-5-&quot; */ System.out.println(myAtoi(&quot;0-1&quot;)); }}","link":"/Algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode7-8.html"},{"title":"贪心算法解析示例","text":"定义贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 思想贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止 过程 建立数学模型来描述问题； 把求解的问题分成若干个子问题； 对每一子问题求解，得到子问题的局部最优解； 把子问题的解局部最优解合成原来解问题的一个解。 示例假设山洞中有 n 种宝物，每种宝物有一定重量 w 和相应的价值 v，毛驴运载能力有限，只能运走 m 重量的宝物，一种宝物只能拿一样，宝物可以分割。那么怎么才能使毛驴运走宝物的价值最大呢？尝试贪心策略：（1）每次挑选价值最大的宝物装入背包，得到的结果是否最优？（2）每次挑选重量最小的宝物装入，能否得到最优解？（3）每次选取单位重量价值最大的宝物，能否使价值最高？思考一下，如果选价值最大的宝物，但重量非常大，也是不行的，因为运载能力是有限的，所以第 1 种策略舍弃；如果选重量最小的物品装入，那么其价值不一定高，所以不能在总重限制的情况下保证价值最大，第 2 种策略舍弃；而第 3 种是每次选取单位重量价值最大的宝物，也就是说每次选择性价比（价值/重量）最高的宝物，如果可以达到运载重量 m， 那么一定能得到价值最大。因此采用第 3 种贪心策略，每次从剩下的宝物中选择性价比最高的宝物。 算法设计：（1）数据结构及初始化。将 n 种宝物的重量和价值存储在结构体 three（包含重量、价值、性价比 3 个成员）中，同时求出每种宝物的性价比也存储在对应的结构体 three 中，将其按照性价比从高到低排序。采用 sum 来存储毛驴能够运走的最大价值，初始化为 0。（2）根据贪心策略，按照性价比从大到小选取宝物，直到达到毛驴的运载能力。每次选择性价比高的物品，判断是否小于 m（毛驴运载能力），如果小于 m，则放入，sum（已放入物品的价值）加上当前宝物的价值，m 减去放入宝物的重量；如果不小于 m，则取该宝物的一部分 m * p[i]，m=0，程序结束。m 减少到 0，则 sum 得到最大值。 完美图解假设现在有一批宝物，价值和重量如表 2-3 所示，毛驴运载能力 m=30，那么怎么装入最大价值的物品？宝物清单： 123宝物 i 1 2 3 4 5 6 7 8 9 10重量 w[i] 4 2 9 5 5 8 5 4 5 5价值 v[i] 3 8 18 6 8 20 5 6 7 15 （1）因为贪心策略是每次选择性价比（价值/重量）高的宝物，按照性价比降序排序：排序后宝物清单： 1234宝物 i 2 10 6 3 5 8 9 4 7 1重量 w[i] 2 5 8 9 5 4 5 5 5 4价值 v[i] 8 15 20 18 8 6 7 6 5 3性价比 p[i] 4 3 2.5 2 1.6 1.5 1.4 1.2 1 0.75 （2）按照贪心策略，每次选择性价比高的宝物放入：第 1 次选择宝物 2，剩余容量 30−2=28，目前装入最大价值为 8。第 2 次选择宝物 10，剩余容量 28−5=23，目前装入最大价值为 8+15=23。第 3 次选择宝物 6，剩余容量 23−8=15，目前装入最大价值为 23+20=43。第 4 次选择宝物 3，剩余容量 15−9=6，目前装入最大价值为 43+18=61。 第 5 次选择宝物 5，剩余容量 6−5=1，目前装入最大价值为 61+8=69。第 6 次选择宝物 8，发现上次处理完时剩余容量为 1，而 8 号宝物重量为 4，无法全部放入，那么可以采用部分装入的形式，装入 1 个重量单位，因为 8 号宝物的单位重量价值为1.5，因此放入价值 1×1.5=1.5，你也可以认为装入了 8 号宝物的 1/4，目前装入最大价值为69+1.5=70.5，剩余容量为 0。（3）构造最优解把这些放入的宝物序号组合在一起，就得到了最优解（2，10，6，3，5，8），其中最后一个宝物为部分装入（装了 8 号财宝的 1/4），能够装入宝物的最大价值为 70.5。 伪代码详解（1）数据结构定义根据算法设计中的数据结构，我们首先定义一个结构体 three：struct three{double w; //每种宝物的重量double v; //每种宝物的价值double p; //每种宝物的性价比（价值/重量）｝（2）性价比排序我们可以利用 C++中的排序函数 sort（见附录 B），对宝物的性价比从大到小（非递增）排序。要使用此函数需引入头文件：#include 语法描述为：sort(begin, end)// 参数 begin 和 end 表示一个范围，分别为待排序数组的首地址和尾地址在本例中我们采用结构体形式存储，按结构体中的一个字段，即按性价比排序。如果不使用自定义比较函数，那么 sort 函数排序时不知道按哪一项的值排序，因此采用自定义比较函数的办法实现宝物性价比的降序排序：bool cmp(three a,three b)//比较函数按照宝物性价比降序排列{return a.p &gt; b.p; //指明按照宝物性价比降序排列}sort(s, s+n, cmp); //前两个参数分别为待排序数组的首地址和尾地址//最后一个参数 compare 表示比较的类型（3）贪心算法求解在性价比排序的基础上，进行贪心算法运算。如果剩余容量比当前宝物的重量大，则可以放入，剩余容量减去当前宝物的重量，已放入物品的价值加上当前宝物的价值。如果剩余容量比当前宝物的重量小，表示不可以全部放入，可以切割下来一部分（正好是剩余容量），然后令剩余容量乘以当前物品的单位重量价值，已放入物品的价值加上该价值，即为能放入宝物的最大价值。 12345678910111213for(int i = 0;i &lt; n;i++)//按照排好的顺序，执行贪心策略{if( m &gt; s[i].w )//如果宝物的重量小于毛驴剩下的运载能力，即剩余容量 { m -= s[i].w; sum += s[i].v; }else //如果宝物的重量大于毛驴剩下的承载能力 { sum += m 乘以 s[i].p; //进行宝物切割，切割一部分(m 重量)，正好达到驴子承重 break; }} 实现代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int M=1000005;struct three{ double w;//每个宝物的重量 double v;//每个宝物的价值 double p;//性价比}s[M];bool cmp(three a,three b){ return a.p&gt;b.p;//根据宝物的单位价值从大到小排序}int main(){ int n;//n 表示有 n 个宝物 double m ;//m 表示毛驴的承载能力 cout&lt;&lt;&quot;请输入宝物数量 n 及毛驴的承载能力 m ：&quot;&lt;&lt;endl; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;&quot;请输入每个宝物的重量和价值，用空格分开： &quot;&lt;&lt;endl; for(int i=0;i&lt;n;i++) { cin&gt;&gt;s[i].w&gt;&gt;s[i].v; s[i].p=s[i].v/s[i].w;//每个宝物单位价值 } sort(s,s+n,cmp); double sum=0.0;// sum 表示贪心记录运走宝物的价值之和 for(int i=0;i&lt;n;i++)//按照排好的顺序贪心 { if( m&gt;s[i].w )//如果宝物的重量小于毛驴剩下的承载能力 { m-=s[i].w; sum+=s[i].v; } else//如果宝物的重量大于毛驴剩下的承载能力 { sum+=m * s[i].p;//部分装入 break; } } cout&lt;&lt;&quot;装入宝物的最大价值 Maximum value=&quot;&lt;&lt;sum&lt;&lt;endl; return 0;} 注意如果物品不能被分割，就不能采用贪心算法。 leetcode12. 整数转罗马数字 生活中的经验： 在以前还使用现金购物的时候，如果我们不想让对方找钱，付款的时候我们会尽量选择面值大的纸币给对方，这样才会使得我们给对方的纸币张数最少，对方点钱的时候也最方便。 本题“整数转罗马数字”也有类似的思想：在表示一个较大整数的时候，“罗马数字”的设计者不会让你都用 11 加起来，我们总是希望写出来的“罗马数字”的个数越少越好，以方便表示，并且这种表示方式还应该是唯一的。 “罗马数字”与阿拉伯数字的对应关系表中，并且按照从大到小的顺序排列。 罗马数字 阿拉伯数字 M 1000 CM 900 D 500 CD 400 C 100 XC 90 L 50 XL 40 X 10 IX 9 V 5 IV 4 I 1 于是，“将整数转换为罗马数字”的过程，就是用上面这张表中右边的数字作为“加法因子”去分解一个整数，目的是“分解的整数个数”尽可能少，因此，对于这道问题，类似于用最少的纸币凑成一个整数，贪心算法的规则如下： 每一步都使用当前较大的罗马数字作为加法因子，最后得到罗马数字表示就是长度最少的。 123456789101112131415161718192021222324252627public class Solution { public String intToRoman(int num) { // 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中 // 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想 int[] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; String[] romans = {&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;}; StringBuilder stringBuilder = new StringBuilder(); int index = 0; while (index &lt; 13) { // 特别注意：这里是等号 while (num &gt;= nums[index]) { // 注意：这里是等于号，表示尽量使用大的&quot;面值&quot; stringBuilder.append(romans[index]); num -= nums[index]; } index++; } return stringBuilder.toString(); }}作者：liweiwei1419链接：https://leetcode-cn.com/problems/integer-to-roman/solution/tan-xin-suan-fa-by-liweiwei1419/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 参考文章:参考链接1参考链接2","link":"/Algorithm/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E7%A4%BA%E4%BE%8B.html"},{"title":"github Issue 作为博客微型数据库的应用","text":"背景众所周知，对于hexo框架搭建的静态博客，难免会产生一些动态的数据，比如一些碎碎念、友链、音乐、时间轴等微型数据。目前一般的做法: a.是创建一个json数据，来存储这些微型数据，但是如果数据太多的话，一是比较慢，二是有个硬伤问题，就是json数据不能分页请求，只能一次拿完，太多的话网络带宽占用太多。 b.或者有的直接后台写一些接口服务啥的，还得在买个服务器部署上去，然后博客中访问接口。 c.或者有些可能就直接写到html中。 对于a、c方法都比较麻烦，每次更新了都要编译部署，不能很方便的动态更新。对于b的话，成本以及技术要求可能就更多一些了。 基于上面出现的问题，目前想到的一个解决方案就是，利用github 的issue作为一个微型数据库。能够很方便的动态更新，也能分页，也不需要啥json文件，想想都很方便。 issue数据库使用步骤issue的创建先创建一个Repository，对于此Repository可以专门作为微型的数据库，取名issue_database。创建好之后建立一些issue 如下所示 目前博客中，所有的动态数据都放到issue中了。 issue中存储数据对于创建好的issue，就可以往里面写数据了，比如我的友链数据为issue：blog_friends 对于issue中存储的数据最好存json格式的，因为可以方便后面取出来使用。存储好数据后，如果太多的话，可以点击hide,隐藏起来。同时这个issue最好给Lock conversation这样的好处是，防止别人往里面加些脏数据，只能自己往里写数据。哈哈，一般也没有闲的无聊的网友恶作剧。这样就存储好数据了。 博客中获取issue数据博客中通过js获取issue中的数据，以博客友链为例，以下是获取代码，以及处理 1234567891011121314151617181920// author by removef// https://removeif.github.io/$(function () { //获取处理友链数据，来自issue，一次取完 $.getJSON(&quot;https://api.github.com/repos/removeif/issue_database/issues/2/comments?per_page=100&amp;client_id=46a9f3481b46ea0129d8&amp;client_secret=79c7c9cb847e141757d7864453bcbf89f0655b24&quot;, function (source) { var data = []; var source1; source1 = source; // 以后每次更新的都在后面，此处倒序，按时间降序排 source1.reverse(); // 把所有的数据放到data的列表中 $.each(source1, function (i, e) { data.push(...JSON.parse(e.body)); }); $.each(data, function (i, e) { // 博客中html文件的构建，渲染 });}); 上面代码中client_id、client_secret在另一篇文章中**博客源码分享**有详细的说明,可以查看一下。这样就能获取到相应的数据，进行操作。 issue数据的更新比如想更新任意一项数据都可以进github中对应的仓库的issue下进行更新，添加。然后实时去博客中查看。 扩展一下对于有些爱唠叨的人（比如我），弄个类似碎碎念的东西就比较实用了。之前想过各种方案，存json数据太不方便；后台写个服务部署服务器也太麻烦。最后思来想去还是利用了下现成的优秀项目gitalk,稍稍改改就能很好使用。 博客中的碎碎念对于博主而言，有发表框和修改的操作，能够方便发表和修改。 可能有时候还会发表一些图片，对图片的样式做了一些控制 对于网友的话只能查看以及点赞加❤️ 做法就是源码中改下返回html的文件内容，如果是管理员和非管理员返回一些不同的元素，能够很好的实现碎碎念的功能。查看碎碎念。 总结静态博客的动态数据是个痛点，GitHub Issue有很多可利用的地方。多去探索发掘其中的奥妙。 利用GitHub Issue来解决目前也是一种解决方法。希望后面会出现更好的解决方案。","link":"/Blog/github-Issue-%E4%BD%9C%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%BE%AE%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%BA%94%E7%94%A8.html"},{"title":"github page网站cdn优化加速","text":"CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科 放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。 图片加速关于图传以及GitHub作为图库的使用方法请参考文章：博客图片上传picgo工具github图传使用。 在上面参考文章的基础之上只需要修改以下配置：（指定相关cdn域名） 原来项目中使用了原来的方式，进行全局替换，Mac idea直接快捷键command+shift+R全局替换 【ps：题外话】原来是统一用的GitHub的仓库中的图片，通过这样替换，可以看到图片统一管理是多么的重要，多么的方便管理操作。 至此，博客中的相关图片都加上了cdn。 其余资源文件用法： 1https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 例如： 123https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.pnghttps://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.csshttps://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4 注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下： 123456789101112131415161718// 加载任何Github发布、提交或分支https://cdn.jsdelivr.net/gh/user/repo@version/file// 加载 jQuery v3.2.1https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js// 使用版本范围而不是特定版本https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js// 完全省略该版本以获取最新版本https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js// 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js// 在末尾添加 / 以获取资源目录列表https://cdn.jsdelivr.net/gh/jquery/jquery/ 至此，github page 博客基本需要加速的完成。 参考文章:参考链接1参考链接2","link":"/Blog/github-page%E7%BD%91%E7%AB%99cdn%E4%BC%98%E5%8C%96%E5%8A%A0%E9%80%9F.html"},{"title":"不蒜子统计常见问题","text":"不蒜子统计官网：http://busuanzi.ibruce.info/ 详细使用教程：http://ibruce.info/2015/04/04/busuanzi/ 目前支持的功能：（两行代码，搞定计数；方便、简洁、实用） a、显示站点总访问量 b、显示单页面访问量 c、显示站点总访问量和单页面访问量 d、只计数不显示 关于怎么实现当天、昨天、本月、上月（即具体时间段）的访问量目前没有支持，请配合目前不蒜子支持的功能自行实现。 1.常见问题400错误，统计不生效 如图（1）的地方没有加载出统计数据 此时F12打开浏览器控制台，找到（2）network地方，刷新一下页面找到（3），请求统计的网址如图所示，查看（4）referrer-policy是否如图所示，如图的话是不能访问的，需要更改。 导致此问题原因，检查网页源码中，一般header有如下标签 解决方法，去掉此标签，之后访问如下（1）已有统计值，（2）已改变。可详细对比正常使用不蒜子统计网址https://removeif.github.io/ 中请求busuanzi?jsonpCallback=BusuanziCallback_236107382952地址的请求和返回参数的差异！ 这样设置带来的影响，可能有些图床的图片不能显示，会图裂，如新浪图床。解决方法，可以用其他不冲突的图床。 2.统计访问数巨大（清零问题）http://localhost:4000/ 或http://127.0.0.1:4000/ 访问时，统计数巨大，这是正常的，不用清零。部署到线上，用线上域名网址访问数据就正常了。 3.统计无法访问如图所示 查看红色url部分如下所示 此问题是Request URL填写错误，请确保Request URL前部分为http://busuanzi.ibruce.info/busuanzi?，，，，如下 同时查看Response，出现如下数据，就是成功访问了不蒜子统计，如果网站中还没出统计数据，就是自己的代码写错了，检查代码 4.其余问题(1).同一个页面，同名的id标签确保只能放一个如下 1234&lt;span id=&quot;busuanzi_container_site_uv&quot; style=&quot;display: inline;&quot;&gt; &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt; 同一个页面id名为busuanzi_value_site_uv只能放一个! (2).safari（包括移动端的safari）浏览器页面pv统计问题，如下，因为Safari浏览器referer在文章页面时也上送的域名（而单个页面的pv统计是根据页面路径，即上送的referer），所以此时页面的pv返回的站点的pv值。暂时没解决方法，可自行搜索解决方案构造正确的referer值。对于此问题可以换个浏览器看哇，比如Chrome，哈哈。 (3).部分live2d可能与不蒜子统计有冲突，出现此问题时，请查看网页源码引用统计id处是否被隐藏，一般网页上会自动加上display: none;自行选择性的使用。网友的解决方法，修改源码为以下，并引用修改后的js文件 不蒜子源码文件： 修改为如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990var bszCaller, bszTag;!function() { var c, d, e, a = !1, b = []; ready = function(c) { return a || &quot;interactive&quot; === document.readyState || &quot;complete&quot; === document.readyState ? c.call(document) : b.push(function() { return c.call(this) }), this } , d = function() { for (var a = 0, c = b.length; c &gt; a; a++) b[a].apply(document); b = [] } , e = function() { a || (a = !0, d.call(window), document.removeEventListener ? document.removeEventListener(&quot;DOMContentLoaded&quot;, e, !1) : document.attachEvent &amp;&amp; (document.detachEvent(&quot;onreadystatechange&quot;, e), window == window.top &amp;&amp; (clearInterval(c), c = null))) } , document.addEventListener ? document.addEventListener(&quot;DOMContentLoaded&quot;, e, !1) : document.attachEvent &amp;&amp; (document.attachEvent(&quot;onreadystatechange&quot;, function() { /loaded|complete/.test(document.readyState) &amp;&amp; e() }), window == window.top &amp;&amp; (c = setInterval(function() { try { a || document.documentElement.doScroll(&quot;left&quot;) } catch (b) { return } e() }, 5)))}(),bszCaller = { fetch: function(a, b) { var c = &quot;BusuanziCallback_&quot; + Math.floor(1099511627776 * Math.random()); window[c] = this.evalCall(b), a = a.replace(&quot;=BusuanziCallback&quot;, &quot;=&quot; + c), scriptTag = document.createElement(&quot;SCRIPT&quot;), scriptTag.type = &quot;text/javascript&quot;, scriptTag.defer = !0, scriptTag.src = a, document.getElementsByTagName(&quot;HEAD&quot;)[0].appendChild(scriptTag) }, evalCall: function(a) { return function(b) { ready(function() { try { a(b), - // 此处为修改的逻辑- scriptTag.parentElement.removeChild(scriptTag)+ if(scriptTag != null &amp;&amp; scriptTag.parentElement != null){+ scriptTag.parentElement.removeChild(scriptTag)+ } } catch (c) { bszTag.hides() } }) } }},bszCaller.fetch(&quot;//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback&quot;, function(a) { bszTag.texts(a), bszTag.shows()}),bszTag = { bszs: [&quot;site_pv&quot;, &quot;page_pv&quot;, &quot;site_uv&quot;], texts: function(a) { this.bszs.map(function(b) { var c = document.getElementById(&quot;busuanzi_value_&quot; + b); c &amp;&amp; (c.innerHTML = a[b]) }) }, hides: function() { this.bszs.map(function(a) { var b = document.getElementById(&quot;busuanzi_container_&quot; + a); b &amp;&amp; (b.style.display = &quot;none&quot;) }) }, shows: function() { this.bszs.map(function(a) { var b = document.getElementById(&quot;busuanzi_container_&quot; + a); b &amp;&amp; (b.style.display = &quot;inline&quot;) }) }}; 5.官方群！！！群号：419260983，有其余问题进群讨论，提问时遇到其他的问题请同时发出问题的在线网址！！！","link":"/Blog/%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"},{"title":"博客图片上传picgo工具github图传使用","text":"摘要对于每一个写博客的人来说，图片是至关重要。这一路经历了多次图片的烦恼，之前选择了微博个人文章那里粘贴图片的方式上传，感觉也挺方便的。但是由于新浪的图片显示问题，如果header中不设置 标签就不能异步访问图片，导致图裂，那之恶心。然而设置之后又与网站访客统计的插件冲突，使之不能统计，真是神仙打架。无赖之下使用了PicGo工具，使用后感觉真XX方便！ PicGo工具下载安装配置下载 .PicGo下载 github网站提供三个版本的下载，MacOs、linux、windows覆盖市面上90%系统，还是很给力了。 我是mac用户，直接使用brew cask来安装PicGo: brew cask install picgo，简直方便到爆。 配置 PicGo配置(使用github图传，免费方便，同时配合github.io博客真是方便) 选上必填的就ok,一开始不知道token的设置，附赠token获取方法 图片上传相关的设置 链接格式：选择适合自己的，一般用户md文件中，选第一个，然后就可以疯狂使用了。 使用github图传，获取token在github-&gt;setting-&gt;developer settings 选择generate new token 勾选好之后生成就好了 使用 PicGo使用，简直方便 1).默认网页上直接右键复制图片 2).点击等待中的图片，开始上传 3).上传完之后有个提示，同时粘贴板也会自动粘贴上 4).直接粘贴到想要的地方 或者也可以直接截图，然后点击图片里的图片上传，很方便 PicGo上传动图gif 如果直接复制网页上的动图，去上传的话是截取的某帧，是静图。应该下载到本地，然后在拖进去上传就可以了。","link":"/Blog/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0picgo%E5%B7%A5%E5%85%B7github%E5%9B%BE%E4%BC%A0%E4%BD%BF%E7%94%A8.html"},{"title":"","text":"环境搭建 下载 VSCode（编辑器） 下载 Node.js （环境） 下载 npm install hexo-cli -g（HEXO命令安装） 创建文件夹运行 hexo init （初始化环境） 导入博客 下载博客模板导入根目录下的 themes 文件里，开发配置博客 博客上传环境配置 npm install hexo-deployer-git –save npm install hexo-generator-index –save // 所有文章是要 npm i hexo-generator-json-content –save /*****/ hexo clean # 清除缓存文件等hexo g # 生成页面hexo s # 启动预览hexo d # 部署发布访问 http://localhost:4000，出现 Hexo 默认页面，本地博客安装成功 部署 Hexo 到 GitHub Pages 首先安装 hexo-deployer-git： npm install hexo-deployer-git –save 绑定域名（腾讯域名） ping PrivateBlogs.github.io 获取IP地址 Error:","link":"/Blog/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%B4%E6%98%8E.html"},{"title":"博客换肤的一种实现方式思路","text":"当博客内容很多的时候，比如需要加载很多资源文件，许多炫酷的东西的时候，可能相应的就是比较慢了（正可谓时间和空间不能兼得）。虽然目前也有很多方式手段可以提高访问速度，但是博客提供一个简洁模式还是很有必要的，萝卜青菜，各有所爱嘛。说不定很多网友就当纯的想看看文字，不需要那些花里胡哨的东西。这时候提供个清爽模式就相当有用了。 正常模式和精简模式hexo框架2仓2主题，采用正常模式一个仓库，一个主题；精简模式另一个仓库，另一个主题。 本博客采用的github Page部署网站。大家都知道，一个github的账户名，只能够指定一个username.github.io的网址，所以两个仓库，两个主题的话，就必须有一个挂在username.github.io之上，比如正常模式username.github.io，精简模式为username.github.io/name.io。 正常模式正常模式里面可以放各种炫酷的东西，提供丰富的页面。 精简模式只提供必要的文章，归档，分类，搜索基本的东西就够了。看个人需要，既然要简洁，就尽量的少弄一些。 配置方法关于_config.yml主配置文件的注意事项。 12345678910111213+ root: /remove.io/ #精简模式- root: / #正常模式deploy: type: git+ repo: https://github.com/removeif/remove.io.git #精简模式- repo: https://github.com/removeif/removeif.github.io.git #正常模式+ theme: icarus #正常模式- theme: nextn #精简模式 对于root 根节点的说明，因为精简模式的所有资源文件都是挂在 username.github.io/remove.io/ 所以相当于根节点为/remove.io/ 总结注意事项 对于页面中对于对应模式下资源文件的引用，一定加上域名地址 ，比如原来图片访问/image/tuizi.jpg，在精简模式的时候如果继续这样用，就找不到，对应模式下的图片了，需要加上前面的username.github.io/remove.io/ 地址。 对于精简模式下，能去掉的东西就尽量去掉，尽量少加载一些，速度更快。 对于冲突页面的处理，一般对于文章或者关于页面都是通用。文章一般没啥影响，但是关于页面，可能有些也有很炫酷的模块。对于精简模式，可能不需要，此时就需要多new 一个page页面，分开配置，比如下面主题中的_config.yml配置。 12+ /remove.io/abouta/ #精简模式- /abouta/ #正常模式 本博客正常模式 精简模式 以上只是提供了一种解决方法思路，肯定还有更好的方式。","link":"/Blog/%E5%8D%9A%E5%AE%A2%E6%8D%A2%E8%82%A4%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%80%9D%E8%B7%AF.html"},{"title":"安装、部分配置icarus主题中文版","text":"摘要发现icarus主题还不错，花了一两个小时研究了下安装、部分配置icarus主题中文版 安装icarus 直接下载主题模块放到blog项目 ,blog项目根目录执行 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 此时已经下载到项目中。 顶级_config.yml中选择icarus主题 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus 此时主题已经安装好，清除、编译、部署可以看到效果了 配置icarus 完全参照官网配置，进行翻译解说 配置文章部分顶部图片添加icarus 主题中的配置_config.yml中开启图片开关 12article: thumbnail: true 文章.md文件头中添加图片绝对/相对地址 12345title: Getting Started with Icarusthumbnail: /gallery/thumbnails/desert.jpg// thumbnail:https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620152744.png---Post content... 配置完成后部署显示效果如下(最新文章列表显示缩略图、文章开头显示一张设置图片) 左边文章导航栏开启icarus 主题中的配置_config.yml中开关 1234widgets: - type: toc position: left 同事文章顶部加入标签 1234title: Table of Contents Exampletoc: true---Post content... 配置效果 评论系统开启icarus 主题中的配置_config.yml中开启（部分评论系统需要翻墙才能使用，valine不用翻墙个人推荐，valine安装参考） 1234567comment: type: valine app_id: xxxxxxxx # (required) LeanCloud application id app_key: xxxxxxxx # (required) LeanCloud application key notify: false # (optional) receive email notification verify: false # (optional) show verification code placeholder: xxxxxxxx # (optional) comment box placeholder text 开启效果 捐赠收款开启icarus 主题中的配置_config.yml中开启 注意如果默认不配置，编译时有报错，可以# 把它注释掉，不启用功能 1234567891011donate: - # Donation entry name type: alipay # Qrcode image URL qrcode: 'https://wx2.sinaimg.cn/large/b5d1b710gy1g0lvxdcwm0j20p011i4bg.jpg' - # Donation entry name type: wechat # Qrcode image URL qrcode: 'https://wx2.sinaimg.cn/large/b5d1b710gy1g0lvwdcpb5j20u014qgy2.jpg' 开启配置效果如下 全局搜索开启icarus 主题中的配置_config.yml中开启,不同的搜索类型需要安装插件参考官网,type: insight此类型不需要安装，已经内置 123search: type: insight 效果如下 更多配置请参考官网配置目前配置基本已经够使用，还需要更多配置请参考连接 参考自","link":"/Blog/%E5%AE%89%E8%A3%85%E3%80%81%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AEicarus%E4%B8%BB%E9%A2%98%E4%B8%AD%E6%96%87%E7%89%88.html"},{"title":"英语语法-介词","text":"介词特点：不能单独使用，后面需带宾语（名词，代词，数词，动名词，动名词短语，名词从句）搭配：在介词前的词：动词（depend on）名词（pay attention to）形容词（be kind to） 充当： 与其宾语构成介词短语后可充当主语，补足语 ，定语，状语 作用：词与词之间的表示关系 种类：简单介词（at, by, for, from, in,near, of, off, on）复合介词​ 简单链接：inside, into, onto, out of, outside, throughout, upon, within, without ​ 搭配连用：as to, from above, from behind, from beneath, from under, until after 介词短语： at the cost of, at the mercy of, at odds with, by means of, by reason of, by virtue of, by way of, in place of, in favor of, in spite of, with an eye to. 关于：in/with reference to, in/with respect to, in/ with regard to 时间介词：1.at, in, on1)at(时间点)​ a.特定时刻：at nine after ten ​ b.不确定时刻：at night, at dawn, at midnight, at that time, at the moment, at Christmas ​ c.年龄段： ​ at the age of eight/at eight ​ He got married at twenty 2)in(时间段)​ a.长时间段 ​ in the morning/afternoon/evening ​ in spring/summer/autumn/winter ​ in the past, in the past ten years ​ in the twenty-first cenfury ​ a man in his thirties ​ b.在时间之内/后，表将来时 ​ He said he would come back in a month ​ The train is leaving in a minute ​ c.in+动名词：在做…过程中 ​ In crossing the river, we caught some fish. ​ In working, we can learn a lot. ​ d.几月：in October 3)on(表示具体日期)​ a.具体日期和星期 ​ on Monday On my birthday ​ b.特定某天上午、下午等 ​ On the night of December 31,1999 ​ On the eve of christmas/New Year ​ On a hot midnight in July ​ c.在第几天 ​ On his first day to school. ​ On the tenth day I was in Beijing. ​ d.on+动名词 or 名词 = as soon as：一…就… ​ On hearing the bad news, she burst into tears. ​ On arriving, I came directly to visit you. ​ The first thing I did on arrival of Beijing was visit him. at the beginning of 在..的开头 ​ at the begining of a book there is often a table of contents. ​ at the begining of the concert. ​ at the beginning of January. in the begining：at first = in the early stages ​ In the begining, I wrote to my family regularly. later I just gave up at the end of ​ But at the end of this process, unfortunately, the students are none the wiser. ​ At the end of abook there may be an index ​ At the end of the concert at the end of January in the end：eventually = at last：最终…. ​ Jim couldn’t decide where to go for his holidays. He didn’t go anywhere in the end. 有last/next/this/every不再加介词 ​ I’ll see your next Friday. during for ​ during在…期间内，强调这时间内发生了什么 for表示延续时间的长短 ​ I had lived in the countryside for 8 years before I moved to Beijing. ​ I studied in this university for 4 years. During that time most of my time was spent in learning English. ​ My father was in hospital for six weeks during the summer. during接表示一段时间的名词：stay， visit，travel ​ During my visit to China ​ During the travel to the south ​ During the Middle ages for+时间段​ for six years for two months for ever for two hours from​ 和to 或 till/untill连用 ​ Most people work from nine to five. since​ 和时间点连用，从那一时刻起。现在完成时，过去完成时连用 ​ He has been here since last Sunday ​ I haven’t seen him since two years ago ​ I haven’t seen him for two years ​ It’s two years since I last saw him for和时间段连用，表示动作延续到说话的那一刻。现在完成时，过去完成时连用 ​ I have lived here for a year ​ I have lived here since this time last year before, after, till/until(可做介词接短语，可做连词接从句) ​ 后接时间点，某时刻前（before）某时刻后（after）直到某一时刻（till/until） ​ We finished the work before 10 o’ clock ​ I’ll wait for you till 10 o’ clock till/until特点​ 延续性句子谓语(肯定)+till/untill+时间点（若是从句，则从句中谓语动词为短暂性动词） ​ 短暂性句子谓语(否定)+till/untill+时间点（若是从句，则从句中谓语动词为短暂性动词） ​ He didn’t finish the work untill 10 o’ clock（finish短暂动词，用否定） ​ He didn’t leave the office till 12 o’ clock ​ He will stay here until next Sunday（stay延续性动词，用肯定） by​ a.no later than：不迟于某个时间，到了某个时间 ​ by the end of next year ​ b.by引导时间状语常与将来完成时 or 过去完成时连用 ​ By the end of next year I’ll have learned 2000 words ​ By the end of last year I had learned 2000 words 方位介词at, in at表示小地方 at home, at the office, ata school, at the bridge, at the crossroads, at the bus-stop at the doctor’s, at the hairdresser’s in表示大地方 in a country, in a town, in a village, in the street, in the forest, in a field, in a desert 其他情况 in a line/in a row/in a queue in a photo/in a picture in a mirror in the sky/in the world in a book/in a newspaper/in a magazine/in a letter in the front/back row(at the front/back) in the front/back of the car at the front/back of the building/cinema/classroom 谈论建筑 at表示事情发生场合 I met him at the cinema last night. in表示建筑物本身 I enjoyed the film but it was very cold in the cinema in强调在建筑里，at包括建筑物周围及里面 at the restaurant(可以是餐馆内，也可以是在餐馆附近的某个地方) in the restaurant(在餐馆里) at the cinema(在电影院，不一定在里面) in the cinema(在里面) There were a lot of people in the shop, It was very crowed Go along this road, then turn left at the shop on, over, above on表示两者接触 Put away the books on the desk The dictionary on the table is not mine There is some water in the bottle There is a label on the bottle There is somebody at the door. Shall I go and see who it is? There is a notice on the door. It says “Do not disturb” on的其他情况 on the left/on the right on the first/second floor on a map on the page/on page seven(at the top/bottom of the page) on the menu on the list on a farm on the way to school on the corner of street, in the corner of the room over不仅接触，还有覆盖的含义 Spread the cloth over the table Mon put a rug over me when I was asleep over还可以表示正上方 There is a bridge over the river There is a lamp over the desk above仅表示上下位关系，不接触，也不是正上方 The sun rose above the horizon There is a bridge above the river He is over me(He is my immediate superior) He is above me below,under,beneath under在下方，可接触，可不接触 I put the money under the mattess The dog is groveling under the table below表示两个表面之间间隔距离 They live below us beneath可以替换under，但是偏向抽象含义 He would think it beneath him to tell a lie She married beneath her 手段介词by 表示行为方式 send something by post do something by hand pay by check/by credit card(pay in cash) 某事发生：by mistake/by accident/by chance(on purpose) 表示交通工具 by car, by train, by plane/air, by boat/sea/ship, by bus, by bicycle, by metro/subway/underground(on foot) by car(in a car, im my car, in the car) I don’t mind going by car but I don’t want to go in your car car, taxi前用介词in They didn’t come in their car. They came in a taxi. 自行车和公共交通设施前用on on the train/by train, on his bicycle/by bicycle 表示通过 某种手段达到预期效果（与with区别） We succeeded by cooperating with them Our mission is to help our clients achieve their business goals by providing a service for the timely delivery of qualified staff to support their operational needs. with 表示用具体的工具做某事 I killed a fly with a flyflap We can see with our eyes and write with our hands in 表示以某种方式做某事 Write in pencil/in ink Express this in your own words Speak in a low voice Pay in installments through 与by相近，through一般多根名词连用， by多跟 动名词连用 they talked to each other through an interpreter. 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E4%BB%8B%E8%AF%8D.html"},{"title":"英语语法-关系从句","text":"概念：用句子修饰另一句子中的概念(词 to 整个句子) 单词：The woman who lives next door is a famous dancer. 短语：He likes climbing mountains, which is a good exercise. 分句：He said that he had no time, which isn’t true. 整句：He arrived an hour later, which annoyed his girlfriend very much. 形成：两个句子共用的概念为连接点 He laughs best who laughs last. ​ 句子1. he laughs best 句子2. he laughs last 关系词 who ​ 共用He，句1：描述事实，句2：限定作用 种类：形式区别：有无 “，”限制性：提供必要信息，若去掉，含义不明 I don’t like people 意思不明 I don’t like people who never keep their words. 非限制性：补充附加信息，若去掉，含义仍明 Beijing, which is the capital of China, has developed into an international city. 关系词：根据关系词在从句中充当的成分，被分为：关系代词，关系副词关系代词 关系代词 用法 例句 who:只指人 前不可加介词 The girl who you work with is his girl friend whom:只指人 只宾/表,宾语非限制性必用 Li, with whom you work, is his girl friend which:不指人 非限制性句首时用as As I expected, he didn’t believe me that:指人or物 不加介词，无非限制性 The world in which we live is made up of matter. whose+名词指人or物 whose = of which These children sit in a schoolroom of which all the windows are broken. 特殊关系代词as：正如 限制性：只能用在such，the same，as，so ​ a. He’ll repeat such points as are discussed in the book. ​ b. Such a student as works hard will be sure to succeed. ​ c. He tried to make as few mistakes as he could avoid. ​ d. He is not the same playboy as we knew. 非限制性：位于句首必须用as As is known, the whale is not fish but a mammal. 代替全句：as：主从句内容一致 which：主从句内容互斥 She has married again, as was expected. She has married again, which was unexpected. what：等于 先行词 + 关系词单独使用：不能有先行词 She is not what she used to be = She is not the girl that she used to be. what+名词：所有的… a. I will give you what help I can. b. What money I have has been given to you = All the money that I have… 辨析：结构上也可以理解成名词从句，意思上如下 名词从句：整个句子的意思 What he said shows that he is cruel. what从句：只指what这个人或物 He is not what he was a few years ago. than：主句有比较级 a. Don’t drink more wine than is good for health. b. Don’t give him more money than is needed, since money will burn a hole in his pocket. but：eq that/who/whom…not ​ a. There is no man but errs = There is no man who doesn’t err. ​ b. There are few but admire his talent = There are few who don’t admire his talent. ​ c. There are very few people in this club but he knows =whom he doesn’t know. 关系副词限制性 or 非限制性 从句中必做状语 关系副词 先行词 例句 when=on which 时间:day,year,time I’ll never forget the day (when) I met you(紧随其后可省略)I’ll never forget the time which I spent on campus(不做状语时) where=in/at which (抽象)地点place,housesituation, point,joint When you read books, you had better make a mark at the spot where you have any question(定语从句修饰spot)When you read book, you had better make a mark where you have any question(状语从句) why无非限制性 原因:why等 This is the reason why I didn’t come herewhy = for which 方式the way in whichthat省略 You know the old golden rule, “Care for others the way in which you would like them to care for you” 介词+关系代词(whom/which/whose)动词/形容词搭配的介词，可前可后 线索 说明 例句 从句中介词和动词搭配形容词搭配名词搭配 最常用常见较少 He is the man on whom I think you can depend.He referred me to some books with which I am not very familiar.I am sending you an inquiry, to which your prompt attention is highly appreciated. 介词先行词搭配 at the ratewith ease The speed at which an animal lives is determined by measuring the rate at which it uses oxygen. 修饰部分of which 最高级+of whom/which The total cultivated area is 13,000 acres, of which 10,000 acres are irrigated fields. in which to do 此结构注意 A house in which to store grains = A house to store grains inI can’t think of anybody whom to invite 没有介词不能用介词不能置后不能用关系副词代替 引导词辨析 从句 that which 定语从句 充当成分The rumor that he spread everywhere turned out to be untrue.(充当定语) 单独使用Anger is a wind which blows out the lamp of the mind. 名词从句 不当成分THe rumor that Tom was a thief truned out to be untrue.(句子完整) which + 名词连用You should vote for which candidate you assume best. 复杂定语从句 定语从句后置 先行词和定语从句分开 Consequently, nothing seems good or normal that does not accord with the requirements of the free market. 带有插入语 表达个人观点紧跟关系词后 He ran all the way from the station, which I thought was incredible. 并列定语从句 and/or/but连接多个从句修饰同一词 I’d much rather receive a gift that was unique or that I knew my friend had put some thought into. 嵌套修饰 定语从句修饰“先行词+定语从句” He is the only person that we know who speaks so many foreign languages. 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%85%B3%E7%B3%BB%E4%BB%8E%E5%8F%A5.html"},{"title":"英语语法-人称代词","text":"主格人称代词 作用：主句或从句中做主语 ​ She is my daughter. ​ It was he who helped me when I was in trouble. 顺序： you, he and I ； We, you and they（I总是 放在最后） 表示泛指的主格代词 one：任何人，包括说话人 ​ One is knocking at the door.(错误，说话人不算，所以不能用one) ​ Somebody is knocking at the door. ​ One后面使用的代词，美国一般用he，him，himself，his. We/You/They 可以表示泛指：人们 ​ They say = People say or It is said ​ They say it is going to be a cold winter. she(her)的拟人化：表示country, motherland, moon, earth, ship. ​ The ship lost most of her rigging in the storm 宾格人称代词 作用：做宾语（也可做表语） ​ I like her. ​ Who is it? It’s me. ​ 注意：做表语时，后面跟定语从句时，需要用主格人称代词。 ​ It was he in whom we had the greatest faith(he在从句中做介词宾语) 主格和宾格人称代词可以做同位语： ​ We teachers should be patient with students. ​ Our teachers are all nice to us students. 做宾语时的位置 直接宾语前： He bought me a pen as birthday gift. 直接宾语后：He bought a pen for me as a birthday gift ; I’ve lent much monery to him. 若直接宾语是人称代词，只能置后，但是不适用于不定代词： ​ I will give it to you. ​ I‘ll show you something ; I didn’t give Rex any. 在短语动词中间：Hand them in ; throw it away ; pick it up. ​ 若是名词，则中间和后边都可：hand your papers in = hand in your papers. 物主代词(名词性&amp;形容词性)作用：人称代词的所有格形式，表所有关系。 形容词性：不能单独使用： Your book is over there ; His sister is lovely. ​ 表强调时后+own：I wish I had my own house. 名词性：单独使用；避免重复：This is not my book. Mine(=my book) is in my bog. ​ of + 名词性物主代词： a friend of mine ; a teacher of hers= a teacher of her own. 反身代词 必须主语宾语为同一人时，做宾语：God helps those who help themselves. 强调主语： ​ He himself went to visit the old lady(他亲自去看望那个老太太的) ​ 不产生歧义下可置后： ​ He went to visit the old lady himself. ​ He spoke to the boss himself.（有歧义） 强调宾语：反身代词在宾语后 ​ He saw Tom himself(他看到Tom本人了) ​ I will send this gift to John himself(给john本人，不是通过转交) 介词+反身动词 ​ （1）by oneself：独自一人地 ​ I went there by myself(我自己一个人去了那里) ​ I went there myself(我亲自去了那) ​ （2）of oneself：自动地 ​ The door opened of itself(门自动地开了) 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E4%BA%BA%E7%A7%B0%E4%BB%A3%E8%AF%8D.html"},{"title":"英语语法-副词","text":"时间副词种类​ 1.确切时间：yesterday, today, now, tomorrow ​ 2.不确切时间：already, recently, lately, before, soon, then, afterwards ​ 3.副词短语：this morning, last night, in the morning, a week ago, three months ago, ​ at once, in a while, in recent days. 位置​ 确切时间副词：句首 or 句末(更常见)（祈使句只在句末） ​ Tomorrow I’m leaving for Beijing on a businiess tour. ​ I’m leaving for Beijing on a business tour a week ago. ​ Come to my office this afternoon. ​ 不确切时间副词：句首 or 句中 or 句末 ​ Very soon we’ll be there ​ We’ll very soon be there ​ I have been busy recently. ​ before, early, immediately, late 句末 ​ Ｉhave never heard such a story before. ​ He came to school late. ​ 总结：句末保险，句中的副词不多，祈使句只在句末。 地点副词种类​ 1.表示方向：away, down, in, off, on, over, out, round, up ​ 2.表示位置：here, there, somewhere, anywhere, nowhere, everywhere ​ 介词短语：in the park, at home, in the street 位置（一般：动词后）​ 1.方向副词在地点副词之前：He often walks around in the garden after supper. ​ 2.大地点副词在后：He works in a foreign-funded company in Beijing. ​ 3.方向副词：away, down, in, off, on, over, out, round, up, here, there可以倒装 ​ 倒装1：副词+动态动词+名词主语 ​ Here comes the teacher. ​ Round and round flew the plane. ​ 倒装2：副词+物主代词+动态动词 ​ Away they went. ​ Here he comes. ​ 4.介词短语+动词+主语 倒装：down, from, in, on, over, out ,of, round, up ​ From the trees hang a lot of monkeys. ​ Down this street stand a lot of shops. ​ On the ground lies a man whose legs are broken. 总结：一般句末；有些倒装结构句首。 频率副词种类​ 1.确切频率：daily, weekly, monthly, yearly/annually, twice a week/month/year ​ 2.不确切频率：always, often, usually, sometimes, occasionally, frequently, continually, ​ repeatedly, once, ever, never, rarely, seldom(否定). 位置1.不确切频率在 句中​ 1)实义动词前(am, is, are, was, were)，助动词后(will, should, have) ​ a. I often do some shopping on weekends. ​ b. She is often late for school. ​ c. I have never seen him since we parted. ​ 2)多个助动词时，在第一个助动词后 ​ a. This project will never be finished. ​ b. You should never have trusted him. ​ 3)加强语气，在系动词 or 助动词 前 ​ a. You really will get a reward one day. ​ b. I always have been patient. ​ 4)只有助动词而省略了实义动词的句子，在助动词前 ​ a. You should have known better thaan to trust him. I never will(trust him) ​ b. Can you find a plaace to park your car in the street? Yes, I usually can. ​ 也要用在省略了标语的系动词前： No, she never was. 2.确切频率在 句末​ a. Milk is delivered daily. ​ b. We have meetings twice a week. 3.不确切频率也可用在句首 or 句末​ a. Often/Sometimes/Usually I work late into the night. ​ often不单独在句末，需加very or quite修饰 ​ b. He comes late for school quite often. 4.always除在祈使句中句首，其他时候在句末​ a. You always make the same mistakes. ​ b. Always remember not to argue with your boss. 5.否定句中的频率副词​ a.often/sometimes/usually not ​ His wife complains that he sometimes doesn’t listen to her. ​ b.not always ​ He doesn’t always leave before 6 o’clock, sometimes he works until 8 o’clock. 6.never, rarely, seldom​ a.不能再与not连用 ​ He seldom goes out at night. ​ b.若在句首则倒装 ​ Never have I heard such a story (I have enever heard such a story) ​ 总结：不确切频率在句中，确切频率在句末。 程度副词 意义：表示程度或大小，修饰形容词、副词、动词、甚至名词 位置：被修饰词前 比较 ​ Only I saw him at the party last night(Nobody else saw him) ​ I only saw him at the party last night(I didn’t talk to him) ​ I saw only him at the party last night(I didn’t see any other friends) ​ I saw him only at the party last night(I didn’t see him at other places) ​ I saw him at the party only last night(I didn’t see him until last night) enough：在所修饰形容词 or 副词之后 ​ He is not old enough to go to school ​ He didn’t work quickly enough 否定副词不与否定词连用 barely, scarcely, hardly ​ 注意：与频率副词rarely区别 ​ 不说：He hardly attends class ​ 应说：He rarely attends class 可以修饰名词的程度副词 ​ quite, only, even, particularly, especially, almost, rather. ​ quite some, quite an expert ​ It was quite a surprise. ​ rather a bore, rather a shame ​ 注意：quite在a/an前，rather可前可后 ​ quite a nice day. ​ rather a long way a rather long way. ​ vegetables, especially spinach, are good for you ​ He is almost a child ​ Even a boy knows the answer 方式副词 修饰：动词专用 构成：数目不固定，可由形容词+ly构成 位置：修饰动词的后边 有宾语时，宾语在前 I can’t speak English well.He can finish the job quickly. 若动词后成分很长，则在动词前 He firmly believes that he will succeed.I happily pronouce you man and wife. 动词+介词+宾语，可位于宾语后或介词前 The class is listening to the teacher carefullyThe class is listening carefully to the teacher 方式副词在被动分词之前 I was badly paid in that company when I just graduated.When do you think you will have completely finished? 句子副词 修饰：整个句子 位置：句首 意义： 表示说话角度：Geologically, a thousand years is a short time. 表示说话人态度：Frankly, I think he is dishonest. ​ Hopefully, we can get there in time 比较方式副词和句子副词 ​ 句子副词：Happily, he didn’t die. 幸好，他还活着 ​ 方式副词：He didn’t die happily. 他不是安然地离开了这个世界 其他位置 副词顺序：方式副词+地点副词+时间副词 ​ She sang an English song nicely in the auditorium last night. ​ She checked the accounts carefully in the office this morning. (不)确定性副词：probably, possibly, perhaps, certainly, definitely, surely.不在句末 ​ He has probably not been there before. ​ I definitely know how to deal with this matter. 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%89%AF%E8%AF%8D.html"},{"title":"英语语法-动名词","text":"做主语1. 直接句首做主语：谓语动词用单数​ a. Seeing is believing. ​ b. Reading is like permitting a man to talk a long time, and refusing you the right to answer. ​ c. Having a successsful marriage takes effort and patience, and communication is the key. 2. It is no good doing sth句型​ it形式主语，真正主语是doing sth ​ no可以替换为：any/some good, any/some/no use, a waste of time. ​ a. Is it any good trying to explain? ​ c. It’s not much use my buying salmon if you don’t like fish. ​ d. it’s simply a waste of time and money seeing that movie. 3. there be句型​ 1) there is no point (in) doing something,做某事没有意义 ​ a. there is no point in my going out to date somedone, I might really like if I met him a the time, but who, right now, has no chance of being anything to me but a transitional man ​ 2) there is no use/good (in) doing something ​ a. there is no use your arguing with him ​ b. there is no use your complaining to me about this. ​ 3) there is no doing something = it’s impossible to do something = we can’t do something. ​ a. there is no denying the fact that…毋庸置疑 ​ b. there is no gainsaying the fact that…毋庸置疑 ​ c. there is no telling what will happen tomorrow. ​ d. there’s no knowing the future = it’s impossible to know the future, or we can’t know it. 做宾语1. 一些动词后只能用动名词做宾语​ appreciate, avoid, consider, delay, dislike, enjoy, escape, feel like, finish, can’t help, invlove, ​ overlook, permit, postpone, practise, risk, can’t stand, suggest, tolerate, understand. ​ a. I will overlook your being so rude to my sister this time but don’t let it happen again. ​ b. Many of the things we do invlove taking some risk in order to achieve a sitisfactory result ​ c. Being a bad-tempered man , he would not tolerate having this lectures interrupted. 接动名词和不定式有区别的动词： 很多动词接动名词和不定式均可，但是意思有很大差别。 1. demand, deserve, need, require, want 动名词：主动形式表示被动 不定式：必须用被动形式 ​ a. The garden needs watering/ to be watered. 不说 The garden needs being watered. ​ b. Your hair needs cutting/ to be cut. 2. remember, forget, stop, go on, regret. 动名词：表示发生于这些动词之前的事 不定式：表示发生在这些动词之后的事 1) remember remember doing sth: remember/ recall something that happened in the past. 记得已做过某事 ​ a. I still remember being taken to Beijing for the first time. ​ b. I don’t remember/recall locking my suitcase ​ = as far as I know, my suitcase should be open remember to do sth: remember to perform a responsibility, duty or task. 记得需要履行的职责 or 任务。 ​ a. Remember to go to the post office, won’t you? ​ b. Remember to do some shopping after work. ​ c. Clint always remembers to turn off the lights when he leaves the room. 2) forget forget doing sth: forget something that happened in the past. 忘记了已做过的某事 ​ I forgot locking the door. So when I came back, I found the door locked. ​ as far as I know, the door should be open. forget to do sth: forget to perform a responsibility, duty or task. 忘记要做的事 ​ As well as getting on everybody’s nerves, he’s got a habit of borrowing money and forgetting to pay it back. 3) stop stop doing: 停下经常做的或手头正在做的事情 ​ I really must stop smoking. stop to do: 停下来去做某事 ​ stop to have a rest. 4) go on go on doing sth: 继续做一直在做的事情。 ​ a. The teacher went on explaining the text. ​ b. Peter went on sleeping despite the noise. go on to do sth: 改做另一件事 ​ a. He welcomed the new students and then went on to explain the college regulations. ​ b. Finishing the new words, the teacher went on to attack the text. 5) regret regret doing sth: regret something that happened in the past. 对已发生的事情感到遗憾 ​ a. I don’t regret telling her what I thought, even if it upset her. ​ b. I regret letting slip that opportunity. ​ c. I regret lending him so much money. He never paid me back. ​ d. Now he regrets not having gone to university. regret to do something: regret to say, to tell someone, or to inform someone of some bad news 遗憾的告诉或通知某人某个坏消息。 ​ a. We regret to inform you that we are unable to offer you employment. ​ b. I regret to tell you that you failed the test. ​ c. We regret to inform you that the flight has been cancelled. 动名词的其他结构1. have difficulty (in) doing sth​ trouble ​ problem ​ (a lot of fun) ​ (lots of) pleasure ​ a hard time ​ a good time ​ a difficult time 注意: take the trouble to do sth, trouble to do sth, have (no) time to do sth. ​ a. I worked sos late in the office last night that I hardly had time to catch the last bus. ​ b. I have a hard time getting used to living in a big place. 2. can’t help doing, can’t resist doing, can’t keep from doing, can’t hold back from doing​ can’t keep back from doing ​ 注意: can’t help but do, can’t but do, can’t choose but do,etc. ​ No one can help liking Tom; he is such a cute boy. 3. be worth doing值得做；主动形式表示被动​ be worthy of being done 或 be worthy to be done. ​ a. The book is worth reading. ​ b. The book is worthy of being read. ​ c. The book is worthy to be read. 动名词的复合结构物主代词(his, my ,your等)所有格名词(Mary’s Tom’s)与动名词连用，即构成动名词的符合结构。用来引出动名词的逻辑主语，以区别于句子主语。 Clint insisted on reading the letter. (Clint看了信) Clint insisted on my reading the letter. (我不得不看信) Would you mind telling us the whole story? (你告诉) Would you mind Tom’s telling us the whole story? = Would you mind if Tom tells us the story He disliked working late He disliked my working late I object to making private calls on this phone I object to his making private calls on this phone. 用法 做主语或宾语 ​ a. Tom’s coming home at last was a great consolation (做主语) ​ b. Do you mind my making a suggestion? (做及物动词宾语) ​ c. Our discussion of earthquakes would be imncomplete if we didn’t raise the possibility of their being caused by external forces. 物主代词(his)可以改为宾格代词(him) or 所有格名词(Tom’s)改成普通格名词(Tom) ​ a. It’s no use Tom arguing with his boss. ​ b. Do you mind me making a suggestion? ​ c. I am annoyed about John forgetting to pay. 应用原则：​ 1) 若动名词复合结构在句中做主语，最好用所有格形式 ​ a. Tom’s refusing to accept the invitation upset me. ​ b. His refusing to accept the invitation upset me. ​ c. It was a great consolation his coming home at last. ​ 2)动名词复合结构在句中做宾语时候，用普通格或所有格均可 ​ a. Do you mind me making a suggestion? ​ b. I am annoyed about John forgetting to pay. 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%8A%A8%E5%90%8D%E8%AF%8D.html"},{"title":"英语语法-句子类型","text":"特殊疑问句：疑问词+一般疑问句​ What time i convenient for you ​ How late are you open ​ Where were we ​ What was I just going to say ​ What’s in your mind ​ What’s going on ​ When did you begin to study English 一般疑问句：助动词+主语+谓语（yes or no 回答）选择疑问句：提供两种或两种以上情形提对方选择​ Do you like tea or coffee ​ Did you speak to them, or did the manager ​ Which ice cream would you like, chocolate, vanilla or strawberry. 反意疑问句：​ I am going to look like a lemon, aren’t I? ​ You have completed that job,haven’t you? ​ You have not completed that job, have you? 祈使句：表示请求，命令，劝告，建议等​ 主语you省略 ​ 动词原型，没有时态，不用情态动词 ​ Stop bugging me ​ Don’t judge a book by its cover ​ Don’t get me wrong ​ Let’s just have a rest ​ Let’s hope for the best ​ Let’s talk over dinner ​ Let bygones be bygones ​ Strike while the iron is hot ​ Make hay while the sun shines 感叹句：what1.what + a(n) + 形容词 + 可数名词单数 + 谓语部分​ what a lovely boy he is. 2.what + 形容词 +不可数名词或可数名词复数 + 谓语部分​ what foolish mistakes you have made ​ what nice weather(it is) 3.what + a(n) +可数名词单数：是​ 没有感情色彩的普通名词时: 有两种理解 ​ what a day: 可以是今天天气多好，也可以是天气很糟糕 ​ 有感情色彩的名词 ​ what a mess 感叹句： how1.how + 形容词 or 副词 + 谓语部分​ How lovely the boy is ​ How fast time flies 2.How + 主谓部分​ How he ssnores！ ​ How I hate exams! 3.How + 形容词 + a(n) +可数名词单数 + 主谓部分​ How lovely a boy he is. 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%8F%A5%E5%AD%90%E7%B1%BB%E5%9E%8B.html"},{"title":"英语语法-名词从句","text":"概念：三种句子充当另外一句子的四种句子成分 1. 陈述句：句前 + that (当宾语时可省略)​ a. That the moon itself does not give off lights is common knowledge. ​ b. I’ve learned (that) love, not time heals all wounds. 2. 一般疑问：变陈述句语序，句前 + whether(当宾语时可用if)​ a. My question is whether people will live on the moon someday. ​ b. I don’t know if/whether he needs my help. 3. 特殊疑问：变陈述句语序​ a. Money is what we are badly in need of. 句子类型 引导词 从句中作用 陈述句 that 不做成分 一般疑问 whether, if 不做成分 特殊疑问 连接副词when, where, why, how连接代词who, whom, what; which, whose 连接副词做状语who, whom, what做主语/表语/宾语which, whose做定语,后+名词连用 it形式主语：it在句首，主句在后面​ a. It is common knowledge that the moon itself does not give off light. ​ b. It is not known where they came from. it形式宾语：复合宾语中：动词 + it + 宾补 + 宾语从句​ I find it encouraging how many young women are pursuing careers in science. 双宾语：Could you tell me where the post office is? 介词后做宾语： You should vote for which candidate you assume best. 形容词后做宾语： I am afraid that I can’t come. 并列宾语从句中that不省略： I once read that “” and that “”. reason后的表语从句：引导词用that，不用because.​ The reason (why) he was dismissed is that he was careless and irresponsible. 嵌套：a. I realized that what I said was not exactly what I meant to say. ​ b. The question is how what you have learned can be put into practice. 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%90%8D%E8%AF%8D%E4%BB%8E%E5%8F%A5.html"},{"title":"算法成长之路leetcode21-22","text":"21. Merge Two Sorted ListsMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example:12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 JAVA题解：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package algorithm.c3;/** * 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 * * 示例： * * 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 * 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode21 { // 错解 public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode l = new ListNode(0); ListNode cur = l; while (l1.next != null || l2.next != null){ if (l1.next == null) { cur.next = l2; } else if (l2.next == null) { cur.next = l1; }else { if(l1.val &gt; l2.val){ cur.next= l2; l2 = l2.next; }else if(l1.val == l2.val){ cur.next= l2; cur.next.next = l1; l1 = l1.next; l2 = l2.next; }else{ cur.next = l1; l1 = l1.next; } } cur = cur.next; } return l.next; } public ListNode mergeTwoLists1(ListNode l1, ListNode l2) { // maintain an unchanging reference to node ahead of the return node. ListNode prehead = new ListNode(-1); ListNode prev = prehead; while (l1 != null &amp;&amp; l2 != null) { if (l1.val &lt;= l2.val) { prev.next = l1; l1 = l1.next; } else { prev.next = l2; l2 = l2.next; } prev = prev.next; } // exactly one of l1 and l2 can be non-null at this point, so connect // the non-null list to the end of the merged list. prev.next = l1 == null ? l2 : l1; return prehead.next; } // 递归 public ListNode mergeTwoLists2(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } else if (l2 == null) { return l1; } else if (l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } } public static void main(String[] args) { ListNode l1 = new ListNode(1); l1.next = new ListNode(2); l1.next.next = new ListNode(4); ListNode l2 = new ListNode(1); l2.next = new ListNode(1); l2.next.next = new ListNode(3); System.out.println(new Leetcode21().mergeTwoLists1(l1,l2)); } public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; } }} 22. Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. Example:123456789For example, given n = 3, a solution set is:[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] JAVA题解：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package algorithm.c3;import java.util.LinkedList;import java.util.List;/** * 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 * * 例如，给出 n = 3，生成结果为： * * [ * &quot;((()))&quot;, * &quot;(()())&quot;, * &quot;(())()&quot;, * &quot;()(())&quot;, * &quot;()()()&quot; * ] * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/generate-parentheses * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode22 { /** * * 在此题中，动态规划的思想类似于数学归纳法，当知道所有 i&lt;n 的情况时，我们可以通过某种算法算出 i=n 的情况。 * 本题最核心的思想是，考虑 i=n 时相比 n-1 组括号增加的那一组括号的位置。 * * 思路： * 当我们清楚所有 i&lt;n 时括号的可能生成排列后，对与 i=n 的情况，我们考虑整个括号排列中最左边的括号。 * 它一定是一个左括号，那么它可以和它对应的右括号组成一组完整的括号 &quot;( )&quot;，我们认为这一组是相比 n-1 增加进来的括号。 * * 那么，剩下 n-1 组括号有可能在哪呢？ * * 【这里是重点，请着重理解】 * * 剩下的括号要么在这一组新增的括号内部，要么在这一组新增括号的外部（右侧）。 * * 既然知道了 i&lt;n 的情况，那我们就可以对所有情况进行遍历： * * &quot;(&quot; + 【i=p时所有括号的排列组合】 + &quot;)&quot; + 【i=q时所有括号的排列组合】 * * 其中 p + q = n-1，且 p q 均为非负整数。 * * 事实上，当上述 p 从 0 取到 n-1，q 从 n-1 取到 0 后，所有情况就遍历完了。 * * 注：上述遍历是没有重复情况出现的，即当 (p1,q1)≠(p2,q2) 时，按上述方式取的括号组合一定不同。 * * 作者：yuyu-13 * 链接：https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * * 简单来说，在求N个括号的排列组合时，把第N种情况（也就是N个括号排列组合）视为单独拿一个括号E出来， * 剩下的N-1个括号分为两部分，P个括号和Q个括号，P+Q=N-1，然后这两部分分别处于括号E内和括号E的右边， * 各自进行括号的排列组合。由于我们是一步步计算得到N个括号的情况的，所以小于等于N-1个括号的排列组合方式我们是已知的（ * 用合适的数据结构存储，方便后续调用，且在存储时可利用特定数据结构实现题目某些要求，如排序，去重等）， * 且P+Q=N-1，P和Q是小于等于N-1的，所以我们能直接得到P个和Q个括号的情况，进而得到N个括号的结果！ * * 楼主的算法思想很巧妙，赞一个~这个算法主要的基点就是将排列组合的情况分为了括号内和括号外这两种情况， * 且仅存在两种情况！至于为什么，原因在于楼主的算法的前提是单独拿出来的括号E的左边在N个括号所有排列组合情况中都是处于最左边， * 所以不存在括号位于括号E的左边的情况。因此，N-1个括号（拿出了括号E）仅可能分布于括号E内和括号E外，分为两种子情况讨论！ * 这种思想还可以应用于其他类似的题的求解中，即怎样合理高效的利用前面步骤的计算结果得出当前步骤结果，从而得出最终结果。 * * @param n * @return */ public List&lt;String&gt; generateParenthesis(int n) { LinkedList&lt;LinkedList&lt;String&gt;&gt; result = new LinkedList&lt;LinkedList&lt;String&gt;&gt;(); if (n == 0) return result.get(0); LinkedList&lt;String&gt; list0 = new LinkedList&lt;String&gt;(); list0.add(&quot;&quot;); result.add(list0); LinkedList&lt;String&gt; list1 = new LinkedList&lt;String&gt;(); list1.add(&quot;()&quot;); result.add(list1); for (int i = 2; i &lt;= n; i++) { LinkedList&lt;String&gt; temp = new LinkedList&lt;String&gt;(); for (int j = 0; j &lt; i; j++) { List&lt;String&gt; str1 = result.get(j); List&lt;String&gt; str2 = result.get(i - 1 - j); for (String s1 : str1) { for (String s2 : str2) { String el = &quot;(&quot; + s1 + &quot;)&quot; + s2; temp.add(el); } } } result.add(temp); } return result.get(n); }}","link":"/Algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode21-22.html"},{"title":"英语语法-基本句子结构","text":"subject + intransitive verb: 主 + 不及物动词 Man proposes; God disposes Modesty benefits; pride hurts The sun rises and the sun sets. Stars glitter and stars vanish. There are ups and downs in life 常常带有状语​ Great minds think alike ​ The sun sets in the west Subject + Link Verb + Subject Complement: 主 + 系动词 + 表语（主语补足语） He looks unhappy The leaf will trun yellow in autumn I’ve got to return the book this afternoon; it falls overdue a week The best proof of love is trust Bread is the staff of life 介词短语也可以做表语​ Beauty is in the eye of the beholder 表示特征状态: feel, look. sound, taste, smell, seem, appear​ The iron feels hot. ​ The rose doesn’t smell much 状态转变: become, grow, get, turn, fall, go, come​ Our supplies of sugar and rice fell short ​ The jokes fell flat ​ fall asleep ​ fall due ​ go hungry go sour go wrong ​ Hope your dreams will come ture ​ The leaf will turn yellow in autumn ​ I’ve got to return the book this afternoon. it falls overdue a week 状态保持: continue, remain, stay, keep, hold, rest, prove​ The weather continued fine for several days ​ He held silent fo the whole day ​ He has fallen into the habit of doing morning exercises ​ You may rest assured that he will come to the party 近似不及物动词的系动词​ Mr. Bean often acted weird in public ​ All the audience sat silent ​ He was born poor ​ The boy blushed scarlet ​ I married young ​ He died young ​ Jane Austin died a spinster ​ He died a hero’s death Subject + + Transsitive Verb + Object: 主 + 谓 +宾​ Beauty will buy no beef ​ I want to go home now ​ I’ve finished reading the book ​ I’ll pick you up this evening Subject + Dative Verb + Indirect Object + Direct Object: 主 + 谓 + 间接宾语 + 直接宾语​ He showed the guard this passport ​ I will buy you a meal ​ 1. assign, award, bring, deliver, deny, feed, give, grant, hand, lend, offer, owe, pass ​ pass, pay, promise, post, read, recomment, sell, send, show, take, write ​ He showed his passport to the guard ​ He showed the guard his passport ​ 2. 介词用for: book, buy, build, change, choose, cook, fetch, find, get, keep, make, order, prepare, sing ​ I am going to buy a gift for her ​ I am going to buy her a gift ​ 3. 不能用介词: charge, cost, bet ​ I’ll bet you ten dollars ​ The repairman charged me ten dollars ​ 特殊: ask ​ Can I ask you a question? ​ Can I ask a question of you Subject + Factitive Verb + Object + Object Complement​ They appointed John chairman ​ I believe him to be true ​ The chairman declared the meeting over ​ They elected John chairman ​ You can leave the door open ​ A hedge between keeps friendship green ​ 双宾语和复合宾语区分:宾语后加上be，若能成完整句子则是补足语 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%9F%BA%E6%9C%AC%E5%8F%A5%E5%AD%90%E7%BB%93%E6%9E%84.html"},{"title":"英语语法-完成时","text":"现在完成时(一)：开始于过去的动作一直持续到现在，有可能继续持续。谓语动词为延续性动词 I have lived here for 3 years. 我仍然住在这里，而且还可能继续住下去。 ​ 如果在搬家时说这句话，则live这件事只持续到目前为止。 The teacher has taught in this school since I came here. I’ve worked in this company since I left school. ​ since表明了动作开始的时间点。 有上下问明确告知，动作只持续到说话的时刻为止。 ​ a. A: Have you waited long? ​ B: I’ve waited for three hours. ​ b. I’ve waited for him all day; I don’t want to wait any longer. 特点： 谓语动词为延续性动词 动作的发生时间是过去，持续到现在，还可能继续持续下去。 常常与表示一段时间的时间状语连用，是说明某个状态持续了多久。 与现在完成时搭配的时间状语 1. since + 时间点 ​ a. I’ve worked in thiss company since 1980 ​ b. I’ve worked in this company since I left school. (从句中一般过去时) 2. for + 时间段 ​ a. I’ve worked in this company for three years. ​ b. Great changes have taken place in Beijing for the past few years. 3. 到目前为止：until now, up until now, up to now, up till now, so far. ​ a. We have up until now failed to take any action to decide on a common language that would further communication between nations. 4. 在最近几世纪/年/月以来：in the past few years, over the past few years, during the last three months, for the last few centuries, through centuries, throughout history. ​ a. Throughout history man has had to accept the fact that all living things must die, for the very nature of life includes death. ​ b. Through centuries the bizarre anticss of sleepwalkers have puzzled police, perplexed scientists anad fascinated writers. 现在完成时(二)：过去发生但与现在仍有联系的动作或状态 a. He has broken his leg. 他现在还在医院，所以不能和同学一起郊游。 b. He broke this leg. 退摔断过，单纯表示一种过去的经历，但现在腿已经好了。 c. You should have put the milk into icebox; I expect it has become undrinkable by now. ​ 牛奶变质是过去某一时刻的动作，但其影响延续到现在。现在牛奶已经不能喝了。 第二种现在完成时使用技巧。 1. 不与一段时间的时间状语连用：常见 come, go, leave, kill, die, lose, buy, start, give, marry ​ he has left his hometown for 3 years. ​ 改正： ​ a. He left this hometown 3 years ago. ​ b. It’s 3 years since he left this home town. ​ c. He hasn’t come back since he left his hometown 3 years ago. ​ d. He has been away from his home town for 3 years. 2. 终止性动词的完成时句子若用否定，表示尚未发生的事情，则可以为一种状态，从而表示延续。 ​ a. I haven’t seen a film for weeks. ​ b. I haven’t heard form my girlfriends since I came to America ​ c. I haven’t bought a pair of shoes for a year. 3. 与不确定时间的时间状语连用 ​ 这种完成时，可以同一些表示不确定的时间状语连用：already, yet, lately, often, just, never ​ a. A: would you like something to eat? ​ B: No, thanks. I’ve just had dinner. ​ b. The leading expert on sleep in America claims that he has never seen a sleepwalker. ​ c. Has it stopped raining yet? ​ d. He has already arrived. ​ f. I have often thought that it would be perfect if we could fly without any aid. 4. 具有新闻性质：表示最近才发生的动作，提供新消息。有新闻性质 ​ a. The President has been assassinated. ​ b. He can’t go on holiday because he has broken his leg. ​ 强调的时间内容，而不算是发生的过去具体时间。 ​ 通常的日常对话，以现在完成时开始问答。过去时间咋唉说话人的脑子中已经确定了，则继续用一般过去时。 ​ c. I hear that famous Chinese comedian has died. ​ Really? When did she die? She was dead late last night. 现在完成时(三)：表示到目前为止的一个时间段内重复发生的动作。 For more than eighty years, scientists have argued over whehter life exists on the planet Mars. We have taken three tests so far this week. 其他现在完成时的结构 1. This/ That/ It is + 序数词 + 名词 + that + 现在完成时 ​ a. It is the third thime that I’ve come to Beijing. ​ b. It is the fifth time that someone has knocked at my door. ​ c. This is the thenth cup of coffee that I’ve drunk this evening. 2. This/ That/ It is + 最高等或only修饰名词 + 现在完成时 ​ a. This is the most interesting movie that I’ve ever seen ​ b. This is the best wine I have ever drunk ​ c. This is the hardest job I have ever had. 3. 如果是It was the second/ best… that 后面要用过去完成时 ​ a. It was the fifth time that someone had knocked at my door that night. 总结：一直在持续； 重复发生；影响现状 现在完成时与一般过去时比较 不同时态，表明了说话的时间不同。 a. I haven’t seen him this morning. b. I didn’t see him this morning. a. 句用了现在完成时，而完成时生死要与现在发生联系的。所以a说话的时间是this morning b. 句用的是一般过去时，说明this morning已经成为了过去，所以b说话时间是今早后 c. I have called thim three times this morning. d. I called thim three times this morning. c. 表示到现在为止的一个是时间段内重复的动作。所以c说话时间是this morning d. 过去时，和现在没有什么联系，所以说话时间是今早后 延续性动词的两种时态区别 a. He lives in Beijing. He has lived here for 3 years. (可能还继续住在这里) b. He lived in Beijing for 3 years and then emigrated to America (曾经住过，已经搬走了) 过去完成时：过去某时刻之前就开始的动作；​ (1)该过去时刻仍然在继续，或该过去时刻刚刚停止 ​ (2)在该过去时刻之前的某一时刻已经停止的动作做 ​ (3)在该过去时刻之前一段时间内重复的动作 (1) a. I had stayed in America for two years when he moved here. b. I had lived in 兵庫 for one and a half years when I came to Aizu. 有上下文表示持续过去这一时刻刚刚停止 c. I had waited for her for two hours in susch a severe winter when she eventually turned up d. There had been fifty colleges in our city up till 1993. (2) a. She had made everything ready before I came. b. Her baby had fallen asleep when she went into the room. c. Before John got home, Mary had gone to bed. d. I had just poured myself a cup of tea when the phone rang. When I came back from answering it, the cup was empty. Somebody had drunk the tea or thrown it away. (3) a. I had written her 100 letters when she finally promised to marry me. b. I had proposed to her five times, but she still refused to marry me. 过去完成时的其他用法 1. intend, mean, hope, want, plan, suppose, expect, think, propose, wish ​ 动词的过去完成时，可以表示过去未能时间的计划，设想，意图或希望等 ​ a. I had planned to go shopping with you but my mother came to see me just when I was about to go. ​ b. She had hoped that he would come to date her, but he didn’t show up. ​ c. I had intended to see you, but I was busy. ​ d. They had hoped to see you off at the airport, but they got there too late. 2. 用在It was the + 序数词 或最高级 that 句中。 ​ a. Last week I attended an international conference and saw Mr. Machine. It was the third time that I had met him. 一把拿过去时与过去完成时的比较 1. 两个或以上相继发生的动作，用and 或 but 按动作发生的先后顺序连接，此时要用一般过去时。 过去完成时则强调主语在过去某一时刻回顾更早的动作，具体来说。当我们在讨论过去某一事件时，想到了在这之前已经发生的某事，这时用过去完成时。 ​ a. He opened the door and entered, but found nobody. ​ b. He served in the army for ten years; then retired and married. His children are now at school. ​ c. When I had written my letters I did some gardening. ​ d. When I wrote him a letter, he came at once. ​ e. When the singer had sung her song, she sat down.如果说when the singer sang her song, she sat down.给中一种印象，这位歌手喜欢坐着唱歌。 将来完成时：站在将来某一时间来谈某一个动作的完成情况 动作开始的时间可以是过去，现在，未来。但并不重要，说话人强调的是他们一共有5门 ​ a. We started our exam yesterday and we will have taken five exams by next Friday. ​ b. We have started our exam today and we will have taken five exams by next Friday. ​ c. We will start our exam tomorrow and we will have taken five exams by next Friday. 1. 同现在完成时第一种用法的将来完成时 ​ a. I will have taught English in New Oriental School for five years by the end of next month. ​ b. I will have learned 8000 words by the end of next year. ​ c. I will have waited for her for two hourss when she arrives at 2 o’clock this afternoon. 2. 同现在完成时第二种用法的将来完成时：对将来有影响 ​ a. We will have finished our exam by the end of next week. ​ b. By the year 2050, scientists probably will have discovered a cure for cancer. ​ c. I will graduate in July. I will see you in September. By the time I see you, I will have graduated. ​ d. I will have finished my homework by the time I go out on a date tonight. 3. 同现在完成时第二种用法的将来完成时：重复发生。 ​ a. By five o’ clock this afternoon the spaceship will have traveled eleven times round the world. 完成时的三种思维用法​ 1. 延续到现在的动作或状态，可能继续延续，也可能到现在为止。 ​ 2. 过去发生但与现在仍有联系的动作或状态。对现在有影响。 ​ 3. 到目前为止的一个时间段内重复发的动作。 ​ 4.不同时间的完成时本质上是一样的。只是说话人的立足时间不同。 ● Sorry I’m late. The car broke down on my way here. ● Yesterday I had a phone call from Clint. I was very surprised. I had written to him many times but he had never replied to my letters. ● The man sitting next to me on the plane was very nervous. It was his first flight. He had never flown before. ● Last spring I went to France. It was the first time that I had been there. ● Look! Somebody has spilt milk on the carpet. Well, it wasn’t me. I didn’t do it. I wonder who it was then. ● I lost my key, so I couldn’t get into my house. But now I have found it. ● He has been in the army for five years. ● I’ve already had lunch. 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%AE%8C%E6%88%90%E6%97%B6.html"},{"title":"英语语法-句子简化","text":"名词从句逻辑思路：从句—&gt;动名词or不定式 that引导的主语从句：动名词当主语​ It surprised us that John won the marathon. ​ John’s winning the marthon suprised us. that引导的同谓语从句：+ of 变成复合结构​ There was no chance that Davy would come from the battle alive. ​ There was no chance of Davy coming from the battle alive. that引导的宾语从句：转换动名词or不定式(取决于主句谓语动词)​ a. I hope that I can drive to work in my own car. ​ I hope to drive to work in my own car. ​ b. I consider that I will emigrate to America in the future. ​ I consider emigrating to America in the future. ​ c. Jane’s mother insisted that she should go swimming with her brother. ​ Jane’s mother insisted on her going swimming with her brother. 名词从句不定式简化：​ a. I don’t know what I should do. ​ I don’t know what to do. ​ b. Tell me how I can get to the bus station. ​ Tell me how to get to the bus station. 定语从句逻辑思路：从句—&gt;短语(只有关系词做主语时可简化) 从句有be动词：去掉be动词and关系代词 主动：现在分词；被动：过去分词；形容词短语也可​ a. The man who is standing at the gate is my English teacher. ​ The man standing at the gate is my English teacher. ​ b. Books that are written in English are more expensive. ​ Books written in English are more expensive. ​ c. The people who were responsible for the incident were all punished. ​ The people responsible for the indident were all punished. 从句没有be动词：去掉关系代词；动词—&gt;现在分词​ a. They live in a room that faces the south. ​ They live in a room facing the south. ​ b. English has an alphabet that consists of 26 letters. ​ English has an alphabet consisting of 26 letters. 不定式替换：the only，the last，the next，序数词，最高级修饰的名词​ a. The only one that understands me. ​ The only one to understand me. ​ b. The next train that arrives is from New York. ​ The next train to arrive is from New York. ​ c. Jango was the second person that fell into this trap. ​ Jango was the second person to fall into this trap. 状语从句注意：主句从句的主语相同时，才可以简化。 有be动词：去掉be动词(常见：时间，地点，条件，让步) 主动：现在分词；被动：过去分词；形容词or名词短语也可​ a. Metals expand when heated and contract when (they are) cooled. ​ b. When (he was) a student in the university, he read a lot. ​ c. while (he was) waitting, he took out a magazine to read. ​ d. A tiger can’t be tamed unless (it is) caught very young. 没有be动词：从句主语省略，动词变成现在分词​ a. Since I came to Beijing, I have made many new friends. ​ Since coming to Beijing, I have made many new friends. ​ b. After I finished my homework, I fed the dog. ​ After finishing my homework, I fed the dog. ​ c. After he jumped out of a boat, the man was bitten by a shark. ​ After jumping out of a boat, the man was bitten by a shark. 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%8F%A5%E5%AD%90%E7%AE%80%E5%8C%96.html"},{"title":"英语语法-定语从句","text":"完整句子做定语形容词做定语放在被修饰词前面 完整句子做定语放在被修饰词后面 定语从句的重要概念先行词：被修饰或限定的词（the people） 关系词：重复指代先行词，起连接作用并在定语从句中充当成分 代词作用：重复指代先行词，从句中充当成分 连接作用：连接主句和从句的作用 关系代词的用法 先行词指人who，whom 先行词指物which 先行词指人或物均可：that，whose 先行词指人 who和whom区别 who在从句中可做主语，宾语，表语，但who之前不可用介词 ​ I like the people who I work with ​ I like the people with whom I work whom在定语从句中不能做主语，可以做表语或宾语 ​ A rich person is not one who has the most, but is one who needs the least. **表示人或物的所有关系：whose + 名词：在从句中可做主语，动词宾语，介词宾语** a. When I looked through the window, I saw a girl whose beauty took my breath away. b. It was a meeting whose importance I did not realize at the time ​ 动词宾语 c. Atlas(in Greek mythology) was a kneeling man on whose shoulders the world rested. ​ 介词宾语 先行词指物 a. which可以指代单个名词 ​ Perhaps it is human to appreciate little that which we have and to long for that which we have not b. which可以指代单个短语 ​ He likes climbing mountains, which is a good exercise. c. which可以指代前面整个句子 ​ She wore her swimming things in the office, which shocked her boss a great deal. 非限定性定语从句：被修饰的句子不需要定语从句意思也完整，只是补充说明 that指代人或指代物：注意不可以用在介词后面 The world that/which we live in is made up of matter. The world in which we live is made up of matter. 最好用that情况 先行词有人也有物时，用that ​ The writer and his novels that the article deals with are quite familiar to us. 先行词为指物的all, little, few, much, none, the first用that ​ a. All that glitters is not gold. ​ b. This book contains little that is useful. ​ c. There is not much that can be done. ​ d. As long as you stand up to the difficulties, there are none that cannot be overcome. 先行词是不定代词something, anything, nothing, everything用that ​ a. Is there anything that I can do for you? ​ b.Greater expense does not always equal better gift, I would much rather receive a gift that was unique or that I knew my friend had put some thought into rather than something that cost a lot of money but that I didn’t need or want. I would much rather receive something that made me laugh, made me reminisce, or fit my personality that something that cost a lot but that I will just throw in my closet and forget about. 先行词被any, only, all, every, no, some, much, few, little, 序数词，最高级，the only, the one, the very, the right, the last，修饰时用that ​ a. Tell us all things that you know. ​ b. There is no difficulty (that) they can’t overcome. ​ c. The only thing that we should do is find our way home. ​ d. The very problem that I want to solve is like this. ​ e. He is the only man that can speak four foreign languages in our company. 关系代词省略 关系代词who, whom, which, that 若在定语从句中用作宾语，可以省略 ​ a. Tina likes the present which I gave her for her birthday. ​ b. Tina likes the present that I gave her for her birthday. ​ c. Tina likes the present I gave her for ther birthday. ​ d. I like the people who I work with. ​ e. I like the people I work with. ​ f. I’m talking about friends who you can share almost everything with. ​ g. I’m talking abouot friends you can share almost everything with. 关系副词的用法：when, where, why，从句中做时间状语，地点状语， 原因状语 先行词指时间 ​ when 引导限制性和非限制性定语从句，先行词须是表示**时间的名词** ​ day, year, time, when可以用on which来替换 ​ a. I’ll never forget the day when I met you. ​ b. I’ll never forget the day on which I met you. ​ c. We will put off the outing until next week, when we won’t be so busy. ​ d. The day may soon come when we don’t bother to go to office but just work at home. 关系副词when在从句中做时间状语 ​ 当心：表示时间的先行词，若定语从句中不缺少状语和是缺少宾语或主语，要用which或 that来引导定语从句。因为when来引导定语从句的前提条件是：when 在其引导的定语从句中做时间状语。 ​ a. The day, which began brightly, ended with a violent storm. (which做主语) ​ b. I’ll never forget the time which I spent on campus. (which做spent宾语) ​ c. I’ll never forget the day when we first met in the park. (when做时间状语修饰met) where的用法 = at which或in which where引导定语从句，先行词必须是表示地点的名词，如place, house ​ a. Do you know any place where I can buy Clint’s grammar book? ​ b. Do you know any place at which I can buy Clint’s grammar book? ​ c. This is the town where(in which) I spent my childhood. ​ d. This is the restaurant where I often have my breakfast. 关系副词where在从句中做地点状语 ​ a. This is the town where I spent my childhood. ​ b. This is the town which I told you about before. which做about的宾语 ​ c. The library where students often study was on fire last night. ​ d. The library, which was built in the 1930’s, needs to be renovated. ​ e. One of the places which I want to visit someday is Tibet. which做visit宾语 why的用法：只用来引导限制定语从句，先行词是reason等表示原因的名词 因为说明原因，所以不是补充说明，不能做非限制定语从句 = for which This is the reason why I didn’t come here 限制性和非限制性的定语从句 形式上：有无 “，” 分割开来 限制性定语从句 ​ 作用：用来提供必要的信息，限定身份或性质，限制范围，若去掉从句，含义不明 ​ 例子：I don’t like people意思不明 ​ I don’t like people who never keep their words. 非限制性定语从句 ​ 作用：提供附加的非必要信息，补充说明或解释，去掉从句，不会引起误解。 ​ 例子：Beijing, which is the capital of China, has developed into an international city. 如果定语从句修饰一个专有名词，我用一般用逗号，就是要用非限定性定语从句。 因为专有名词本身意思已经很完整，不需要限制，只是用定语从句进行补充 用不用逗号的句子意义有差别 限制性 非限制性 解释 he has a daughter who works in a hospital he has a daughter, who works in a hospital a，表示他有多个女儿，其中一个在医院工作b，强调他有一个女儿，不是儿子，在医院工作 the food which wasn’t in the fridge all went off. the food, which wasn’t in the fridge, all went off a，没有放在冰箱里的那部分食物坏了b，食物都坏了，因为没有放在冰箱里。此时的定语从句补充说明变坏的原因。 限制性定语从句一般翻译成定语形式“….的” 非性质性定语从句往往翻译成各种状语 a. the food, which wasn’t in the fridge, all went off. ​ 翻译成原因状语从句 b. the Ambassador gave a dinner to the scientists, with whom the especially wished to talk ​ 翻译成原因状语从句 c. the people were desperate for work, any work, which could support their family. ​ 条件状语从句 d. the millionaire had another house built, which he didn’t need at all ​ 让语状语从句 that引导的定语从句和同位语从句的区别 that是否做成分：that在定语从句中充当成分，在同位语从句中不做任何成分 ​ a. the rumor that he spread everywhere turned out to be untrue. ​ b. the rumor that tom was a thief turned out to be untrue. ​ a 中that在从句he spread everywhere 做成分，充当spread的宾语，为定语从句 ​ b 中that在从句tom was a thief中不做任何成分。 从句作用 ​ 定语从句相当于形容词，他对先行词起到修饰，描述和限制的作用。 ​ 同位语从句相当于一个名词，他是前面名词的内容的具体表述。两者是同位的关系。 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5.html"},{"title":"英语语法-完成进行时","text":"现在完成进行时(一)到现在仍在延续的动作 1. 与一段时间连用：强调动作的持续性，开始于过去的动作持续到现在，并且还会继续持续 常与for + 时间段、since + 时间点、all morning、all day、all week表示段时间的状语连用 ​ It began raining two hours ago and it’s still raining. It has been raining for two hours. 2. 可不与时间段连用；表示最近一段时间内正在持续的活动 ​ I have been thinking about changing my job. 我最近一直在考虑换工作。 (二)刚刚结束的动作 1. 动作持续到说话为止 ​ a. Where have you been? I’ve been looking for you for the last half hour. ​ b. Thank you for the binoculars. I’ve been wanting a pair for ages. 2. 不久前刚刚结束的动作(完成时没有的用法) ​ a. Your friend is out of breath. you ask, “Have you been running?” ​ b. Why are your clothes so dirty? what have you been doing? ​ c. The little boy is dirty from head to foot because he has been playing in the mud. (三)重复发生的的动作 说话时刻以前的一段时间内重复发生的动作 ​ a. Every Sunday they meet in the same bar. They’re been going there for years. ​ b. I’ve been getting up early since I entered the college. ​ c. The price has been going up recently. I wonder whether it will remain so. ​ d. You’ve been staying up late again? 与现在完成时比较(一)相同点： 1. 都是延续性谓语动作live, learn, study, sleep, snow, wait, work, teach, stay 2. 与时间段连用(这时两种时态几乎没有多大的区别) ​ a. I have been learning/ have learned English for ten years. ​ b. I have been living/ have lived here since 3 years ago. 不同点： 现在完成时只与段时间连用才能表示这类动作。 a. I have worked/ have been working in this company for 3 years. b. I have worked in this company(现在不在了，表示过去的经历) c. I have been working in this company. (现在还在这家公司) d. He has been sleeping/ has slept for three hours. e. He has slept(他睡过了，所以现在不困了) g. he has been sleeping(现在还在睡) 与现在完成时比较(二) 完成进行时强调动作过程 完成时强调动作的结果 a. My hands are very dirty. I’ve been painting the house(理由，做的动作过程) b. I have painted the house green. The house was white, but now it’s green. c. Sorry about the mess–I’ve been painting the house. 与现在完成时比较(三) 1. 短暂动词的完成进行时表示重复。 ​ 短暂动词的完成时不能与一段时间的时间状语连用。但是完成进行时可以，表示重复动作 ​ a. Over the past few years, many towns in the United States have been joining with neighboring communites to share the costs of government. ​ b. Over the past few years, many towns in the United States have joined with … ​ c.I’ve got up early since I entered the college. 2. 重复动作的分割性 ​ 完成进行时表示不间断动作。如果要表达做事情的次数，不能用现在完成进行时 ​ a. I have been sitting in class since 8 o’ clock this morning. ​ b. I have had three classes since 8 o’ clock this morning. ​ c. The phone has been ringing for almost a minute, why doesn’t someone answer it?​ d. The phone has rung four times this mrning, and each time it has been for Clint. 与现在完成时比较(四) 不能用进行时的动词，同样不能用现在完成进行时 a. How long have you known Jane? b. How long have you been knowing Jane? 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%AE%8C%E6%88%90%E8%BF%9B%E8%A1%8C%E6%97%B6.html"},{"title":"英语语法-状语从句","text":"本质：连接词(关键)表达分句之间逻辑关系 种类：时间，地点，原因，目的，结果，条件，让步，比较，方式 时间状语：说明两个从句的时间 when：调节两个时间点【起始点&amp;结束点(完成时)】来说明主从句发生顺序 三要点： 同 时 态：从句先发生 有完成时：强调已完成的时间点 从 句 中：现在表将来 (主句/从句)时态 例句 将来/现在 I’ll speak to him when he arrives. 将来/现在完成 I’ll give you a call when I have finished the work. 过去/过去 I started my dinner when he left. 过去/过去完成 He left when I had got there. 过去完成/过去 I had started my dinner when he left. whenever：强调无论何时(每次) Smile whenever you pick up the phone, for the caller will be able to notice it. while + 延续动词：从句发生期间发生 The doorbell rang while we were watching TV. until：主句持续到从句的时间点保持同一状态 肯定形式：持续发生状态 We’ll stay here till it stops raining. 否定形式：持续未发生状态 I did not realize I would need English in the future until I came to Japan. 三种特殊结构 until句首 Until he saw his mother, the little boy didn’t smile. 主句倒装 Not until he saw his mother did the little boy smile. 强调 It was not until he saw his mother that the little boy smiled. 一…就：as soon as, once, the minute, the moment, the instant, immediately, directly, instantly. 说明：强调主从句说明的两个时间点同时发生；时态一般一致 It began to rain as soon as/immediately/the moment I arrived home. 特殊：倒装比较方式，主句动作刚结束(过去完成)，从句动作就开始(过去) No sooner had I arrived home than it began to rain. ​ 2. Hardly/Scarcely had I arrived home when it began to rain. ​ 3. No sooner had we begun having dinner than the doorbell rang. 时间短语引导： next time, by the time, every time, each time, the day, the week. a. The day he returned, his father was already dead. ​ b. Next time you come, remember to bring along your sister. ​ c. Every time I listen to your advice, I get into trouble. 在…之前：by the time 强调：主句动作(完成时)在从句动作之前已经完成 a. By the time they arrived, we had already left. ​ b. By the time they arrive, we will have already left. 地点状语主句后边：一般 Generally, air will be heavily polluted where there are factories. 主句前边：需要灵活翻译 wherever there is love, there is also wealth and success. wherever, anywhere, everywhere引导 wherever I happens to be, I can make myself at home. 原因状语Because 语气最强，只有它能回答why问句。听话人未知原因 You want to know why I am leaving? ​ I am leaving because I’m fed up with the job and boss. 强调词：only，just ​ You shouldn’t get angry just because some people speak ill of you. Since：已知道的原因，既然 Since Monday is Bob’s birthday, let’s throw him a party. As：和since差不多 She didn’t hear us come in as she was asleep. For：推断理由 Pay attention to your enemies, for they are the first to discover your mistakes. 介词短语表原因：because of，due to(非句首)，owing to(句首)：只接名词 Owing to his carelessness we had an accident. because否定转移：从句的否定转移到主句 I didn’t attend the meeting because he was present. 复合连词表原因：seeing (that)，now (that)，considering (that)，given (that) = since Now that the semester is finished, I’m going to rest a few days and then take a trip. In that：原因就在于 The girl is like her mother in that she also has very delicate feeling. 目的状语常用连词：so that，in order that，that；从句：有表能力的情态动词 I spoke slowly and clearly so that/ in order that the audience could understand me. 不定式简化 In order for sb to do sth I spoke slowly and clearly in order for the audience to understand me. In order to(可句首)/so as to do：主从句主语一致 All the key words in the article are printed in bold type so as to attract attention. 以免连词：lest，for fear (that)，in case：以免，生怕 Take an umbrella with you lest it would rain. 其他连词：in the hope that，on purpose that，for the pupose that，to the end that The teacher raised his voice on purpose that the students could hear more clearly. 结果状语常用连词：so…that，such…that，such that(such = so+adj.) His anger was so explosive that he lost control of himself. 主句倒装 a. So fast does light travel that it is difficult for us to imagine its speed. ​ b. Such a fool was he that he believed him. 不定式简化 such…as to do sth，such as to do sth，so…as to do sth (as不能省略) Her voice was such as to make everyone stare. 其他短语：to the degree/extent (that)，to such a degree/extent (that)(句首时倒装) a. To such an extent did his health deteriorate that he was forced to retire. ​ b. The bereaved mother was grieved to the deggree that she couldn’t eat for 3 days. so和such区别 1.a. so + 形容词 or 副词 b. such + 名词 ​ a. This is so expensive a house that I can’t afford to buy it. ​ b. This is such an expensive house that I can’t afford to buy it. 2. a. so + 形容词 + a(n) + 名词 b. so + many/much/few/little + 名词 ​ a. This is so expensive a house that I can’t afford to buy it. 3. 数量词/限定词 + such + 名词 ​ one such man; no such man; every such man; five hundred such men 让步状语常用连词：though, although, even though, even if. (主句前不用but，可用yet/still) Though he tried hard, yet he failed. 介词让步：despite, in spite of, for all, notwithstanding后只接名词(短语) ​ Although it was dangerous, … = Despite the danger, … 句首while：表示尽管 While I sympathize with your point of view, I can not accept it. No matter 特殊疑问词 = 特殊疑问词 + ever ​ Whoever may trouble you, I will help you to the last. as倒装：(adj/ adv/ 分词/ 名词/ 短语) + as + 主语 + 谓语 ​ a. Young as he is, he is knowledgeable. ​ b. Much as I respect him, I can not agree with him. ​ c. Child as he is, he is knowledgeable. ​ d. Lazy a boy as he is, he is kind to help others. ​ f. Praised as he was, he remained modest. (as/so) + 形容词 + as + 主谓，放在句首 ​ As amusing and perceptive as graffiti may sometimes be, it has by no means won universal approval. be倒装 ​ Be it ever so humble, there is no place like home. ​ = However humble it may be, there is no place like home. 比较状语as 结构1: as 形容词/副词 + as ​ The work is not as difficult as you think. 结构2: as + 形容词 +a(n) + 可数名词 + as ​ Americans tend to think from small to large. Let us take as simple an example as the addressing of envelopes. 结构3: 否定句中so代替as ​ He is not so/as clever as you. than: 必须同类比较，必有比较级 ​ He is taller than me. 三种倍数 ​ a. A is … times bigger than B. ​ b. A is … times as big as B. ​ c. A is … times the size of B. The more … , the more: 先翻译从句，后翻译主句 ​ a. The more she practiced, the worse she sang. ​ b. The less you open your heart to others, the more your heart suffers. ​ c. The nearer it is drawn to the surface of the earth, the more a body weighs. (just)as … , so …：类比 ​ a. Just as dark clouds cannot long hide the sun, so no lies can cover up the fact. ​ b. As it is the mark of great minds to say many things in a few words, so it is the mark of little minds to use many words to say nothing. A is to B (what/as) C is to D ​ Air is to man what/as water is to fish = What/As water is to fish, so is air to man. No more … than或not … any more than：同 … 一样不能（than后面肯定式，否定意思） ​ You are no more clever than he. = You are as stupid as he. Not more … than …：平起平坐 ​ You are not more clever than he = You both are clever, not stupid. Not A so much as B/ not so much A as B： ​ 1. 与其说A，不如说B（A，B是平行结构[同介词短语，动词不定时]） ​ a. The great use of a school education is not so much to teach you things as to teach you the art of learning. ​ b. The trumpet player was certainly loud, but I was not bothered by this loudness so much as by his lack of talent. 方式状语常用连词：as, like, as if, as though, the way ​ a. When in Rome, do as the Romans do. ​ b. Work like you don’t need money, love like you’ve never been hurt, dance like nobody’s watching. ​ c. Do it the way you were taught. ​ d. He looks (as though/as if) he is an actor. ​ e. Do as I say, not as I do. 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E7%8A%B6%E8%AF%AD%E4%BB%8E%E5%8F%A5.html"},{"title":"英语语法-形容词adjective","text":"两种形容词的区别 ing：描述引起人某种感觉的事物（主语通常是事物） ed：描述人对事物的感觉（主语通常是人） The interesting children can make other people feel interested in them. 位置 1.限定词+形容词+名词 ​ I am reading an interesting book. 2.不定代词+形容词 ​ There is something(某事) wrong with my computer. 形容词顺序 观点形容词(opinion adjective)+描绘形容词(descriptive adjective) ​ a beautiful white table 描绘形容词顺序 ​ size-&gt;shape-&gt;age-&gt;color-&gt;origin-&gt;material ​ This beautiful big round old red chinese wooden table was mine. 比较级和最高级单音节：-er -est​ -e结尾：-r -st ​ large-&gt;larger brave-&gt;braver ​ -y结尾：变y-&gt;i 加-er -est ​ shy-&gt;shier ​ 元音+辅音：双写最后字母后加-er -est ​ fat-&gt;fatter big-&gt;bigger sad-&gt;sadder 双音节：前面+more most​ 特例：y结尾双音节词，变y-&gt;i 加-er -est ​ happy-&gt;happier early-&gt;earlier ​ early和showly ​ early是不可分割：故变earlier ​ slowly是组合词：故变more slowly 多音节：前面+more most特殊： 原级 比较级 最高级 good/well better best bad/ill worse worst far farther/further farthest/furthest old older/elder oldest/eldest little less least many/much more most late later/latter latest/last up upper uppermost/upmost 特别说明 ​ A:farther(多用实际距离) further(表示抽象，进一步) ​ further discussion ​ B:older(大小，用于比较级中) elder(成员长幼关系，并非大小，不用比较级中) ​ my elder brother his eldest son ​ I am seven years older than Rex ​ C:later, latter, latest, last ​ later(时间上”较迟“)：I am on the phone right, Could you call me later? ​ latter(顺序上”后者“)：The latter point is the most important. ​ latest(最新的，最近的)：the latest games the latest fashions. ​ last(1.上一次,最近一次；2.所有事物中的最后一个) ​ 1.The last game, I won. last week ​ 2.The last three pages of the chapter 原级比较 如同：A + as + 形容词 or 副词 + as + B ​ You are as lazy as she. ​ The work is not as difficult as you think. 如同的否定句：可用so代替第一个as ​ The work is not so difficult as you think. 表示几倍/几分之几：A + 几倍(three times)/几分之几(a third) + as + 形容词 or 副词 +as + B ​ This book is twice as thick as that one. ​ The Earth has a mass nearly one hundred times as much as that of the Moon. A + the same + 名词 + as + B ​ I am as old as you ​ I am the same age as you. 形容词比较级注意1.than前面必须有比较级2.必须是同类事物比较​ a.两个彼此独立的同类事物比较 ​ This question is less difficult than that question. ​ b.自身比较：A + 比较级 + 情形1 + than + 情形2 ​ He did much better in the finals this term than last term ​ c.前后有从属关系时，加other，else与整体区别开来，避免逻辑错误 ​ She works harder than any other student in her class.(不说other就把自身也比较了) 3.比较级前+the的情况：有介词短语 of the two时.​ I think this painting is the more interesting of the two. 越来越…… 单音节：比较级 + and + 比较级：That female singer is getting fatter and fatter. 多音节：more and more 形容词原级： As summer approaches, the sea seems more and more beautiful. 可以修饰比较级的词 a bit, a little bit, a little, a lot, a great deal, any, even, far, by far, much, very much, no, rather, still, slightly. 不用：very, many, quite, fairly. Are you feeling any better? Things are no better than before He makes far fewer mistakes in spellings than before 否定比较级可表示最高级：few， nothing， never， not How have you been? It couldn’t be worse Few are better qualified for the job than he is. I have never heard a better song(This is the best song that I have ever heard) 最高级注意1.the + 最高级 + in +地方-不说：It is the most expensive car of the world-​ It is the most expensive car in the world. 2.第几最高： the + 序数词 + 最高级 + in + 地方​ The Huanghe River is the second longset river in China. ​ THe Yangtze River is the longest river in China, but it is the third longset river in the world 3.the + 最高级 + of + 所属范围​ The youngest (one) of the family is most successful.（理解时+one，but实际应用时省去） ​ Gold is sthe least useful of all metals. ​ The Atlantic is not the largest of the world’s oceans. ​ Silk is the strongest of all natural fibers, ranking in strength with the synthetic fiber nylon. ​ A good book is the best of friends, the same today and forever. ​ 特别：of + 范围放置句首：Of all metals, gold is the least useful. 4.最高级是否加the​ a.形容词需要+the：This is the most interesting book of all. ​ b.副词可加可不加：He works hardest in his class. ​ c.most不加the的特殊用法=very much：The story is most interesting. 无等级形容词：含绝对含义-可用nearly，almost，the most closely，more nearly修饰-absolute, alone, dead, empty, equal, eternal, final, harizontal, perfect, primary, pregnant, round, single, square, straight, supreme, unique, unanimous. 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%BD%A2%E5%AE%B9%E8%AF%8Dadjective.html"},{"title":"英语语法-限定词1","text":"数量限定词只与可数名词连用 只接单数 one each every 只接复数 two（three） both a couple of a few several many a number of 只与不可数名词连用 a little little much a great deal of a large amount of 与可数名词复数或不可数名词连用均可 not any some a lot of lots of plenty of most all 数量词与of连用all/most/some/any of+特指限定词+复数可数或不可数名词 most books most of books 不正确 most of my/these/the/john’s books many/a few/few/several/both/two/three of +特指限定词+ 复数可数名词 many students many of students 不正确 many of these students much/a little/little of +特指限定词+ 不可数名词 much water much of water 不正确 much of the water 其他数量词 a lot of , lots of , a couple of , plenty of , a number of , a great deal of 直接+名词all和both特殊用法all/both my students 可以不加of，其他much/many数量限定词不可这么用 all students all of my students all of students 不正确 数量词a few, few（只接可数）, a little, little（只接不可数）a little，a few为肯定之意，等同于some，有一些 His theory is rather difficult; few people understand it.=almost no people understand it. I have little interest in English, so I am very poor at it. little，few为否定之意，等同于几乎没有 His theory is rather difficult, but a few people understand it. I have a little interest in English, so I like learning it. only a little，only a few very few，very little some and any 陈述句：some 一般用肯定，any一般用否定，表示”一些“。可与可数或不可数名词连用。 I need some medicine to cure my cough. I don’t have any friends here. 疑问句：多用any；在期待对方回答”是“的时候，要用some Have you got any medicine to cure your cough? Would you like to give me some advice? Can I have some more wine? any可以表示”任何一个，无论哪一个“，用于任何句型。 You can catch any bus. They all go to the railway station. 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E9%99%90%E5%AE%9A%E8%AF%8D1.html"},{"title":"英语语法-被动语态","text":"构成：be + 过去分词不同时态的被动语态be变化is, is being, has been, was, was being, had been, will be, will have been 不用by情况 实施者明显 ​ a. The rubbish hasn’t been collected. ​ b. Your hand will be X-rayed. ​ c. The streets are swept every day. 实施者未知或没必要提及 ​ a. The President has been murdered. ​ b. My car has been moved. ​ c. Rice is grown in many countries. ​ d. The library was built in 1890. 泛指人们 ​ acknowledge, assume, believe, claim, consider, estimate, feel, find, know, presume, report, ​ say, think ​ People believe him to be honest. ​ He is believed to be honest. 主句主语是one, you, they 通常用被动语态 ​ One/ You see this kind of advertisement everywhere. ​ This kind of advertisement is seen everywhere. ​ They are building a new public library in our town. ​ A new public library is being built in our town. 避免改换主语(可以接by短语) ​ When he arrived home, a detective arrested him. ​ When he arrived home, he was arrested. 不及物动词没有被动语态 He came here last night. He looks fine. 双宾语可以有两种被动语态(人做主语更常见) Someone gave me a gift. I was given a gift. Someone gave a gift to me. A gift was given to me. 静态被动语态 句子 解释 Now the door is locked 这里的is locked 只是强调动作，起着形容词的作用。 I locked the door two minutes ago. The door was locked by me two minutes ago. 这里的was locked强调动作 Clint broke the window last night The window was broken last night Now the window is broken. 常见interested, excited, satisfied, married, disappointed, scared, frightened, worried, lost ​ a. I am interested in grammar. ​ b. I am satisfied with Clint’s grammar course. ​ c. She is married to her teacher. ​ d. The table is made of wood. ​ e. Are you scared of snake? get与被动语态(get与过去分词连用) 可以构成被动语态 ​ a. My watch got broken while I was playing with the children. ​ b. He got caught by the police because he exceeded the speed limit. 可以接静态的被动形式，表示主语的状态 ​ a. I stopped working because I got tired. ​ b. I got worried because he was two hours late. ​ c. She is getting dressed to the party and has trouble deciding what clothes to wear. have/get sth done have sth done或者get sth done 安排别人把事情做好(主要用法) ​ a. Are you going to repair the car yourself? ​ b. No, I’m going to have it repaired. ​ c. I want to have/get my iterms repaired. (My iterms need repairing.) ​ d. I must get my hair cut = I want someone to cut my hair. ​ e. You should get/have your bike repaired. ​ g. If you don’t get our of my house, I’ll have you arrested. 意外或不行的事情 ​ a. I got my car stolen last year. ​ b. Have you ever had your passport stolen? ​ c. Joe had his leg broken in a fight. ​ d. It took me two hours to get the washing done. ​ e. Don’t get your plans changed. 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E8%A2%AB%E5%8A%A8%E8%AF%AD%E6%80%81.html"},{"title":"算法成长之路leetcode5-6","text":"5. Longest Palindromic SubstringGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example12345678Example 1:Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.Example 2:Input: &quot;cbbd&quot;Output: &quot;bb&quot; JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package algorithm;public class Leetcode5 { public static void main(String[] args) { System.out.println(longestPalindrome(&quot;abbaabb&quot;)); } /** * 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 * * 示例 1： * * 输入: &quot;babad&quot; * 输出: &quot;bab&quot; * 注意: &quot;aba&quot; 也是一个有效答案。 * 示例 2： * * 输入: &quot;cbbd&quot; * 输出: &quot;bb&quot; * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/longest-palindromic-substring * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */ /** * 终于看懂了这个中心向两边扩张算法是什么意思了。 * 先来解释一下为什么中心是2n-1而不是n 比如有字符串abcba，这时回文子串是abcda， * 中心是c；又有字符串adccda，这时回文子串是adccda，中心是cc。 由此可见中心点既有可能是一个字符， * 也有可能是两个字符，当中心为一个字符的时候有n个中心， * 当中心为两个字符的时候有n-1个中心，所以一共有2n-1个中心。 * 然后for循环开始从左到右遍历，为什么会有两次expandAroundCenter，一次是i和i本身，一次是i和i+1， * 这就是上面说到的一个中心与两个中心。 而后会去判断这两种情况下谁的回文子串最长，并标记出这个子串在原字符串中的定位，即start和end。 * * @param s * @return */ public static String longestPalindrome(String s) { if (s == null || s.length() &lt; 1) return &quot;&quot;; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) { // 一个数向两边扩张 int len1 = expandAroundCenter(s, i, i); // 两个数向两边扩张 int len2 = expandAroundCenter(s, i, i + 1); // 取最长的回文 int len = Math.max(len1, len2); // 判读此时长度和原来的最长度 if (len &gt; end - start) { // 求最长回文开始位置 start = i - (len - 1) / 2; // 求最长回文结束位置 end = i + len / 2; } } // 截取最长回文 return s.substring(start, end + 1); } /** * 向两边向两边扩张求长度 * * @param s * @param left * @param right * @return */ private static int expandAroundCenter(String s, int left, int right) { // 定位中心位置 int L = left, R = right; // 判读中间位置是否相等，以及两边扩张是否相等 while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) { // 向左扩张一位 L--; // 向右扩张一位 R++; } // 回文的长度 如 aba 时,当 b = 1时，一个中心点进来,L = 1,R = 1,此时满足循环，L=0,R=2,此时也满足 // 循环，L = -1,R=3,此时循环结束，长度为3 = 3 -（-1） -1 return R - L - 1; }} 6. ZigZag ConversionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example12345678910111213Example 1:Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot;Example 2:Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I JAVA题解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package algorithm;import java.util.ArrayList;import java.util.List;public class Leetcode6 { /** * 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 * &lt;p&gt; * 比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下： * &lt;p&gt; * L C I R * E T O E S I I G * E D H N * 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。 * &lt;p&gt; * 请你实现这个将字符串进行指定行数变换的函数： * &lt;p&gt; * string convert(string s, int numRows); * 示例 1: * &lt;p&gt; * 输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3 * 输出: &quot;LCIRETOESIIGEDHN&quot; * 示例 2: * &lt;p&gt; * 输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4 * 输出: &quot;LDREOEIIECIHNTSG&quot; * 解释: * &lt;p&gt; * L D R * E O E I I * E C I H N * T S G * &lt;p&gt; * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/zigzag-conversion * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */ public String convert(String s, int numRows) { if (numRows == 1) return s; List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; Math.min(numRows, s.length()); i++) // 确定有多少行，每一行放一个待填充的字符串 rows.add(new StringBuilder()); // 当前行 int curRow = 0; // 上移或下移 false上移 boolean goingDown = false; for (char c : s.toCharArray()) { // 挨着放字符到对应的行 rows.get(curRow).append(c); // 判断是否下移，当第一行和最后一行的时候转向 if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown; // 下移行数+1，上移行数-1 curRow += goingDown ? 1 : -1; } // 存最终结果 StringBuilder ret = new StringBuilder(); // 遍历每行，进行连接 for (StringBuilder row : rows) ret.append(row); return ret.toString(); } public static void main(String[] args) { Leetcode6 l = new Leetcode6(); System.out.println(l.convert(&quot;weweqw&quot;, 3)); }}","link":"/Algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode5-6.html"},{"title":"英语语法-限定词2","text":"冠词 a 辅音因素开头的名词前， an 元音因素开头的名词前** 单数可数名词：不能单独使用，必须用冠词或其他限定词 复数可数名词 or 不可数名词： ​**(1)不能同冠词连用** (2)复数名词 or 不可数名词 ​ 泛指：不用the ​ Life is hard sometimes ​ 特指：用the ​ The writer is writing a book about the life of blacks in America. ​ I love music, poetry and art. ​ I don’t like the film, but I like the music(of the film) ​ 表示特指的时候，一般会带有后置定语 第一次提到单数可数名词前用不定冠词a or an，再次出现要用定冠词the谈到对话双方都知道的事物要用the（比如自己房间里的东西）​ can you turn off the light, please? 表示世界上独一无二的事物用the​ the earth, the sky, the equator, the moon, the world, the universe 做形容词的only、最高级、序数词修饰的名词前+the​ the only/best way to cope with the problem. ​ this is the first time I’ve come to Beijing. 乐器、乐团+the（运动不+the）play football or chess or tennis​ the Beatles ​ the Philaadelphia Orchestra ​ play/learn the guitar learn the piano 独一无二的身份不+the​ Henry was elected chairman of the committee ​ For the first time I am king of myself 限定词彼此互斥，不能同时出现在名词前面​ (1)冠词：the an a ​ (2)物主形容词： my your his her our their ​ (3)指示形容词： this that these those ​ (4)名词属格： Tom’s John’s 特殊名词前省略the​ (1)nature : in nature (2)society: in society (3)space: in space ​ (4)man在泛指整个人类时，不加冠词 ​ (5)history在泛指整个历史时，不加冠词 ​ (6)三餐前不+冠词：have something for breakfast/lunch/supper/dinner 交通工具​ 若用介词on：+冠词the（on foot 步行不加the）on the train/plane/boat ​ 若不用介词on，如用by时，不加the： by bicycle/boat/bus/car/plane/train/metro 其他固定介词搭配​ face to face , arm in arm , hand in hand , shoulder to shoulder , side by side ​ inch by inch , day after day , dentist after dentist school or the school​ bed, church, court, hospital, prison, school/college/unversity, sea, work, office ​ 当人们去这些地方做在这些地方应该做的事情时，不加冠词，表示抽象概念 ​ 当要去这些地方不是要做特定的事，而是由于其他原因，要用the ​ his mother is in hospital and he has been in the hospital to take care of her. ​ Bill Blinton came into office in 1992./Bill Clinton came into the office and saw sth. ​ to church(to pray) ​ to hospital(as patients) ​ to/at sea(出海/在海上) ​ to/at/from(去上班/在上班/下班) ​ go to sea(as sailors) go to the sea(go to the seaside) ​ be at sea(as passengers or crew) be at the sea(be at the seaside) ​ by sea(by ship) ​ by the sea(by the seaside) ​ be in office(在任职) be in the office(在办公室里) ​ be out of office(离职) be out of the office(离开办公室) 泛指的四种表达​ 1.不带the的不可数名词 ​ I like music ​ 2.不带the的复数可数名词 ​ bananas are yellow I am afraid of dogs ​ 3.the+单数可数名词（也可表示特指） ​ the whale is the largest mammal on earth ​ the whale is dead ​ 4.a/an+单数可数名词（也可以表示一个） ​ I ate a banana this morning ​ A banana is yellow ​ 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E9%99%90%E5%AE%9A%E8%AF%8D2.html"},{"title":"Git-rebase-用法示例小结","text":"看过上一篇文章【Git如何优雅地回退代码】的小伙伴们，肯定还有很多跟我一样对rebase的使用还是云里雾里的，这篇文章将使你彻底搞明白怎么使用。rebase在git中是一个非常有魅力的命令，使用得当会极大提高自己的工作效率；相反，如果乱用，会给团队中其他人带来麻烦。它的作用简要概括为：可以对某一段线性提交历史进行编辑、删除、复制、粘贴；因此，合理使用rebase命令可以使我们的提交历史干净、简洁！ 前提：不要通过rebase对任何已经提交到公共仓库中的commit进行修改（你自己一个人玩的分支除外） 一、合并多个commit为一个完整commit当我们在本地仓库中提交了多次，在我们把本地提交push到公共仓库中之前，为了让提交记录更简洁明了，我们希望把如下分支B、C、D三个提交记录合并为一个完整的提交，然后再push到公共仓库。 现在我们在测试分支上添加了四次提交，我们的目标是把最后三个提交合并为一个提交： 这里我们使用命令: 1git rebase -i [startpoint] [endpoint] 其中-i的意思是--interactive，即弹出交互式的界面让用户编辑完成合并操作，[startpoint] [endpoint]则指定了一个编辑区间，如果不指定[endpoint]，则该区间的终点默认是当前分支HEAD所指向的commit(注：该区间指定的是一个前开后闭的区间)。 在查看到了log日志后，我们运行以下命令： 1git rebase -i 36224db or 1git rebase -i HEAD~3 然后我们会看到如下界面: 上面未被注释的部分列出的是我们本次rebase操作包含的所有提交，下面注释部分是git为我们提供的命令说明。每一个commit id 前面的pick表示指令类型，git 为我们提供了以下几个命令: pick：保留该commit（缩写:p） reword：保留该commit，但我需要修改该commit的注释（缩写:r） edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e） squash：将该commit和前一个commit合并（缩写:s） fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f） exec：执行shell命令（缩写:x） drop：我要丢弃该commit（缩写:d） 根据我们的需求，我们将commit内容编辑如下: 此做法是把后面两次提交都合并到第一次提交里，改完上面的操作后执行vim：wq保存信息，之后会跳出下面的修改注释界面： 编辑完保存即可完成commit的合并了： 二、将某一段commit粘贴到另一个分支上当我们项目中存在多个分支，有时候我们需要将某一个分支中的一段提交同时应用到其他分支中，就像下图： 我们希望将develop分支中的C~E部分复制到master分支中，这时我们就可以通过rebase命令来实现（如果只是复制某一两个提交到其他分支，建议使用更简单的命令:git cherry-pick）。 在实际模拟中，我们创建了master和develop两个分支: master分支: develop分支: 我们使用命令的形式为: 1git rebase [startpoint] [endpoint] --onto [branchName] 其中，[startpoint] [endpoint]仍然和上一个命令一样指定了一个编辑区间(前开后闭)，--onto的意思是要将该指定的提交复制到哪个分支上。 所以，在找到C(90bc0045b)和E(5de0da9f2)的提交id后，我们运行以下命令： 1git rebase 90bc0045b^ 5de0da9f2 --onto master 以上命令有网友补充内容： 大帅_8183 15楼 2019.05.26 17:30 博主，关于你说的“[startpoint] [endpoint]仍然和上一个命令一样指定了一个编辑区间(前开后闭)” ，其中的前开后闭的思维，其实是有歧义的。 如果一定要用“区间”来表示的话， 那它表示的也一定是一个“前闭后闭”的区间；至于，博主理解的“前开后闭”,其实是博主想使用[startpoint] 这个commit上的功能，但这部分功能本身 就是 上 一个commit提交功能后生成的新的commit(也就是 这里的[startpoint])； 而原rebase的[startpoint] 的意思是，应该是表示，在此commit开始（[startpoint]）更改的代码部分； andy_dfa5 5楼 2018.08.13 14:14 作者写的很好，但是有个小错误，就是rebase是一个开闭集，就是上面例子中 git rebase 90bc0045b^ 5de0da9f2 –onto master。90bc0045b^这个提交是不会生效的，如果要这个生效要从b4d576开始rebase 关于上面的质疑自己动手试下就知道结果了。 注:因为[startpoint] [endpoint]指定的是一个前开后闭的区间，为了让这个区间包含C提交，我们将区间起始点向后退了一步。运行完成后查看当前分支的日志: 可以看到，C~E部分的提交内容已经复制到了G的后面了，大功告成？NO！我们看一下当前分支的状态: 当前HEAD处于游离状态，实际上，此时所有分支的状态应该是这样: 所以，虽然此时HEAD所指向的内容正是我们所需要的，但是master分支是没有任何变化的，git只是将C~E部分的提交内容复制一份粘贴到了master所指向的提交后面，我们需要做的就是将master所指向的提交id设置为当前HEAD所指向的提交id就可以了，即: 12git checkout mastergit reset --hard 0c72e64 此时我们才大功告成！ 参考文章:参考链接","link":"/Git/Git-rebase-%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B%E5%B0%8F%E7%BB%93.html"},{"title":"Git如何优雅地回退代码","text":"前言从接触编程就开始使用 Git 进行代码管理，先是自己玩 Github，又在工作中使用 Gitlab，虽然使用时间挺长，可是也只进行一些常用操作，如推拉代码、提交、合并等，更复杂的操作没有使用过，看过的教程也逐渐淡忘了，有些对不起 Linus 大神。 出来混总是要还的，前些天就遇到了 Git 里一种十分糟心的场景，并为之前没有深入理解 Git 命令付出了一下午时间的代价。 先介绍一下这种场景，我们一个项目从 N 版本升到 A 版本时引入了另一项目的 jar 包，又陆续发布了 B、C 版本，但在 C 版本后忽然发现了 A 版本引入的 jar 包有极大的性能问题，B、C 版本都是基于 A 版本发布的，要修复 jar 包性能问题，等 jar 包再发版还得几天，可此时线上又有紧急的 Bug 要修，于是就陷入了进退两难的境地。 最后决定先将代码回退到 A 版本之前，再基于旧版本修复 Bug，也就开始了五个小时的受苦之路。 基础试探revert首先肯定的是 revert，git revert commit_id 能产生一个 与 commit_id 完全相反的提交，即 commit_id 里是添加， revert 提交里就是删除。 但是使用 git log 查看了提交记录后，我就打消了这种想法，因为提交次数太多了，中途还有几次从其他分支的 merge 操作。 ”利益于”我们不太干净的提交记录，要完成从 C 版本到 N 版本的 revert，我需要倒序执行 revert 操作几十次，如果其中顺序错了一次，最终结果可能就是不对的。 另外我们知道我们在进行代码 merge 时，也会把 merge 信息产生一次新的提交，而 revert 这次 merge commit 时需要指定 m 参数，以指定 mainline 这个 mainline 是主线，也是我们要保留代码的主分支，从 feature 分支往 develop 分支合并，或由 develop 分支合并到 master 的提交还好确定，但 feature 分支互相合并时，我哪知道哪个是主线啊。 所以 revert 的文案被废弃了。 Reset然后就考虑 reset 了， reset 也能使代码回到某次提交，但跟 revert 不同的是， reset 是将提交的 HEAD 指针指到某次提交，之后的提交记录会消失，就像从没有过这么一次提交。 但由于我们都在 feature 分支开发，我在 feature 分支上将代码回退到某次提交后，将其合并到 develop 分支时却被提示报错。 这是因为 feature 分支回退了提交后，在 git 的 workflow 里，feature 分支是落后于 develop 分支的，而合并向 develop 分支，又需要和 develop 分支保持最新的同步，需要将 develop 分支的数据合并到 feature 分支上，而合并后，原来被 reset 的代码又回来了。 这个时候另一个可选项是在 master 分支上执行 reset，使用 --hard 选项完全抛弃这些旧代码，reset 后再强制推到远端。 12master&gt; git reset --hard commit_idmaster&gt; git push --force origin master 但是还是有问题，首先，我们的 master 分支在 gitlab 里是被保护的，不能使用 force push，毕竟风险挺大了，万一有人 reset 到最开始的提交再强制 push 的话，虽然可以使用 reflog 恢复，但也是一番折腾。 另外，reset 毕竟太野蛮，我们还是想能保留提交历史，以后排查问题也可以参考。 升级融合rebase只好用搜索引擎继续搜索，看到有人提出可以先使用 rebase 把多个提交合并成一个提交，再使用 revert 产生一次反提交，这种方法的思路非常清晰，把 revert 和 rebase 两个命令搭配得很好，相当于使用 revert 回退的升级版。 先说一下 rebase，rebase 是”变基”的意思，这里的”基”，在我理解是指[多次] commit 形成的 git workflow，使用 rebase，我们可以改变这些历史提交，修改 commit 信息，将多个 commit 进行组合。 介绍 rebase 的文档有很多，我们直接来说用它来进行代码回退的步骤。 首先，切出一个新分支 F，使用 git log 查询一下要回退到的 commit 版本 N。 使用命令 git rebase -i N， -i 指定交互模式后，会打开 git rebase 编辑界面，形如： 1234pick 6fa5869 commit1pick 0b84ee7 commit2pick 986c6c8 commit3pick 91a0dcc commit4 这些 commit 自旧到新由上而下排列，我们只需要在 commit_id 前添加操作命令即可。 在合并 commit 这个需求里，我们可以选择 pick(p) 最旧的 commit1，然后在后续的 commit_id 前添加 squash(s) 命令，将这些 commits 都合并到最旧的 commit1 上。 保存 rebase 结果后，再编辑 commit 信息，使这次 rebase 失效，git 会将之前的这些 commit 都删除，并将其更改合并为一个新的 commit5 如果出错了，也可以使用 git rebase --abort/--continue/--edit-todo`` 对之前的编辑进行撤销、继续编辑。 这个时候，主分支上的提交记录是 older, commit1, commit2, commit3, commit4 而 F 分支上的提交记录是 older, commit5，由于 F 分支的祖先节点是 older，明显落后于主分支的 commit4，将 F 分支向主分支合并是不允许的 所以我们需要执行 git merge master 将主分支向 F 分支合并，合并后 git 会发现 commit1 到 commit4 提交的内容和 F 分支上 commit5 的修改内容是完全相同的，会自动进行合并，内容不变，但多了一个 commit5。 再在 F 分支上对 commit5 进行一次 revert 反提交，就实现了把 commit1 到 commit4 的提交全部回退。 这种方法的取巧之处在于巧妙地利用了 rebase 操作历史提交的功能和 git 识别修改相同自动合并的特性，操作虽然复杂，但历史提交保留得还算完整。 rebase 这种修改历史提交的功能非常实用，能够很好地解决我们遇到的一个小功能提交了好多次才好使，而把 git 历史弄得乱七八糟的问题，只需要注意避免在多人同时开发的分支使用就行了。 遗憾的是，当天我并没有理解到 rebase 的这种思想，又由于试了几个方法都不行太过于慌乱，在 rebase 完成后，向主分支合并被拒之后对这些方式的可行性产生了怀疑，又加上有同事提出听起来更可行的方式，就中断了操作。 文件操作这种更可行的方式就是对文件操作，然后让 git 来识别变更，具体是： 从主分支上切出一个跟主分支完全相同的分支 F。 从文件管理系统复制项目文件夹为 bak，在 bak 内使用 git checkout N 将代码切到想要的历史提交，这时候 git 会将 bak 内的文件恢复到 N 状态。 在从文件管理系统内，将 bak 文件夹下 除了 .git 文件夹下的所有内容复制粘贴到原项目目录下。git 会纯从文件级别识别到变更，然后更新工作区。 在原项目目录下执行 add 和 commit，完成反提交。 这种方式的巧妙之处在于利用 git 本身对文件的识别，不牵涉到对 workflow 操作。 小结最后终于靠着文件操作方式成功完成了代码回退，事后想来真是一把心酸泪。 为了让我的五个小时不白费，复盘一下当时的场景，学习并总结一下四种代码回退的方式： revert 适合需要回退的历史提交不多，且无合并冲突的情景。 如果你可以向 master 强推代码，且想让 git log 里不再出现被回退代码的痕迹，可以使用 git reset --hard + git push --force`` 的方式。 如果你有些 geek，追求用”正规而正统”的方式来回退代码，rebase + revert 满足你的需求。 如果你不在乎是否优雅，想用最简单，最直接的方式，文件操作正合适。 git 真的是非常牛逼的代码管理工具，入手简单，三五个命令组合起来就足够完成工作需求，又对 geeker 们非常友好，你想要的骚操作它都支持，学无止境啊。 参考文章:参考链接","link":"/Git/Git%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%9B%9E%E9%80%80%E4%BB%A3%E7%A0%81.html"},{"title":"github gpg failed to sign the data","text":"git gpg commit sign error:gpg failed to sign the datafatal: failed to write commit object 1234567891011121314brew uninstall gpgbrew install gpg2brew install pinentry-mac (if needed)gpg --full-generate-key #Create a key by using an algorithm.#Get generated key by executing: gpg --list-keys#detail listgpg --list-secret-keys --keyid-format LONGsec rsa2048/F9F78B768Fxxxxx 2020-03-13 [SC] [有效至：2022-03-13] 79418A9275A4D98B86FF39F6xxxxxxxxxxx#Set the key here git config --global user.signingkey F9F78B768Fxxxxxgit config --global gpg.program /usr/local/bin/gpggit config --global commit.gpgsign true If you want to export your Key to GitHub then:gpg --armor --export F9F78B768Fxxxxx and add this key to GitHub at GPG keys: https://github.com/settings/keys (with START and END line included) If the issue still exists: 123test -r ~/.bash_profile &amp;&amp; echo 'export GPG_TTY=$(tty)' &gt;&gt; ~/.bash_profileecho 'export GPG_TTY=$(tty)' &gt;&gt; ~/.profile If the issue still exists: Install https://gpgtools.org and sign the key that you used by pressing Sign from the menu bar: Key-&gt;Sign If the issue still exists: Go to: ‎⁨your global .gitconfig file which in my case is at: ‎⁨/Users/gent/.gitconfig And modify the .gitconfig file (please make sure Email and Name are the same with the one that you have created while generating the Key): 1234567891011121314151617[user] email = gent@youremail.com name = Gent signingkey = &lt;YOURKEY&gt;[gpg] program = /usr/local/bin/gpg[commit] gpsign = true gpgsign = true[filter &quot;lfs&quot;] process = git-lfs filter-process required = true clean = git-lfs clean -- %f smudge = git-lfs smudge -- %f[credential] helper = osxkeychain When you create and add a key to gpg-agent you define something called passphrase. Now that passphrase at some point expires, and gpg needs you to enter it again to unlock your key so that you can start signing again. When you use any other program that interfaces with gpg, gpg’s prompt to you to enter your passphrase does not appear (basically gpg-agent when daemonized cannot possibly show you the input dialog in stdin). One of the solutions is gpg --sign a_file.txt (this is very import!!!) then enter the passphrase that you have entered when you created your key and then everything should be fine (gpg-agent should automatically sign) See this answer on how to set longer timeouts for your passphrase so that you do not have to do this all the time. Or you can completely remove the passphrase with ssh-keygen -p Edit: Do a man gpg-agent to read some stuff on how to have the above happen automatically and add the lines: GPG_TTY=$(tty)export GPG_TTYon your .bashrc if you are using bash(this is the correct answer but I am keeping my train of thought above as well) my environment 1234567gpg --versiongpg (GnuPG) 2.2.19libgcrypt 1.8.5Copyright (C) 2019 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;https://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. reference:reference","link":"/Git/github-gpg-failed-to-sign-the-data.html"},{"title":"intellj idea 详细调试代码debug","text":"Debug用来追踪代码的运行流程，通常在程序运行过程中出现异常，启用Debug模式可以分析定位异常发生的位置，以及在运行过程中参数的变化。通常我们也可以启用Debug模式来跟踪代码的运行流程去学习三方框架的源码。 在Intellij IDEA中使用好Debug，主要包括如下内容： Debug开篇 基本用法&amp;快捷键 变量查看 计算表达式 智能步入 断点条件设置 多线程调试 回退断点 中断Debug 一、Debug开篇首先看下IDEA中Debug模式下的界面。如下是在IDEA中启动Debug模式，进入断点后的界面，我这里是Windows，可能和Mac的图标等会有些不一样。就简单说下图中标注的8个地方： 以Debug模式启动服务，左边的一个按钮则是以Run模式启动。在开发中，我一般会直接启动Debug模式，方便随时调试代码。 断点：在左边行号栏单击左键，或者快捷键Ctrl+F8 打上/取消断点，断点行的颜色可自己去设置。 Debug窗口：访问请求到达第一个断点后，会自动激活Debug窗口。如果没有自动激活，可以去设置里设置，如图1.2。 调试按钮：一共有8个按钮，调试的主要功能就对应着这几个按钮，鼠标悬停在按钮上可以查看对应的快捷键。在菜单栏Run里可以找到同样的对应的功能，如图1.4。 服务按钮：可以在这里关闭/启动服务，设置断点等。 方法调用栈：这里显示了该线程调试所经过的所有方法，勾选右上角的[Show All Frames]按钮，就不会显示其它类库的方法了，否则这里会有一大堆的方法。 Variables：在变量区可以查看当前断点之前的当前方法内的变量。 Watches：查看变量，可以将Variables区中的变量拖到Watches中查看 在设置里勾选Show debug window on breakpoint，则请求进入到断点后自动激活Debug窗口。 如果你的IDEA底部没有显示工具栏或状态栏，可以在View里打开，显示出工具栏会方便我们使用。可以自己去尝试下这四个选项。 在菜单栏Run里有调试对应的功能，同时可以查看对应的快捷键。 二、基本用法&amp;快捷键Debug调试的功能主要对应着图一中4和5两组按钮： 1、首先说第一组按钮，共8个按钮，从左到右依次如下： Show Execution Point (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。 Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。 Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法，如第25行的put方法。 Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。 Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。 Drop Frame (默认无)：回退断点，后面章节详细说明。 Run to Cursor (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。 Evaluate Expression (Alt + F8)：计算表达式，后面章节详细说明。 2、第二组按钮，共7个按钮，从上到下依次如下： Rerun ‘xxxx’：重新运行程序，会关闭服务后重新启动程序。 Update ‘tech’ application (Ctrl + F5)：更新程序，一般在你的代码有改动后可执行这个功能。而这个功能对应的操作则是在服务配置里，如图2.3。 Resume Program (F9)：恢复程序，比如，你在第20行和25行有两个断点，当前运行至第20行，按F9，则运行到下一个断点(即第25行)，再按F9，则运行完整个流程，因为后面已经没有断点了。 Pause Program：暂停程序，启用Debug。目前没发现具体用法。 Stop ‘xxx’ (Ctrl + F2)：连续按两下，关闭程序。有时候你会发现关闭服务再启动时，报端口被占用，这是因为没完全关闭服务的原因，你就需要查杀所有JVM进程了。 View Breakpoints (Ctrl + Shift + F8)：查看所有断点，后面章节会涉及到。 Mute Breakpoints：哑的断点，选择这个后，所有断点变为灰色，断点失效，按F9则可以直接运行完程序。再次点击，断点变为红色，有效。如果只想使某一个断点失效，可以在断点上右键取消Enabled，如图2.4，则该行断点失效。 更新程序，On ‘Update’ actions，执行更新操作时所做的事情，一般选择’Update classes and resources’，即更新类和资源文件。 一般配合热部署插件会更好用，如JRebel，这样就不用每次更改代码后还要去重新启动服务。如何激活JRebel，在最后章节附上。 下面的On frame deactivation，在IDEA窗口失去焦点时触发，即一般你从idea切换到浏览器的时候，idea会自动帮你做的事情，一般可以设置Do nothing，频繁切换会比较消耗资源的。 三、变量查看在Debug过程中，跟踪查看变量的变化是非常必要的，这里就简单说下IDEA中可以查看变量的几个地方，相信大部分人都了解。 1、如下，在IDEA中，参数所在行后面会显示当前变量的值。 2、光标悬停到参数上，显示当前变量信息。点击+号查看详情 3、在Variables里查看，这里显示当前方法里的所有变量。 4、在Watches里，点击New Watch，输入需要查看的变量。或者可以从Variables里拖到Watche里查看。 如果你发现你没有Watches，可能在下图所在的地方。 四、计算表达式在前面提到的计算表达式如图4.1的按钮，Evaluate Expression (Alt + F8) 。可以使用这个操作在调试过程中计算某个表达式的值，而不用再去打印信息。 1、按Alt + F8或按钮，或者，你可以选中某个表达式再Alt + F8，弹出计算表达式的窗口，如下，回车或点击Evaluate计算表达式的值。 这个表达式不仅可以是一般变量或参数，也可以是方法，当你的一行代码中调用了几个方法时，就可以通过这种方式查看查看某个方法的返回值。 2、设置变量，在计算表达式的框里，可以改变变量的值，这样有时候就能很方便我们去调试各种值的情况了不是。 五、智能步入想想，一行代码里有好几个方法，怎么只选择某一个方法进入。之前提到过使用Step Into (Alt + F7) 或者 Force Step Into (Alt + Shift + F7)进入到方法内部，但这两个操作会根据方法调用顺序依次进入，这比较麻烦。 那么智能步入就很方便了，智能步入，这个功能在Run里可以看到，Smart Step Into (Shift + F7)，如图5.1 按Shift + F7，会自动定位到当前断点行，并列出需要进入的方法， 点击方法进入方法内部。 如果只有一个方法，则直接进入，类似Force Step Into。 六、断点条件设置通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。 通常，当我们在遍历一个比较大的集合或数组时，在循环内设置了一个断点，难道我们要一个一个去看变量的值？那肯定很累，说不定你还错过这个值得重新来一次。 1、在断点上右键直接设置当前断点的条件，我设置exist为true时断点才生效。 2、点击View Breakpoints (Ctrl + Shift + F8)，查看所有断点。 Java Line Breakpoints 显示了所有的断点，在右边勾选Condition，设置断点的条件。 勾选Log message to console，则会将当前断点行输出到控制台。 勾选Evaluate and log，可以在执行这行代码是计算表达式的值，并将结果输出到控制台。 3、再说说右边的Filters过滤，这些一般情况下不常用，简单说下意思。 Instance filters：实例过滤，输入实例ID(如下图中的实例ID)，但是我这里没有成功，不知道什么原因，知道的朋友留个言。 Class filters：类过滤，根据类名过滤，同样没有成功…. Pass count：用于循环中，如果断点在循环中，可以设置该值，循环多少次后停在断点处，之后的循环都会停在断点处。 4、异常断点，通过设置异常断点，在程序中出现需要拦截的异常时，会自动定位到异常行。 如图，点击+号添加Java Exception Breakpoints，添加异常断点。然后输入需要断点的异常类，如图6.7，之后可以在Java Exception Breakpoints里看到添加的异常断点。 我这里添加了一个NullPointerException异常断点，如图，出现空指针异常后，自动定位在空指针异常行。 七、多线程调试一般情况下我们调试的时候是在一个线程中的，一步一步往下走。但有时候你会发现在Debug的时候，想发起另外一个请求都无法进行了？ 那是因为IDEA在Debug时默认阻塞级别是ALL，会阻塞其它线程，只有在当前调试线程走完时才会走其它线程。可以在View Breakpoints里选择Thread，如图，然后点击Make Default设置为默认选项。 切换线程，在图中Frames的下拉列表里，可以切换当前的线程，如下我这里有两个Debug的线程，切换另外一个则进入另一个Debug的线程。 八、回退断点在调试的时候，想要重新走一下流程而不用再次发起一个请求？ 1、首先认识下这个方法调用栈，如图，首先请求进入DemoController的insertDemo方法，然后调用insert方法，其它的invoke我们且先不管，最上面的方法是当前断点所在的方法。 2、断点回退 所谓的断点回退，其实就是回退到上一个方法调用的开始处，在IDEA里测试无法一行一行地回退或回到到上一个断点处，而是回到上一个方法。 回退的方式有两种，一种是Drop Frame按钮，按调用的方法逐步回退，包括三方类库的其它方法(取消Show All Frames按钮会显示三方类库的方法，下图2)。 第二种方式，在调用栈方法上选择要回退的方法，右键选择Drop Frame，回退到该方法的上一个方法调用处，此时再按F9(Resume Program)，可以看到程序进入到该方法的断点处了。 但有一点需要注意，断点回退只能重新走一下流程，之前的某些参数/数据的状态已经改变了的是无法回退到之前的状态的，如对象、集合、更新了数据库数据等等。 九、中断Debug想要在Debug的时候，中断请求，不要再走剩余的流程了？ 有些时候，我们看到传入的参数有误后，不想走后面的流程了，怎么中断这次请求呢(后面的流程要删除数据库数据呢….)，难道要关闭服务重新启动程序？嗯，我以前也是这么干的。 确切的说，我也没发现可以直接中断请求的方式(除了关闭服务)，但可以通过Force Return，即强制返回来避免后续的流程。 点击Force Return，弹出Return Value的窗口，我这个方法的返回类型为Map，所以，我这里直接返回 results，来强制返回，从而不再进行后续的流程。或者你可以new HashMap&lt;&gt;()。 参考文章:参考链接","link":"/Git/intellj-idea-%E8%AF%A6%E7%BB%86%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81debug.html"},{"title":"mysql-like模糊查询优化","text":"sql语句写法一张表大概40万左右的数据，用like模糊查询title字段，很慢，title字段已经建立了索引，mysql 对 someTitle% 这样的模糊查询在有索引的前提下是很快的。所以下面这两台sql语句差别就很大了$sql1 = “… title like someTitle%” (0.001秒) $sql2 = “…… title like %someTitle%” (0.8秒) 这两句的效率相差了800倍，这很可观啊。所以我有个想法：在不用分词的方法的前提下，把存储的title字段，加一个特别的前缀，比如”im_prefix”，比如一条记录的title=”我是标题党”，那么存储的时候就存储为”im_prefix我是标题党”。这样一来，我们要模糊查找”标题党”这个关键词的时候，就把sql写成这样：$sql1 = “…… title like im_prefix%标题党%” (花费0.001秒)，前台显示数据的时候，自然把取到的title过滤掉”im_prefix”这个前缀了。 在使用msyql进行模糊查询的时候，很自然的会用到like语句，通常情况下，在数据量小的时候，不容易看出查询的效率，但在数据量达到百万级，千万级的时候，查询的效率就很容易显现出来。这个时候查询的效率就显得很重要！ 一般情况下like模糊查询的写法为（field已建立索引）： SELECTcolumnFROMtableWHEREfieldlike’%keyword%’; 上面的语句用explain解释来看，SQL语句并未用到索引，而且是全表搜索，如果在数据量超大的时候，可想而知最后的效率会是这样 对比下面的写法： SELECTcolumnFROMtableWHEREfieldlike’keyword%’; 这样的写法用explain解释看到，SQL语句使用了索引，搜索的效率大大的提高了！ 但是有的时候，我们在做模糊查询的时候，并非要想查询的关键词都在开头，所以如果不是特别的要求，”keywork%”并不合适所有的模糊查询 我在网上搜索时发现很多mysql函数用来解决这个问题，我测试出来的结果是跟like相比并没有任何优势。 1.LOCATE（’substr’,str,pos）方法 SELECTcolumnFROMtableWHERELOCATE(‘keyword’, field)&gt;0 2.POSITION(‘substr’ IN field)方法 SELECTcolumnFROMtableWHEREPOSITION(‘keyword’INfiled) 3.INSTR(str,’substr’)方法 SELECTcolumnFROMtableWHEREINSTR(field,’keyword’)&gt;0 这几种方法都试过后，发现百万级别数据以上，时间是跟like差不多，并没有解决问题，因为都没走到索引。 这种情况下想要实现后几位模糊查询并且速度要快，在此我想了两个办法，一个是不需要mysql版本支持，一个需要mysql5.7版本以上 第一种方法：新增一列字段新增一列字段，那个字段是你需要实现模糊查询的倒序，也就是原本是ABCD，那列字段就是DCBA 然后在那个字段添上索引 UPDATE tbl_ser_apply a set order_no_desc = REVERSE (SUBSTRING(a.order_no, -6)) ALTER TABLE tbl_ser_apply ADD INDEX order_no_desc ( order_no_desc ) 我这边设的是后六位 也就是我把之前字段的后6位倒序后存入新的字段，也可以整个字段倒序后存入新的字段 12345678910111213141516171819202122select a.*,a1.id as id2,a1.order_no as orderNo2,a1.tran_amt as tranAmt2,a1.fee_amt as feeAmt2,a1.repayment_date_req as repaymentDateReq2 ,a1.status as status2,a1.create_time as createTime2,a1.update_time as updateTime2 from ( select tsa.id,tsa.order_no as orderNo,tsa.repayment_date_req as repaymentDateReq,tsa.status,tsa.fee_state as feeState,tsa.repayment_flag as repaymentFlag, tsa.capital_return_flag as capitalReturnFlag,tsa.tran_amt as tranAmt,tsa.fee_amt as feeAmt,tsa.capital_returned_amont as capitalReturnedAmont, tsa.wait_amt as waitAmt,tsa.back_charge_amt as backChargeAmt,tsa.create_time as createTime,tui.real_name as realName,tui.mobile_no as mobileNo, tc.bank_card_no as bankCardNo,tmi.merchant_name as merchantName,tui.mer_no as merNo,tsa.reserved1 as reserved1,tsa.parent_id as parentId,tc.bank_name as bankName,tc.holder_name as holderName, tc.certificate_no as certificateNo from tbl_ser_apply as tsa LEFT JOIN tbl_user_info as tui on tsa.userid=tui.id LEFT JOIN tbl_merchant_inf as tmi on tmi.merchant_no=tui.mer_no LEFT JOIN tbl_cusinfo tc on tc.id=tsa.cusInf_id where tsa.order_no_desc like REVERSE('%372191') ORDER BY tsa.create_time desc ) a LEFT JOIN tbl_ser_apply a1 on a.parentId=a1.id 我的整个sql是这样的 实际上最后查询的时候是这样 where tsa.order_no_desc like REVERSE(‘%372191’) 需要修改sql和java代码，查询的是新增反向字段，而不是原来的字段 这样就能实现走索引 原来的sql不走索引的情况下查询出来需要20S，优化后只需要0.049S 这种方法适合mysql5.7以下版本，这样能大大加快模糊查询速度，而且能到1000W以上应该都是没问题的 第二种方法：虚拟列需要mysql5.7以上版本支持，用到虚拟列的方法，原理跟上述方法一样 alter table tbl_ser_apply add column virtual_col varchar(20) as (REVERSE (SUBSTRING(tbl_ser_apply.order_no, -6))); ALTER TABLE tbl_ser_apply ADD INDEX virtual_col ( virtual_col ) 在MySQL 5.7中，支持两种Generated Column，即Virtual Generated Column和Stored Generated Column，前者只将Generated Column保存在数据字典中（表的元数据），并不会将这一列数据持久化到磁盘上；后者会将Generated Column持久化到磁盘上，而不是每次读取的时候计算所得。很明显，后者存放了可以通过已有数据计算而得的数据，需要更多的磁盘空间，与Virtual Column相比并没有优势，因此，MySQL 5.7中，不指定Generated Column的类型，默认是Virtual Column。 如果需要Stored Generated Golumn的话，可能在Virtual Generated Column上建立索引更加合适 综上，一般情况下，都使用Virtual Generated Column，这也是MySQL默认的方式 语法： [ GENERATED ALWAYS ] AS ( ) [ VIRTUAL|STORED ] [ UNIQUE [KEY] ] [ [PRIMARY] KEY ] [ NOT NULL ] [ COMMENT ] 这样做比上一个方法好的地方是，不需要修改java代码，只需要修改很小一部分的sql语句即可，上一个方法其实实现后要修改的java代码要不少，而且每次新增修改删除时，都要加上这个字段的代码，而新增虚拟列的话，那一列的字段是自动添加修改，通过计算得出的，所以代码完全不需要修改，只需要修改操作原来字段的sql即可。 12345678910111213141516171819202122select a.*,a1.id as id2,a1.order_no as orderNo2,a1.tran_amt as tranAmt2,a1.fee_amt as feeAmt2,a1.repayment_date_req as repaymentDateReq2 ,a1.status as status2,a1.create_time as createTime2,a1.update_time as updateTime2 from ( select tsa.id,tsa.order_no as orderNo,tsa.repayment_date_req as repaymentDateReq,tsa.status,tsa.fee_state as feeState,tsa.repayment_flag as repaymentFlag, tsa.capital_return_flag as capitalReturnFlag,tsa.tran_amt as tranAmt,tsa.fee_amt as feeAmt,tsa.capital_returned_amont as capitalReturnedAmont, tsa.wait_amt as waitAmt,tsa.back_charge_amt as backChargeAmt,tsa.create_time as createTime,tui.real_name as realName,tui.mobile_no as mobileNo, tc.bank_card_no as bankCardNo,tmi.merchant_name as merchantName,tui.mer_no as merNo,tsa.reserved1 as reserved1,tsa.parent_id as parentId,tc.bank_name as bankName,tc.holder_name as holderName, tc.certificate_no as certificateNo from tbl_ser_apply as tsa LEFT JOIN tbl_user_info as tui on tsa.userid=tui.id LEFT JOIN tbl_merchant_inf as tmi on tmi.merchant_no=tui.mer_no LEFT JOIN tbl_cusinfo tc on tc.id=tsa.cusInf_id where tsa.virtual_col like '372191%' ORDER BY tsa.create_time desc ) a LEFT JOIN tbl_ser_apply a1 on a.parentId=a1.id 经过我的测试后，原来不走索引是20S 用上一个方法是0.049s 用第二个方法的话是0.1S 虽然慢了0.05S 那是计算数据的时间，但这样的方案已经大大缩短了模糊查询时间，而且不需要修改java代码，个人推荐使用第二种！ 参考文章:参考链接1参考链接2","link":"/MySQL/mysql-like%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.html"},{"title":"mysql数据库索引解析","text":"摘要看了很多关于索引的博客，讲的大同小异。但是始终没有让我明白关于索引的一些概念，如B-Tree索引，Hash索引，唯一索引….或许有很多人和我一样，没搞清楚概念就开始研究B-Tree，B+Tree等结构，导致在面试的时候答非所问！ 索引是什么?索引是帮助MySQL高效获取数据的数据结构。 索引能干什么?索引非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。 索引能够轻易将查询性能提高好几个数量级，总的来说就是可以明显的提高查询效率。 索引的分类? 从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式， 从应用层次来分：普通索引，唯一索引，复合索引 根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。 平时讲的索引类型一般是指在应用层次的划分。就像手机分类：安卓手机，IOS手机 与 华为手机，苹果手机，OPPO手机一样。 普通索引**：**即一个索引只包含单个列，一个表可以有多个单列索引 唯一索引：索引列的值必须唯一，但允许有空值 复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并 聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。 非聚簇索引：不是聚簇索引，就是非聚簇索引 索引的底层实现mysql默认存储引擎innodb只显式支持B-Tree( 从技术上来说是B+Tree)索引，对于频繁访问的表，innodb会透明建立自适应hash索引，即在B树索引基础上建立hash索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。 不谈存储引擎，只讨论实现(抽象) Hash索引基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。 B-Tree索引（MySQL使用B+Tree）B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。 B+Tree索引 是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。 结合存储引擎来讨论（一般默认使用B+Tree） 案例：假设有一张学生表，id为主键 id name birthday 1 Tom 1996-01-01 2 Jann 1996-01-04 3 Ray 1996-01-08 4 Michael 1996-01-10 5 Jack 1996-01-13 6 Steven 1996-01-23 7 Lily 1996-01-25 在MyISAM引擎中的实现（二级索引也是这样实现的） 在InnoDB中的实现 为什么索引结构默认使用B+Tree，而不是Hash，二叉树，红黑树？B+tree：因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低； Hash：虽然可以快速定位，但是没有顺序，IO复杂度高。 二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。 红黑树：树的高度随着数据量增加而增加，IO代价高。 红黑树: 每个节点或者是黑色，或者是红色。 根节点是黑色。 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！] 如果一个节点是红色的，则它的子节点必须是黑色的。 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 为什么官方建议使用自增长主键作为索引？结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。 插入连续的数据： 插入非连续的数据 简单总结下 MySQL使用B+Tree作为索引数据结构。 B+Tree在新增数据时，会根据索引指定列的值对旧的B+Tree做调整。 从物理存储结构上说，B-Tree和B+Tree都以页(4K)来划分节点的大小，但是由于B+Tree中中间节点不存储数据，因此B+Tree能够在同样大小的节点中，存储更多的key，提高查找效率。 影响MySQL查找性能的主要还是磁盘IO次数，大部分是磁头移动到指定磁道的时间花费。 MyISAM存储引擎下索引和数据存储是分离的，InnoDB索引和数据存储在一起。 InnoDB存储引擎下索引的实现，(辅助索引)全部是依赖于主索引建立的(辅助索引中叶子结点存储的并不是数据的地址，还是主索引的值，因此，所有依赖于辅助索引的都是先根据辅助索引查到主索引，再根据主索引查数据的地址)。 由于InnoDB索引的特性，因此如果主索引不是自增的(id作主键)，那么每次插入新的数据，都很可能对B+Tree的主索引进行重整，影响性能。因此，尽量以自增id作为InnoDB的主索引。 InnoDB一棵B+树能存多少行数据？为什么要用B+树？而不是其他树？InnoDB一棵B+树可以存放多少行数据？这个问题的简单回答是：约2千万。为什么是这么多呢？因为这是可以算出来的，要搞清楚这个问题，我们先从InnoDB索引数据结构、数据组织方式说起。 我们都知道计算机在存储数据的时候，有最小存储单元，这就好比我们今天进行现金的流通最小单位是一毛。在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是512字节，而文件系统（例如XFS/EXT4）他的最小单元是块，一个块的大小是4k，而对于我们的InnoDB存储引擎也有自己的最小储存单元——页（Page），一个页的大小是16K。 innodb的所有数据文件（后缀为ibd的文件），他的大小始终都是16384（16k）的整数倍。 磁盘扇区、文件系统、InnoDB存储引擎都有各自的最小存储单元。 在MySQL中我们的InnoDB页的大小默认是16k，当然也可以通过参数设置： 12345678mysql&gt; show variables like 'innodb_page_size';+------------------+-------+| Variable_name| Value|+------------------+-------+| innodb_page_size | 16384|+------------------+-------+1 row in set(0.00sec) 数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？假设一行数据的大小是1k，那么一个页可以存放16行这样的数据。 如果数据库只按这样的方式存储，那么如何查找数据就成为一个问题，因为我们不知道要查找的数据存在哪个页中，也不可能把所有的页遍历一遍，那样太慢了。所以人们想了一个办法，用B+树的方式组织这些数据。如图所示： 我们先将数据记录按主键进行排序，分别存放在不同的页中（为了便于理解我们这里一个页中只存放3条记录，实际情况可以存放很多），除了存放数据的页以外，还有存放键值+指针的页，如图中page number=3的页，该页存放键值和指向数据页的指针，这样的页由N个键值+指针组成。当然它也是排好序的。这样的数据组织形式，我们称为索引组织表。现在来看下，要查找一条数据，怎么查？ 如select * from user where id=5; 这里id是主键,我们通过这棵B+树来查找，首先找到根页，你怎么知道user表的根页在哪呢？其实每张表的根页位置在表空间文件中是固定的，即page number=3的页（这点我们下文还会进一步证明），找到根页后通过二分查找法，定位到id=5的数据应该在指针P5指向的页中，那么进一步去page number=5的页中查找，同样通过二分查询法即可找到id=5的记录： | 5 | zhao2 | 27 | 现在我们清楚了InnoDB中主键索引B+树是如何组织数据、查询数据的，我们总结一下： 1、InnoDB存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存放键值+指针，在B+树中叶子节点存放数据，非叶子节点存放键值+指针。 2、索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据； 那么回到我们开始的问题，通常一棵B+树可以存放多少行数据？这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。 上文我们已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右）。 那么现在我们需要计算出非叶子节点能存放多少指针？ 其实这也很好算，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170。那么可以算出一棵高度为2的B+树，能存放1170*16=18720条这样的数据记录。 根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170*1170*16=21902400条这样的记录。 所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。 怎么得到InnoDB主键索引B+树的高度？上面我们通过推断得出B+树的高度通常是1-3，下面我们从另外一个侧面证明这个结论。在InnoDB的表空间文件中，约定page number为3的代表主键索引的根页，而在根页偏移量为64的地方存放了该B+树的page level。如果page level为1，树高为2，page level为2，则树高为3。即B+树的高度=page level+1；下面我们将从实际环境中尝试找到这个page level。 在实际操作之前，你可以通过InnoDB元数据表确认主键索引根页的page number为3，你也可以从《InnoDB存储引擎》这本书中得到确认。 1234567SELECTb.name, a.name, index_id, type, a.space, a.PAGE_NOFROMinformation_schema.INNODB_SYS_INDEXES a,information_schema.INNODB_SYS_TABLES bWHEREa.table_id = b.table_id AND a.space &lt;&gt; 0; 执行结果： 可以看出数据库dbt3下的customer表、lineitem表主键索引根页的page number均为3，而其他的二级索引page number为4。关于二级索引与主键索引的区别请参考MySQL相关书籍，本文不在此介绍。 下面我们对数据库表空间文件做想相关的解析： 因为主键索引B+树的根页在整个表空间文件中的第3个页开始，所以可以算出它在文件中的偏移量：16384*3=49152（16384为页大小）。 另外根据《InnoDB存储引擎》中描述在根页的64偏移量位置前2个字节，保存了page level的值，因此我们想要的page level的值在整个文件中的偏移量为：16384*3+64=49152+64=49216，前2个字节中。 接下来我们用hexdump工具，查看表空间文件指定偏移量上的数据： linetem表的page level为2，B+树高度为page level+1=3；**region表的page level为0，B+树高度为page level+1=1；**customer表的page level为2，B+树高度为page level+1=3； 这三张表的数据量如下： 小结lineitem表的数据行数为600多万，B+树高度为3，customer表数据行数只有15万，B+树高度也为3。可以看出尽管数据量差异较大，这两个表树的高度都是3，换句话说这两个表通过索引查询效率并没有太大差异，因为都只需要做3次IO。那么如果有一张表行数是一千万，那么他的B+树高度依旧是3，查询效率仍然不会相差太大。 region表只有5行数据，当然他的B+树高度为1。 最后回顾一道面试题有一道MySQL的面试题，为什么MySQL的索引要使用B+树而不是其它树形结构？比如B树？ 现在这个问题的复杂版本可以参考本文； 他的简单版本回答是： 因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低； 总结本文从一个问题出发，逐步介绍了InnoDB索引组织表的原理、查询方式，并结合已有知识，回答该问题，结合实践来证明。当然为了表述简单易懂，文中忽略了一些细枝末节，比如一个页中不可能所有空间都用于存放数据，它还会存放一些少量的其他字段比如page level，index number等等，另外还有页的填充因子也导致一个页不可能全部用于保存数据。关于二级索引数据存取方式可以参考MySQL相关书籍，他的要点是结合主键索引进行回表查询。参考参考","link":"/MySQL/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%A7%A3%E6%9E%90.html"},{"title":"mysql允许最大sql语句长度配置","text":"MySQL对于每个客户端连接都会分配连接buffer和结果集发送的buffer，连接buffer主要就是来接受客户端发送过来的sql语句，并且初始分配大小都是 net_buffer_length，可以动态增长，最多可以达到 max_allow_packet大小。这个参数是会话只读的，言外之意就是只能全局修改，新建连接才生效。max_allow_packet是MySQL控制网络包大小的参数，默认是4M。有次可控制一条mysql查询语句大大小，实现mysql慢sql相关优化。 一、前言前几天在生产环境抓到一条慢SQL，内容大致如下： 1select xxx from table where conditions and id in (in_list); 这个SQL看起来貌似没有什么问题，但是 in_list的元素个数多达3000多个，然后我尝试统计了这个表的总数据量，刚好跟这个 in_list吻合，用大腿猜了下，应该是用了框架，先查出表里所有的数据放入list，再进行拼接生成的SQL，这尼玛不是蠢么。 二、问题抛开这个蠢不蠢的问题，我比较关心的是在MySQL里面，这个 in_list的元素个数能不能控制。咨询了下叶师傅，加上自己搜索了一圈文档，很遗憾，MySQL没法限制这个 in_list的元素个数。那么既然没法控制 in_list，那我们是不是可以控制sql语句的长度呢？ net_buffer_length MySQL有一个参数叫做 net_buffer_length，它是做什么用的呢？ 1Each client thread is associated with a connection buffer and result buffer. Both begin with a size given by net_buffer_length but are dynamically enlarged up to max_allowed_packet bytes as needed. The result buffer shrinks to net_buffer_length after each SQL statement.This variable should not normally be changed, but if you have very little memory, you can set it to the expected length of statements sent by clients. If statements exceed this length, the connection buffer is automatically enlarged. The maximum value to which net_buffer_length can be set is 1MB.The session value of this variable is read only. 简单翻译一下的意思就是，MySQL对于每个客户端连接都会分配连接buffer和结果集发送的buffer，连接buffer主要就是来接受客户端发送过来的sql语句，并且初始分配大小都是 net_buffer_length，可以动态增长，最多可以达到 max_allow_packet大小。这个参数是会话只读的，言外之意就是只能全局修改，新建连接才生效。max_allow_packet是MySQL控制网络包大小的参数，默认是4M。 三、测试既然是这样的话，我们就来测试一把，下面是我的测试过程。 参数设置 1234567891011121314root@mysqldb 16:58: [(none)]&gt; show global variables like 'net_buffer_length';+-------------------+-------+| Variable_name | Value |+-------------------+-------+| net_buffer_length | 16384 |+-------------------+-------+1 row in set (0.00 sec)root@mysqldb 17:00: [(none)]&gt; show global variables like 'max_allowed_packet';+--------------------+--------+| Variable_name | Value |+--------------------+--------+| max_allowed_packet | 131072 |+--------------------+--------+ 这里我设置 net_buffer_length为16K， max_allowed_packet为128K 测试脚本 1234567891011121314151617181920212223242526272829#!/bin/env python#coding:utf-8import pymysqldef get_in_list(i): in_list = '' for i in range(1,i): in_list = str(i) + ',' + in_list in_list = in_list + str(i+1) return in_listdef exec_mysql(sql): conn = pymysql.connect(host='127.0.0.1', user='xucl', password='xuclxucl123', database='sbtest', charset='utf8') cursor = conn.cursor() cursor.execute(sql) results = cursor.fetchall() if results: print(&quot;get results&quot;) conn.close()if __name__ == &quot;__main__&quot;: in_list = get_in_list(100) sql = &quot;select * from sbtest1 where id in ({})&quot;.format(in_list) # 打印出sql占用的字节数 print(len(in_list.encode())) exec_mysql(sql) 测试结果 当i为4200时，sql大小为19892字节（大于 net_buffer_length），MySQL能正常返回数据，结果如下 1[root@izbp13wpxafsmeraypddyvz python_scripts]# python test.py 19892get results 当i为23690时，sql大小为131033字节（小于 max_allowed_packet），也能正常输出，结果如下，此时sql的字节数为131033 1[root@izbp13wpxafsmeraypddyvz python_scripts]# python test.py 131033get results 当i为23691时，sql大小为131039字节（仍然小于 max_allowed_packet），抛出异常 123456789101112131415161718192021222324[root@izbp13wpxafsmeraypddyvz python_scripts]# python test.py 131039Traceback (most recent call last): File &quot;test.py&quot;, line 29, in &lt;module&gt; exec_mysql(sql) File &quot;test.py&quot;, line 19, in exec_mysql cursor.execute(sql) File &quot;/usr/lib64/python2.7/site-packages/pymysql/cursors.py&quot;, line 170, in execute result = self._query(query) File &quot;/usr/lib64/python2.7/site-packages/pymysql/cursors.py&quot;, line 328, in _query conn.query(q) File &quot;/usr/lib64/python2.7/site-packages/pymysql/connections.py&quot;, line 517, in query self._affected_rows = self._read_query_result(unbuffered=unbuffered) File &quot;/usr/lib64/python2.7/site-packages/pymysql/connections.py&quot;, line 732, in _read_query_result result.read() File &quot;/usr/lib64/python2.7/site-packages/pymysql/connections.py&quot;, line 1075, in read first_packet = self.connection._read_packet() File &quot;/usr/lib64/python2.7/site-packages/pymysql/connections.py&quot;, line 684, in _read_packet packet.check_error() File &quot;/usr/lib64/python2.7/site-packages/pymysql/protocol.py&quot;, line 220, in check_error err.raise_mysql_exception(self._data) File &quot;/usr/lib64/python2.7/site-packages/pymysql/err.py&quot;, line 109, in raise_mysql_exception raise errorclass(errno, errval)pymysql.err.InternalError: (1153, u&quot;Got a packet bigger than 'max_allowed_packet' bytes&quot;) MySQL错误日志如下： 12020-03-10T09:07:46.992043Z 32 [Note] Aborted connection 32 to db: 'sbtest' user: 'xucl' host: '127.0.0.1' (Got a packet bigger than 'max_allowed_packet' bytes) 释惑 为什么sql字节数为131039&lt;131072（ max_allowed_packet大小），MySQL还是报错了呢？因为这里还需要加上MySQL的包头大小，这个包头的大小是多少呢？还是用i=23690的例子，在MySQL服务器上抓包 看到MySQL接收到的包大小是131070字节，那么这个包头大小就为37字节了（未深入研究，留到以后研究），而上述实验中i=23691的例子中，sql大小为131039字节，加上包头的大小37字节，总大小为131076字节，大于 max_allowed_packet的131072，所以MySQL报错，符合逻辑。 四、结论经过这次测试，得出了以下节点结论 虽然MySQL没有限制子查询内元素个数，但是还是不建议元素太多，会影响执行计划同时也会影响SQL解析的效率和内存占用 适当调大 net_buffer_length，最好能够一次性缓存sql，无需再分配内存，并且这是一个全局性参数 适当调大 max_allowed_packet大小，但是也不要分配过大，这是一个会话级变量，生产建议调为32M为佳 学会利用抓包解决”网络”相关的问题 参考文章:参考链接","link":"/MySQL/mysql%E5%85%81%E8%AE%B8%E6%9C%80%E5%A4%A7sql%E8%AF%AD%E5%8F%A5%E9%95%BF%E5%BA%A6%E9%85%8D%E7%BD%AE.html"},{"title":"mysql索引优化方案","text":"摘要mysql自带优化：先执行explain sql，在执行explain extended sql，得到优化结果，show warnings显示优化后的结果sql. 索引基数基数是数据列所包含的不同值的数量，例如，某个数据列包含值 1、3、7、4、7、3，那么它的基数就是 4。索引的基数相对于数据表行数较高（也就是说，列中包含很多不同的值，重复的值很少）的时候，它的工作效果最好。如果某数据列含有很多不同的年龄，索引会很快地分辨数据行；如果某个数据列用于记录性别（只有“M”和“F”两种值），那么索引的用处就不大；如果值出现的几率几乎相等，那么无论搜索哪个值都可能得到一半的数据行。在这些情况下，最好根本不要使用索引，因为查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。惯用的百分比界线是“30%”。 索引失效原因索引失效的原因有如下几点： 对索引列运算，运算包括（+、-、*、/、！、&lt;&gt;、%、like’%_’（% 放在前面）。 类型错误，如字段类型为 varchar，where 条件用 number。 对索引应用内部函数，这种情况下应该要建立基于函数的索引。例如 select * from template t where ROUND (t.logicdb_id) = 1，此时应该建 ROUND (t.logicdb_id) 为索引。 MySQL 8.0 开始支持函数索引，5.7 可以通过虚拟列的方式来支持，之前只能新建一个 ROUND (t.logicdb_id) 列然后去维护。 如果条件有 or，即使其中有条件带索引也不会使用（这也是为什么建议少使用 or 的原因），如果想使用 or，又想索引有效，只能将 or 条件中的每个列加上索引。 如果列类型是字符串，那一定要在条件中数据使用引号，否则不使用索引。 B-tree 索引 is null 不会走，is not null 会走，位图索引 is null，is not null 都会走。 组合索引遵循最左原则。 索引的建立索引的建立需要注意以下几点： 最重要的肯定是根据业务经常查询的语句。 尽量选择区分度高的列作为索引，区分度的公式是$$COUNT(DISTINCT空格col) / COUNT(*):表示字段不重复的比率，比率越大我们扫描的记录数就越少。$$ 如果业务中唯一特性最好建立唯一键，一方面可以保证数据的正确性，另一方面索引的效率能大大提高。 EXPLIAN 中有用的信息EXPLIAN 基本用法如下： desc 或者 explain 加上你的 SQL。 explain extended 加上你的 SQL，然后通过 show warnings 可以查看实际执行的语句，这一点也是非常有用的，很多时候不同的写法经 SQL 分析后，实际执行的代码是一样的。 提高性能的特性EXPLIAN 提高性能的特性如下： 索引覆盖(covering index)：需要查询的数据在索引上都可以查到不需要回表 EXTRA 列显示 using index。 ICP特性(Index Condition Pushdown)：本来 index 仅仅是 data access 的一种访问模式，存数引擎通过索引回表获取的数据会传递到 MySQL Server 层进行 where 条件过滤。 5.6 版本开始当 ICP 打开时，如果部分 where 条件能使用索引的字段，MySQL Server 会把这部分下推到引擎层，可以利用 index 过滤的 where 条件在存储引擎层进行数据过滤。 EXTRA 显示 using index condition。需要了解 MySQL 的架构图分为 Server 和存储引擎层。 索引合并(index merge)：对多个索引分别进行条件扫描，然后将它们各自的结果进行合并(intersect/union)。 一般用 or 会用到，如果是 AND 条件，考虑建立复合索引。EXPLAIN 显示的索引类型会显示 index_merge，EXTRA 会显示具体的合并算法和用到的索引。 Extra字段Extra 字段使用： using filesort：说明 MySQL 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。 MySQL 中无法利用索引完成的排序操作称为“文件排序”，其实不一定是文件排序，内部使用的是快排。 using temporary：使用了临时表保存中间结果，MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。 using index：表示相应的 SELECT 操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错。 impossible where：where 子句的值总是 false，不能用来获取任何元组。 select tables optimized away：在没有 group by 子句的情况下基于索引优化 MIN/MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*) 操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。 distinct：优化 distinct 操作，在找到第一匹配的元组后即停止找同样值的操作。 using filesort、using temporary 这两项出现时需要注意下，这两项是十分耗费性能的 在使用 group by 的时候，虽然没有使用 order by，如果没有索引，是可能同时出现 using filesort，using temporary 的。因为 group by 就是先排序在分组，如果没有排序的需要，可以加上一个 order by NULL 来避免排序，这样 using filesort 就会去除，能提升一点性能。 type字段 system：表只有一行记录（等于系统表），这是 const 类型的特例，平时不会出现。 const：如果通过索引依次就找到了，const 用于比较主键索引或者 unique 索引。因为只能匹配一行数据，所以很快。如果将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量。 eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。 ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。 range：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的 where 语句中出现 between、&lt;、&gt;、in 等的查询。 这种范围扫描索引比全表扫描要好，因为只需要开始于缩印的某一点，而结束于另一点，不用扫描全部索引。 index：Full Index Scan ，index 与 ALL 的区别为 index 类型只遍历索引树，这通常比 ALL 快，因为索引文件通常比数据文件小。 也就是说虽然 ALL 和 index 都是读全表，但 index 是从索引中读取的，而 ALL 是从硬盘读取的。 all：Full Table Scan，遍历全表获得匹配的行。 字段类型和编码 MySQL 返回字符串长度 CHARACTER_LENGTH(同CHAR_LENGTH)方法返回的是字符数，LENGTH 函数返回的是字节数，一个汉字三个字节。 varchar 等字段建立索引长度计算语句 select count(distinct left(test,5))/count(*) from table；越趋近 1 越好。 MySQL 的 utf8 MySQL 的 utf8 最大是 3 个字节不支持 emoji 表情符号，必须只用 utf8mb4。需要在 MySQL 配置文件中配置客户端字符集为 utf8mb4。 JDBC 的连接串不支持配置 characterEncoding=utf8mb4，最好的办法是在连接池中指定初始化 SQL。例如：hikari 连接池，其他连接池类似 spring . datasource . hikari . connection - init - sql =set names utf8mb4。否则需要每次执行 SQL 前都先执行 set names utf8mb4。 MySQL 排序规则一般使用 _bin 和 _genera_ci： utf8_genera_ci 不区分大小写，ci 为 case insensitive 的缩写，即大小写不敏感。 utf8_general_cs 区分大小写，cs 为 case sensitive 的缩写，即大小写敏感，但是目前 MySQL 版本中已经不支持类似于 _genera_cs 的排序规则，直接使用 utf8_bin 替代。 utf8_bin 将字符串中的每一个字符用二进制数据存储，区分大小写。 那么，同样是区分大小写，utf8_general_cs 和 utf8_bin 有什么区别？ cs 为 case sensitive 的缩写，即大小写敏感；bin 的意思是二进制，也就是二进制编码比较。 utf8_general_cs 排序规则下，即便是区分了大小写，但是某些西欧的字符和拉丁字符是不区分的，比如 ä=a，但是有时并不需要 ä=a，所以才有 utf8_bin。 utf8_bin 的特点在于使用字符的二进制的编码进行运算，任何不同的二进制编码都是不同的，因此在 utf8_bin 排序规则下：ä&lt;&gt;a。 SQL语句总结常用但容易忘的 如果有主键或者唯一键冲突则不插入：insert ignore into。 如果有主键或者唯一键冲突则更新，注意这个会影响自增的增量：INSERT INTO room_remarks(room_id,room_remarks)VALUE(1,”sdf”) ON DUPLICATE KEY UPDATE room_remarks = “234”。 如果有就用新的替代，values 如果不包含自增列，自增列的值会变化：REPLACE INTO room_remarks(room_id,room_remarks) VALUE(1,”sdf”)。 备份表：CREATE TABLE user_info SELECT * FROM user_info。 复制表结构：CREATE TABLE user_v2 LIKE user。 从查询语句中导入：INSERT INTO user_v2 SELECT * FROM user 或者 INSERT INTO user_v2(id,num) SELECT id,num FROM user。 连表更新：UPDATE user a, room b SET a.num=a.num+1 WHERE a.room_id=b.id。 连表删除：DELETE user FROM user,black WHERE user.id=black.id。 锁相关锁相关(作为了解，很少用)： 共享锁：select id from tb_test where id = 1 lock in share mode。 排它锁：select id from tb_test where id = 1 for update。 优化时用到 强制使用某个索引：select * from table force index(idx_user) limit 2。 禁止使用某个索引：select * from table ignore index(idx_user) limit 2。 禁用缓存(在测试时去除缓存的影响)：select SQL_NO_CACHE from table limit 2。 查看状态 查看字符集：SHOW VARIABLES LIKE ‘character_set%’。 查看排序规则：SHOW VARIABLES LIKE ‘collation%’。 SQL编写注意 where 语句的解析顺序是从右到左，条件尽量放 where 不要放 having。 采用延迟关联(deferred join)技术优化超多分页场景，比如 limit 10000,10,延迟关联可以避免回表。 distinct 语句非常损耗性能，可以通过 group by 来优化。 连表尽量不要超过三个表。 踩坑 如果有自增列，truncate 语句会把自增列的基数重置为 0，有些场景用自增列作为业务上的 ID 需要十分重视。 聚合函数会自动滤空，比如 a 列的类型是 int 且全部是 NULL，则 SUM(a) 返回的是 NULL 而不是 0。 MySQL 判断 null 相等不能用 “a=null”，这个结果永远为 UnKnown，where 和 having 中，UnKnown 永远被视为 false，check 约束中，UnKnown 就会视为 true 来处理。所以要用“a is null”处理。 千万大表在线修改MySQL 在表数据量很大的时候，如果修改表结构会导致锁表，业务请求被阻塞。MySQL 在 5.6 之后引入了在线更新，但是在某些情况下还是会锁表，所以一般都采用 PT 工具( Percona Toolkit)。如对表添加索引： 1234pt-online-schema-change --user='root' --host='localhost' --ask-pass --alter &quot;add index idx_user_id(room_id,create_time)&quot; D=fission_show_room_v2,t=room_favorite_info --execute 慢查询日志 有时候如果线上请求超时，应该去关注下慢查询日志，慢查询的分析很简单，先找到慢查询日志文件的位置，然后利用 mysqldumpslow 去分析。 查询慢查询日志信息可以直接通过执行 SQL 命令查看相关变量，常用的 SQL 如下： mysqldumpslow 的工具十分简单，我主要用到的参数如下： -t：限制输出的行数，我一般取前十条就够了。 -s：根据什么来排序默认是平均查询时间 at，我还经常用到 c 查询次数，因为查询次数很频繁但是时间不高也是有必要优化的，还有 t 查询时间，查看那个语句特别卡。 -v：输出详细信息。 例子：mysqldumpslow -v -s t -t 10 mysql_slow.log.2018-11-20-0500。 一些数据库性能的思考 在对公司慢查询日志做优化的时候，很多时候可能是忘了建索引，像这种问题很容易解决，加个索引就行了。但是有几种情况就不是简单加索引能解决了 业务代码循环读数据库 ​ 考虑这样一个场景，获取用户粉丝列表信息，加入分页是十个，其实像这样的 SQL 是十分简单的，通过连表查询性能也很高。 ​ 但是有时候，很多开发采用了取出一串 ID，然后循环读每个 ID 的信息，这样如果 ID 很多对数据库的压力是很大的，而且性能也很低。 统计 SQL ​ 很多时候，业务上都会有排行榜这种，发现公司有很多地方直接采用数据库做计算，在对一些大表做聚合运算的时候，经常超过五秒，这些 SQL 一般很长而且很难优化。像这种场景，如果业务允许（比如一致性要求不高或者是隔一段时间才统计的），可以专门在从库里面做统计。另外我建议还是采用 Redis 缓存来处理这种业务。 超大分页 ​ 在慢查询日志中发现了一些超大分页的慢查询如 Limit 40000，1000，因为 MySQL 的分页是在 Server 层做的，可以采用延迟关联在减少回表。但是看了相关的业务代码正常的业务逻辑是不会出现这样的请求的，所以很有可能是有恶意用户在刷接口，最好在开发的时候也对接口加上校验拦截这些恶意请求。","link":"/MySQL/mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88.html"},{"title":"英语语法-动词不定式","text":"做主语：It + to do sth 句型1. It + to do sth句型；it做形式主语​ a. It is easier to spend money than to make money. ​ b. It takes time to study English well. ​ 形式主语it不能用this或that替换 ​ This is impossible for people to stare directly at the sun.应用it 2. 不定式置于句首做主语，谓语动词要用单数。​ a. To err is human; to forgive, divine ​ b. To solve this problem takes a genius like Einstein. ​ c. To love for the sake of being loved is human, but to love for the sake of loving is angelic. ​ d. To send a letter is a good way to go somewhere without moving anything but your heart. 做宾语：动词 + to do1. 直接跟在一个及物动词后面做宾语​ 特点一：句子的主语和不定式的逻辑主语是一致的，动作都是由主语发出。 ​ 特点二：这时句子谓语动词多是描写态度；不定式动作则说明行为。 ​ a. I hope to see you again. ​ b. This company refused to cooperate with us. ​ c. He promised not to tell anyone about it. ​ 接不定式做宾语的动词有 ​ agree, appear, beg, begin, dare, decide, expect, fail, forget, happen, hate, hesitate ​ hope, intend, like, love, manage, mean, prefer, prepare, pretend, promise, propose ​ refuse, regret, remember, seem, start, swear, try, want, wish 2. 连接词引导宾语从句的简略形式：动词 + 连接代词or连接副词or连词whether + to do​ a. I wonder who to invite. (= who I should invite) ​ b. Show us what to do. (= what we must do) ​ c. I don’t know whether to answer his letter. (= whether I should answer) ​ 类似动词还有：ask, consider, decide, discover, explain, forget, find out, guess, imagine, ​ know, learn, observe, remember, see, tell, teach, think, understand, wonder 做宾语补足语：动词 + sb to do sth1. 通常结构：动词 + sb to do sth​ a. They don’t allow people to smoke in the theater. ​ b. The chairman declared the meeting to be over. ​ c. Allow me to drink to your success. ​ d. Allow me to propose a toast to our friendship. ​ f. My mother wishes me to return to China. ​ 常用动词：advise, allow, ask, beg, cause, encourage, expect, forbid, force, get, help, like ​ order, permit, persuade, remind, teach, tell, want, warn, wish(hope不可) 2. 在let, make, have, see, hear, feel, watch, notice, listen to等动词后面，不定式做宾语补足语to要省略，改为被动语态，则必须带to(详见“不带to的不定式”)做定语：名词 + to do sth1. 动宾关系​ 被修饰名词在逻辑上做不定式的宾语 ​ a. She has four children to take care of. ​ b. I had no place to live in. ​ c. You just regard me as a thing, an object to look at, to use, to touch, but not to listen to or to take seriously. ​ d. I gave the kid a comic to read. ​ e. He needs a place to live in. ​ f. I have no partner to speak English with. ​ g. I need a pen to write with. ​ h. I need a piiece of paper to write on. ​ 注意： ​ 1. 不定式一般不用被动形式 ​ 2. 不定式动词后面不能再加宾语 ​ a. I gave the kid a comic to read it. * ​ b. I need something to eat it. * ​ 3. 不定式动词后介词不省略 ​ a. I have no partner to speak English. * ​ b. I need a pen to write. * 2. 被only, last, next, 序数词, 最高级修饰的名词通常用不定式做定语​ a. I don’t think he is the best man to do the job. ​ b. The next train to arrive is from New York. ​ c. Clint was the second person to fall into this trap. ​ d. Clint was the only person to survive the air crash. 做独立成分 修饰整个句子： to begin with, to tell the truth, to make a long story short, so to speak, to be brief/exaact/frank/honest, to say nothing of(姑且不所说), to say the least(至少可以这么说) a. To begin with, on behalf of (代表)all of your American guests, I wish to thank you for the incomparable hospitality. b. I have a point there, to say the least. c. To make a long story short, he is in hospital now. 做状语：目的在状语 and 结果状语1.做目的状语 a. Hating people is like burning down your own house to get rid of a rat. b. To avoid criticsim, do nothing, say nothing, be nothing. c. To acquire knowledge, one must study; but to acquire wisdom, one must observe. d. We had better start early to catch the train. e. I went to the post office to mail a letter. 可以用in order to do 或 so as to do 强调目的状语 ​ a. We had better start early so as to catch the train. ​ b. I went to the post office in order to mail a letter. ​ c. I quote others in order to better express my own self. ​ d. The teacher raised her voice in order for us to hear more clearly. ​ 注意：so as to不放在句首；to do和in order to do可以放句首。 2.做结果状语 1. 直接做结果状语 ​ a. He lived to be a hundred years. ​ b. What have I done to offend you? ​ c. He lived to see second world war.(= he lived until he saw world war II) 2. never to do表结果 ​ a. John left his hometown ten years ago, never to return. ​ b. We parted never to see each other. 3. only to do引出意想不到或不愉快的结果 ​ a. We hurried to the railway station, only to find the train had just left. ​ b. All too often, women complain that they’re educated as equals, only to go out into the workforce to be treated as inferiors. ​ c. He worked very hard, only to find he had not finished half of the job. 4. enough to ​ a. He is not old enough to go to school. ​ b. The teacher speaks loudly enough to make himself heard clearly. 5. too…to结构：太…而不能 ​ a. The box is too heavy for me to even move. ​ b. The tea is too hot to drink. 形容词后的不定式1. 句子主语和不定式可以构成逻辑上的主谓关系 这类形容词通常表示人的性格特征或行为表现 brave, careful, careless, clever, considerate, cruel, foolish, generous, kind, modest, nice polite, rude, selfish, silly, stupid, thoughtful. ​ a. He was surprised to learn how much he had spent. ​ b. The boy was careless to break the window. 2. 句子主语和不定式构成逻辑上的动宾关系 a. She is interesting to listen to = It is interesting to listen to her. b. Relativity theory isn’t easy to understand = it isn’t easy to understand relativity theory. c. She is very nice to talk to = It is very nice to talk to her. d. Mary is easy to get on with = It is easy to get on with Mary. e. English is difficult to speak. f. Football is very interesting to watch. g. Barbara is interesting to listen to because she reads a lot. 在动宾关系的情况需要注意：​ 1)不定式动词不用被动式(最容易出错) ​ a. English is difficult to be spoken ​ b. Football is interesting to be watched ​ 2)不定式后不加宾语 ​ a. Football is very interesting to watch it ​ b. She is nice to talk to her ​ 3)不定式动词所带介词不能省略 ​ a. She is interesting to listen ​ b. She is easy to get on ● It’s impossble for fish to live without water. ● it’s necessary for students to do more exercise in learning English. ● The boy was made to sing the song once again. ● He couldn’t help bursting into tears after he heard the news. ● She could not but admit that they were justified in this ● They forbade him to go to the park ● The first explorer to reach California by land was Strong Smith, a trapper who crossed the southwestern deserts of the United States in 1826 ● He was the first to arrive and the last to leave ● The teachers don’t know what it takes to start and run a school. 不带to的不定式动词的复合宾语中to省去 1. 感觉动词：see, hear, watch, notice, feel, observe 2. 使役动词：let, make, have ​ a. The teacher has us write a composition every week. ​ b. I saw a man enter the shop. ​ 但为被动结构时，后面需要 + to ​ a. A man was seen to enter the shop. 一些短语中to省略 had better, would rather, would sooner, would just a soon, might(just) as well, cannot but cannot choose but, cannot help but ​ a. I cannot but admire his courage. ​ b. We might as well put up here for tonight. ​ c. I couldn’t help but fall in love with you. do nothing/anything/everything but do省略 a. I have nothing to do but wait. b. I have no choice but to wait(but前没有do，则不定式 + to) c. He needs nothing but to succeed. d. He will do anything but give in 在解释do的精确含义的名词从句和定语从句做主语的句子中，be动词后直接 + do e. All that I could do then was wait. f. What I could do then was wait. g. All you do now is complete this form. h. No mountains too high for you to climb. All you have to do is have some climbing faith. g. No rivers too wide for you to make it across. All you have to do is believe it when you pray. 英语学习-语法系列github仓库，欢迎收藏star ​参考文章: 参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%8A%A8%E8%AF%8D%E4%B8%8D%E5%AE%9A%E5%BC%8F.html"},{"title":"","text":"Editor DebugGame","link":"/UnrealEngine/C++/FindObjectReferencers.html"},{"title":"二分查找法模板的基本思想-leetcode35","text":"leetcode35给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 123456789101112131415输入: [1,3,5,6], 5输出: 2示例 2:输入: [1,3,5,6], 2输出: 1示例 3:输入: [1,3,5,6], 7输出: 4示例 4:输入: [1,3,5,6], 0输出: 0 传统解法： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution3 { public int searchInsert(int[] nums, int target) { int len = nums.length; if (nums[len - 1] &lt; target) { return len; } int left = 0; int right = len - 1; while (left &lt;= right) { int mid = (left + right) / 2; // 等于的情况最简单，我们应该放在第 1 个分支进行判断 if (nums[mid] == target) { return mid; } else if (nums[mid] &lt; target) { // 题目要我们返回大于或者等于目标值的第 1 个数的索引 // 此时 mid 一定不是所求的左边界， // 此时左边界更新为 mid + 1 left = mid + 1; } else { // 既然不会等于，此时 nums[mid] &gt; target // mid 也一定不是所求的右边界 // 此时右边界更新为 mid - 1 right = mid - 1; } } // 注意：一定得返回左边界 left， // 如果返回右边界 right 提交代码不会通过 // 【注意】下面我尝试说明一下理由，如果你不太理解下面我说的，那是我表达的问题 // 但我建议你不要纠结这个问题，因为我将要介绍的二分查找法模板，可以避免对返回 left 和 right 的讨论 // 理由是对于 [1,3,5,6]，target = 2，返回大于等于 target 的第 1 个数的索引，此时应该返回 1 // 在上面的 while (left &lt;= right) 退出循环以后，right &lt; left，right = 0 ，left = 1 // 根据题意应该返回 left， // 如果题目要求你返回小于等于 target 的所有数里最大的那个索引值，应该返回 right return left; }} 说明 a、当把二分查找法的循环可以进行的条件写成 while (left &lt;= right) 时，在写最后一句 return 的时候，如果不假思索，把左边界 left 返回回去，虽然写对了，但可以思考一下为什么不返回右边界 right 呢？ b、但是事实上，返回 left 是有一定道理的，如果题目换一种问法，你可能就要返回右边界 right，这句话不太理解没有关系，我也不打算讲得很清楚（在上面代码的注释中我已经解释了原因），因为实在太绕了，这不是我要说的重点。 二分查找法模板的基本思想1、首先把循环可以进行的条件写成 while(left &lt; right)，在退出循环的时候，一定有 left == right 成立，此时返回 left 或者 right 都可以或许你会问：退出循环的时候还有一个数没有看啊（退出循环之前索引 left 或 索引 right 上的值）？没有关系，我们就等到退出循环以后来看，甚至经过分析，有时都不用看，就能确定它是目标数值。 （什么时候需要看最后剩下的那个数，什么时候不需要，会在后面介绍。） 更深层次的思想是“夹逼法”或者称为“排除法”。 2、“神奇的”二分查找法模板的基本思想（特别重要）“排除法”即：在每一轮循环中排除一半以上的元素，于是在对数级别的时间复杂度内，就可以把区间“夹逼” 只剩下 1 个数，而这个数是不是我们要找的数，单独做一次判断就可以了。 “夹逼法”或者“排除法”是二分查找算法的基本思想，“二分”是手段，在目标元素不确定的情况下，“二分” 也是“最大熵原理”告诉我们的选择。 还是 LeetCode 第 35 题，下面给出使用 while (left &lt; right) 模板写法的 2 段参考代码，以下代码的细节部分在后文中会讲到，因此一些地方不太明白没有关系，暂时跳过即可。 参考代码 1：重点理解为什么候选区间的索引范围是 [0, size]。 12345678910111213141516171819202122232425262728from typing import Listclass Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: # 返回大于等于 target 的索引，有可能是最后一个 size = len(nums) # 特判 if size == 0: return 0 left = 0 # 如果 target 比 nums里所有的数都大，则最后一个数的索引 + 1 就是候选值，因此，右边界应该是数组的长度 right = size # 二分的逻辑一定要写对，否则会出现死循环或者数组下标越界 while left &lt; right: mid = left + (right - left) // 2 if nums[mid] &lt; target: left = mid + 1 else: assert nums[mid] &gt;= target # [1,5,7] 2 right = mid # 调试语句 # print('left = {}, right = {}, mid = {}'.format(left, right, mid)) return left 参考代码 2：对于是否接在原有序数组后面单独判断，不满足的时候，再在候选区间的索引范围 [0, size - 1] 内使用二分查找法进行搜索。 1234567891011121314151617181920212223242526from typing import Listclass Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: # 返回大于等于 target 的索引，有可能是最后一个 size = len(nums) # 特判 1 if size == 0: return 0 # 特判 2：如果比最后一个数字还要大，直接接在它后面就可以了 if target &gt; nums[-1]: return size left = 0 right = size - 1 # 二分的逻辑一定要写对，否则会出现死循环或者数组下标越界 while left &lt; right: mid = left + (right - left) // 2 if nums[mid] &lt; target: left = mid + 1 else: assert nums[mid] &gt;= target right = mid return left 细节、注意事项、调试方法1、前提：思考左、右边界，如果左、右边界不包括目标数值，会导致错误结果例：LeetCode 第 69 题：x 的平方根 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 分析：一个非负整数的平方根最小可能是 0 ，最大可能是它自己。因此左边界可以取 0 ，右边界可以取 x。可以分析得再细一点，但这道题没有必要，因为二分查找法会帮你排除掉不符合的区间元素。 例：LeetCode 第 287 题：寻找重复数 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 分析：题目告诉我们“其数字都在 1 到 n 之间（包括 1 和 n）”。因此左边界可以取 1 ，右边界可以取 n。 要注意 2 点： 如果 left 和 right 表示的是数组的索引，就要考虑“索引是否有效” ，即“索引是否越界” 是重要的定界依据； 左右边界一定要包括目标元素，例如 LeetCode 第 35 题：“搜索插入位置” ，当 target 比数组中的最后一个数字还要大（不能等于）的时候，插入元素的位置就是数组的最后一个位置 + 1，即 (len - 1 + 1 =) len，如果忽略掉这一点，把右边界定为 len - 1 ，代码就不能通过在线测评。 2、中位数先写 int mid = (left + right) &gt;&gt;&gt; 1 ; 根据循环里分支的编写情况，再做调整理解这一点，首先要知道：当数组的元素个数是偶数的时候，中位数有左中位数和右中位数之分。 当数组的元素个数是偶数的时候：使用 int mid = left + (right - left) / 2 ; 得到左中位数的索引； 使用 int mid = left + (right - left + 1) / 2 ; 得到右中位数的索引。 当数组的元素个数是奇数的时候，以上二者都能选到最中间的那个中位数。其次， int mid = left + (right - left) / 2 ; 等价于 int mid = (left + right) &gt;&gt;&gt; 1； int mid = left + (right - left + 1) / 2 ; 等价于 int mid = (left + right + 1) &gt;&gt;&gt; 1 。 我们使用一个具体的例子来验证：当左边界索引 left = 3，右边界索引 right = 4 的时候， mid1 = left + (right - left) // 2 = 3 + (4 - 3) // 2 = 3 + 0 = 3， mid2 = left + (right - left + 1) // 2 = 3 + (4 - 3 + 1) // 2 = 3 + 1 = 4。 左中位数 mid1 是索引 left，右中位数 mid2 是索引 right。 记忆方法： (right - left) 不加 11 选左中位数，加 11 选右中位数。 那么，什么时候使用左中位数，什么时候使用右中位数呢？选中位数的依据是为了避免死循环，得根据分支的逻辑来选择中位数，而分支逻辑的编写也有技巧，下面具体说。 3、先写逻辑上容易想到的分支逻辑，这个分支逻辑通常是排除中位数的逻辑；在逻辑上，“可能是也有可能不是”让我们感到犹豫不定，但**“一定不是”是我们非常坚决的，通常考虑的因素特别单一，因此“好想” **。在生活中，我们经常听到这样的话：找对象时，“有车、有房，可以考虑，但没有一定不要”；找工作时，“事儿少、离家近可以考虑，但是钱少一定不去”，就是这种思想的体现。 例：LeetCode 第 69 题：x 的平方根 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 分析：因为题目中说“返回类型是整数，结果只保留整数的部分，小数部分将被舍去”。例如 55 的平方根约等于 2.2362.236，在这道题应该返回 22。因此如果一个数的平方小于或者等于 x，那么这个数有可能是也有可能不是 x 的平方根，但是能很肯定的是，如果一个数的平方大于 x ，这个数肯定不是 x 的平方根。 注意：先写“好想”的分支，排除了中位数之后，通常另一个分支就不排除中位数，而不必具体考虑另一个分支的逻辑的具体意义，且代码几乎是固定的。 4、循环内只写两个分支，一个分支排除中位数，另一个分支不排除中位数，循环中不单独对中位数作判断既然是“夹逼”法，没有必要在每一轮循环开始前单独判断当前中位数是否是目标元素，因此分支数少了一支，代码执行效率更高。 以下是“排除中位数的逻辑”思考清楚以后，可能出现的两个模板代码。 可以排除“中位数”的逻辑，通常比较好想，但并不绝对，这一点视情况而定。 分支条数变成 2 条，比原来 3 个分支要考虑的情况少，好处是： 不用在每次循环开始单独考虑中位数是否是目标元素，节约了时间，我们只要在退出循环的时候，即左右区间压缩成一个数（索引）的时候，去判断这个索引表示的数是否是目标元素，而不必在二分的逻辑中单独做判断。 这一点很重要，希望读者结合具体练习仔细体会，每次循环开始的时候都单独做一次判断，在统计意义上看，二分时候的中位数恰好是目标元素的概率并不高，并且即使要这么做，也不是普适性的，不能解决绝大部分的问题。 还以 LeetCode 第 35 题为例，通过之前的分析，我们需要找到“大于或者等于目标值的第 1 个数的索引”。对于这道题而言： 如果中位数小于目标值，它就应该被排除，左边界 left 就至少是 mid + 1； 如果中位数大于等于目标值，还不能够肯定它就是我们要找的数，因为要找的是等于目标值的第 11 个数的索引，中位数以及中位数的左边都有可能是符合题意的数，因此右边界就不能把 mid 排除，因此右边界 right 至多是 mid，此时右边界不向左边收缩。 下一点就更关键了。 5、根据分支逻辑选择中位数的类型，可能是左中位数，也可能是右位数，选择的标准是避免死循环 死循环容易发生在区间只有 22 个元素时候，此时中位数的选择尤为关键。选择中位数的依据是：避免出现死循环。我们需要确保： （下面的这两条规则说起来很绕，可以暂时跳过）。 如果分支的逻辑，在选择左边界的时候，不能排除中位数，那么中位数就选“右中位数”，只有这样区间才会收缩，否则进入死循环； 同理，如果分支的逻辑，在选择右边界的时候，不能排除中位数，那么中位数就选“左中位数”，只有这样区间才会收缩，否则进入死循环。 理解上面的这个规则可以通过具体的例子。针对以上规则的第 1 点：如果分支的逻辑，在选择左边界的时候不能排除中位数，例如： 1234567891011while left &lt; right: # 不妨先写左中位数，看看你的分支会不会让你代码出现死循环，从而调整 mid = left + (right - left) // 2 # 业务逻辑代码 if (check(mid)): # 选择右边界的时候，可以排除中位数 right = mid - 1 else: # 选择左边界的时候，不能排除中位数 left = mid 在区间中的元素只剩下 22 个时候，例如：left = 3，right = 4。此时左中位数就是左边界，如果你的逻辑执行到 left = mid 这个分支，且你选择的中位数是左中位数，此时左边界就不会得到更新，区间就不会再收缩（理解这句话是关键），从而进入死循环；为了避免出现死循环，你需要选择中位数是右中位数，当逻辑执行到 left = mid 这个分支的时候，因为你选择了右中位数，让逻辑可以转而执行到 right = mid - 1 让区间收缩，最终成为 1 个数，退出 while 循环。上面这段话不理解没有关系，因为我还没有举例子，你有个印象就好，类似地，理解选择中位数的依据的第 2 点。 6、退出循环的时候，可能需要对“夹逼”剩下的那个数单独做一次判断，这一步称之为“后处理”。二分查找法之所以高效，是因为它利用了数组有序的特点，在每一次的搜索过程中，都可以排除将近一半的数，使得搜索区间越来越小，直到区间成为一个数。回到这一节最开始的疑问：“区间左右边界相等（即收缩成 1 个数）时，这个数是否会漏掉”，解释如下： 如果你的业务逻辑保证了你要找的数一定在左边界和右边界所表示的区间里出现，那么可以放心地返回 left 或者 right，无需再做判断； 如果你的业务逻辑不能保证你要找的数一定在左边界和右边界所表示的区间里出现，那么只要在退出循环以后，再针对 nums[left] 或者 nums[right] （此时 nums[left] == nums[right]）单独作一次判断，看它是不是你要找的数即可，这一步操作常常叫做“后处理”。 如果你能确定候选区间里目标元素一定存在，则不必做“后处理”。例：LeetCode 第 69 题：x 的平方根 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 分析：非负实数 x 的平方根在 [0, x] 内一定存在，故退出 while (left &lt; right) 循环以后，不必单独判断 left 或者 right 是否符合题意。 如果你不能确定候选区间里目标元素一定存在，需要单独做一次判断。例：LeetCode 第 704 题：二分查找 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 分析：因为目标数有可能不在数组中，当候选区间夹逼成一个数的时候，要单独判断一下这个数是不是目标数，如果不是，返回 -1。 7、取中位数的时候，要避免在计算上出现整型溢出；int mid = (left + right) / 2; 的问题：在 left 和 right 很大的时候，left + right 会发生整型溢出，变成负数，这是一个 bug ，得改！ int mid = left + (right - left) / 2; 在 right 很大、 left 是负数且很小的时候， right - left 也有可能超过 int 类型能表示的最大值，只不过一般情况下 left 和 right 表示的是数组索引值，left 是非负数，因此 right - left 溢出的可能性很小。因此，它是正确的写法。下面介绍推荐的写法。 int mid = (left + right) &gt;&gt;&gt; 1; 如果这样写， left + right 在发生整型溢出以后，会变成负数，此时如果除以 22 ，mid 是一个负数，但是经过无符号右移，可以得到在不溢出的情况下正确的结果。 解释“无符号右移”：在 Java 中，无符号右移运算符 &gt;&gt;&gt; 和右移运算符 &gt;&gt; 的区别如下： 右移运算符 &gt;&gt; 在右移时，丢弃右边指定位数，左边补上符号位；无符号右移运算符 &gt;&gt;&gt; 在右移时，丢弃右边指定位数，左边补上 00，也就是说，对于正数来说，二者一样，而负数通过 &gt;&gt;&gt; 后能变成正数。下面解释上面的模板中，取中位数的时候使用先用“＋”，然后“无符号右移”。 a、int mid = (left + right) / 2 与 int mid = left + (right - left) / 2 两种写法都有整型溢出的风险，没有哪一个是绝对安全的，注意：这里我们取平均值用的是除以 2，并且是整除： int mid = (left + right) / 2 在 left 和 right 都很大的时候会溢出；int mid = left + (right - left) / 2 在 right 很大，且 left 是负数且很小的时候会溢出；b、写算法题的话，一般是让你在数组中做二分查找，因此 left 和 right 一般都表示数组的索引，因此 left 在绝大多数情况下不会是负数并且很小，因此使用 int mid = left + (right - left) // 2 相对 int mid = (left + right) // 2 更安全一些，并且也能向别人展示我们注意到了整型溢出这种情况，但事实上，还有更好的方式； c、建议使用 int mid = (left + right) &gt;&gt;&gt; 1 这种写法，其实是大有含义的： JDK8 中采用 int mid = (left + right) &gt;&gt;&gt; 1 ，重点不在 + ，而在 &gt;&gt;&gt; 。 我们看极端的情况，left 和 high 都是整型最大值的时候，注意，此时 3232 位整型最大值它的二进制表示的最高位是 00，它们相加以后，最高位是 11 ，变成负数，但是再经过无符号右移 &gt;&gt;&gt;（重点是忽略了符号位，空位都以 00 补齐），就能保证使用 + 在整型溢出了以后结果还是正确的。 Java 中 Collections 和 Arrays 提供的 binarySearch 方法，我们点进去看 left 和 right 都表示索引，使用无符号右移又不怕整型溢出，那就用 int mid = (left + right) &gt;&gt;&gt; 1 好啦。位运算本来就比使用除法快，这样看来使用 + 和 &lt;&lt;&lt; 真的是又快又好了。 我想这一点可能是 JDK8 的编写者们更层次的考量。 看来以后写算法题，就用 int mid = (left + right) &gt;&gt;&gt; 1 吧，反正更多的时候 left 和 right 表示索引。 8、编码一旦出现死循环，输出必要的变量值、分支逻辑是调试的重要方法。当出现死循环的时候的调试方法：打印输出左右边界、中位数的值和目标值、分支逻辑等必要的信息。 按照我的经验，一开始编码的时候，稍不注意就很容易出现死循环，不过没有关系，你可以你的代码中写上一些输出语句，就容易理解“在区间元素只有 2 个的时候容易出现死循环”。具体编码调试的细节，可以参考我在「力扣」第 69 题：x 的平方根的题解《二分查找 + 牛顿法（Python 代码、Java 代码）》 。 总结总结一下，我爱用这个模板的原因、技巧、优点和注意事项： 原因：无脑地写 while left &lt; right: ，这样你就不用判断，在退出循环的时候你应该返回 left 还是 right，因为返回 left 或者 right 都对； 技巧：先写分支逻辑，并且先写排除中位数的逻辑分支（因为更多时候排除中位数的逻辑容易想，但是前面我也提到过，这并不绝对），另一个分支的逻辑你就不用想了，写出第 1 个分支的反面代码即可（下面的说明中有介绍），再根据分支的情况选择使用左中位数还是右中位数； 说明：这里再多说一句。如果从代码可读性角度来说，只要是你认为好想的逻辑分支，就把它写在前面，并且加上你的注释，这样方便别人理解，而另一个分支，你就不必考虑它的逻辑了。有的时候另一个分支的逻辑并不太好想，容易把自己绕进去。如果你练习做得多了，会形成条件反射。 我简单总结了一下，左右分支的规律就如下两点： 如果第 1 个分支的逻辑是“左边界排除中位数”（left = mid + 1），那么第 2 个分支的逻辑就一定是“右边界不排除中位数”（right = mid），反过来也成立； 如果第 2 个分支的逻辑是“右边界排除中位数”（right = mid - 1），那么第 2 个分支的逻辑就一定是“左边界不排除中位数”（left = mid），反之也成立。 “反过来也成立”的意思是：如果在你的逻辑中，“边界不能排除中位数”的逻辑好想，你就把它写在第 1 个分支，另一个分支是它的反面，你可以不用管逻辑是什么，按照上面的规律直接给出代码就可以了。能这么做的理论依据就是“排除法”。 在「力扣」第 287 题：寻找重复数的题解《二分法（Python 代码、Java 代码）》和这篇题解的评论区中，有我和用户@fighterhit 给出的代码，在一些情况下，我们先写了不排除中位数的逻辑分支，更合适的标准就是“哪个逻辑分支好想，就先写哪一个”，欢迎大家参与讨论。 优点：分支条数只有 2 条，代码执行效率更高，不用在每一轮循环中单独判断中位数是否符合题目要求，写分支的逻辑的目的是尽量排除更多的候选元素，而判断中位数是否符合题目要求我们放在最后进行，这就是第 5 点； 说明：每一轮循环开始都单独判断中位数是否符合要求，这个操作不是很有普适性，因为从统计意义上说，中位数直接就是你想找的数的概率并不大，有的时候还要看看左边，还要看看右边。不妨就把它放在最后来看，把候选区间“夹逼”到只剩 11 个元素的时候，视情况单独再做判断即可。 注意事项 1：左中位数还是右中位数选择的标准根据分支的逻辑而来，标准是每一次循环都应该让区间收缩，当候选区间只剩下 22 个元素的时候，为了避免死循环发生，选择正确的中位数类型。如果你实在很晕，不防就使用有 22 个元素的测试用例，就能明白其中的原因，另外在代码出现死循环的时候，建议你可以将左边界、右边界、你选择的中位数的值，还有分支逻辑都打印输出一下，出现死循环的原因就一目了然了； 注意事项 2：如果能确定要找的数就在候选区间里，那么退出循环的时候，区间最后收缩成为 11 个数后，直接把这个数返回即可；如果你要找的数有可能不在候选区间里，区间最后收缩成为 11 个数后，还要单独判断一下这个数是否符合题意。 最后给出两个模板，大家看的时候看注释，不必也无需记忆它们。 说明：我写的时候，一般是先默认将中位数写成左中位数，再根据分支的情况，看看是否有必要调整成右中位数，即是不是要在 (right - left) 这个括号里面加 11 。 虽说是两个模板，区别在于选中位数，中位数根据分支逻辑来选，原则是区间要收缩，且不出现死循环，退出循环的时候，视情况，有可能需要对最后剩下的数单独做判断。 我想我应该是成功地把你绕晕了，如果您觉得啰嗦的地方，就当我是“重要的事情说了三遍”吧，确实是重点的地方我才会重复说。当然，最好的理解这个模板的方法还是应用它。在此建议您不妨多做几道使用“二分查找法”解决的问题，用一下我说的这个模板，在发现问题的过程中，体会这个模板好用的地方，相信你一定会和我一样爱上这个模板的。 在「力扣」的探索版块中，给出了二分查找法的 3 个模板，我这篇文章着重介绍了第 2 个模板，但是我介绍的角度和这个版块中给出的角度并不一样，第 1 个模板被我“嫌弃”了，第 3 个模板我看过了，里面给出的例题也可以用第 2 个模板来完成，如果大家有什么使用心得，欢迎与我交流。 来源：力扣（LeetCode），作者：liweiwei1419","link":"/Algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-leetcode35.html"},{"title":"动态规划DP算法详解","text":"定义动态规划（dynamic programing）和分治法类似，都是通过组合子问题的解来求解原问题的解。（在经典排序算法中的二路归并排序和快速排序都用到了分而治之的思想-分治法）。 分治法是将原问题划分为没有交集，相互独立的子问题，并分别求解后再进行合并，求出原问题的解。 动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。分治法会做许多不必要的工作，它会反复地求解那些公共子问题。动态规划算法对每个子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都需要重新计算。 动态规划上用来求解最优化问题（optimization problem）。 可以按照下面四个步骤来设计一个动态规划算法： 1、刻画一个最优解的结构特征。 2、递归地定义最优解的值。 3、计算最优解的值，通常采用自底向上的方法。 4、利用计算出的信息构造一个最优解。 对于确定状态转移方程就在第一步和第二步中，首先要确定问题的决策对象，接着对决策对象划分阶段并确定各个阶段的状态变量，最后建立各阶段的状态变量的转移方程。 例如用dp[i]表示以序列中第i个数字结尾的最长递增子序列长度和最长公共子序列中用dp[i][j]表示的两个字符串中前 i、 j 个字符的最长公共子序列，我们就是通过对这两个数字量的不断求解最终得到答案的。这个数字量就被我们称为状态。状态是描述问题当前状况的一个数字量。首先，它是数字的，是可以被抽象出来保存在内存中的。其次，它可以完全的表示一个状态的特征，而不需要其他任何的辅助信息。最后，也是状态最重要的特点，状态间的转移完全依赖于各个状态本身，如最长递增子序列中，dp[x]的值由 dp[i](i &lt; x)的值确定。若我们在分析动态规划问题的时候能够找到这样一个符合以上所有条件的状态，那么多半这个问题是可以被正确解出的。所以说，解动态规划问题的关键，就是寻找一个好的状态。 最优子结构用动态规划求解最优化问题的第一步就是刻画一个最优解的结构特征。如果一个问题的最优解包含其子问题的最优解，我们称此问题具有最优子结构性质。因此，某个问题是否适合用动态规划，它是否具有最优子结构性质是一个好的标准。使用动态规划方法时，我们用子问题的最优解来构造原问题的最优解。 如何发掘最优子结构的性质？1、证明问题最优解的第一个组成部分是做出一个选择，而做出这个选择将会产生一个或多个待解的子问题。 2、对一个给定问题，在其可能的第一步选择中，假定已经知道哪种选择才会得到最优解。而我们并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择。 3、给定获取的最优解选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间。 4、利用“剪切-粘贴(cut and paste)”技术证明作为构成原问题最优解组成部分，每个子问题的解就是它本身的最优解。 反证法：假定子问题的解不是自身的最优解，那么我们就可以从原问题中剪切掉这些非最优解，将最优解粘贴进去，从而得到原问题一个更优的解，这个解与最初的解的前提假设矛盾。 刻画子问题空间的经验保持子问题空间尽量简单，只在必要时才扩展它。例如下一节的例子，求钢条切割的最大收益问题中，子问题空间包含的问题为：对每个i值，长度为i的钢条最优切割问题。 对于不同问题领域，最优子结构的不同体现在两个方面： 原问题的最优解中涉及到多个子问题。 在确定最优解使用哪些子问题时，需要考察多少种选择。 重叠子问题适合用动态规划方法求解最优化问题的第二个性质是子问题的空间必须足够小，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。动态规划算法会对重叠的子问题只求解一次，并保存在一张表里，需要用的时候直接查表即可，每次查表的时间代价为常量O(1)。 核心问题动态规划的核心是状态和状态转移方程。 在记忆化搜索中，可以为正在处理的表项声明一个引用，简化对它的读写操作； 动态规划解决的是多阶段决策问题； 1初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 和分治法最大的区别在于：适合于用动态规划的问题，经过分解以后得到的子问题往往不是相互独立的（即下一个子阶段的求解是建立在上一个子阶段的基础之上，进行进一步的求解，而不是相互独立的问题） 动态规划问题一般由难到易分为一维动态规划，二维动态规划，多维动态规划，以及多变量动态规划问题。其中多维动态规划问题又可以进行降维。动态规划问题求解的最重要的一步就是求解出 状态转移方程 特性 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理. 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势，动态规划可以避免多次计算） 动态规划的解题核心主要分为两步： 第一步：状态的定义 第二步：状态转移方程的定义 在这里，我们为了避免混淆用“状态”这个词来替代“问题”这个词。“问题”表示的含义类似：题目、要求解的内容、题干中的疑问句这样的概念。状态表示我们在求解问题之中对问题的分析转化。 第一步：状态的定义 有的问题过于抽象，或者过于啰嗦干扰我们解题的思路，我们要做的就是将题干中的问题进行转化（换一种说法，含义不变）。转化成一系列同类问题的某个解的情况，比如说： 题目：求一个数列中最大连续子序列的和。 我们要将这个原问题转化为： 状态定义：Fk是第k项前的最大序列和，求F1～FN中最大值。 通过换一种表述方式，我们清晰的发现了解决问题的思路，如何求出F1～FN中的最大值是解决原问题的关键部分。上述将原问题转化成另一种表述方式的过程叫做：状态的定义。这样的状态定义给出了一种类似通解的思路，把一个原来毫无头绪的问题转换成了可以求解的问题。 第二步：状态转移方程的定义 在进行了状态的定义后，自然而然的想到去求解F1～FN中最大值。这也是状态定义的作用，让我们把一个总体的问题转化成一系列问题，而第二步：状态转移方程的定义则告诉我们如何去求解一个问题，对于上述已经转换成一系列问题我们要关注的点就在于：如何能够用前一项或者前几项的信息得到下一项，这种从最优子状态转换为下一个最优状态的思路就是动态规划的核心。对于上面的例子题目来说，状态转移方程的定义应该是： Fk=max{Fk-1+Ak,Ak}Fk是前k项的和，Ak是第k项的值 仔细思考一番，我们能够得到这样的结论，对于前k个项的最大子序列和是前k-1项的最大子序列和Fk与第k项的和、或者第k项两者中较大的。如果大家还是不能理解这个原理建议用演算纸自己计算一番，这里就不过多赘述了。这种状态转移的思路就是DP的核心。 状态转移方程动态规划中当前的状态往往依赖于前一阶段的状态和前一阶段的决策结果。例如我们知道了第i个阶段的状态Si以及决策Ui，那么第i+1阶段的状态Si+1也就确定了。所以解决动态规划问题的关键就是确定状态转移方程，一旦状态转移方程确定了，那么我们就可以根据方程式进行编码。 各种模型的状态转移方程汇总如下：1、最长公共子串假设两个字符串为str1和str2，它们的长度分别为n和m。d[i][j]表示str1中前i个字符与str2中前j个字符分别组成的两个前缀字符串的最长公共长度。这样就把长度为n的str1和长度为m的str2划分成长度为i和长度为j的子问题进行求解。状态转移方程如下： 1234dp[0][j] = 0; (0&lt;=j&lt;=m)dp[i][0] = 0; (0&lt;=i&lt;=n)dp[i][j] = dp[i-1][j-1] +1; (str1[i] == str2[j])dp[i][j] = 0; (str1[i] != str2[j]) 因为最长公共子串要求必须在原串中是连续的，所以一但某处出现不匹配的情况，此处的值就重置为0。 详细代码请看最长公共子串。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &quot;stdafx.h&quot;#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100char str1[MAXSIZE];char str2[MAXSIZE];int dp[MAXSIZE][MAXSIZE];//'y'代表str1[i] = str2[j];'n'反之char path[MAXSIZE][MAXSIZE];void printComStr(int i, int j){ if (path[i][j] == 'n' || i == 0 || j == 0) return; if (path[i][j] == 'y') { printComStr(i - 1, j - 1); cout &lt;&lt; str1[i - 1]; }}int main(){ int n, m; int indexi, indexj; int ans = 0; cin &gt;&gt; str1 &gt;&gt; str2; n = strlen(str1); m = strlen(str2); for (int i = 0; i &lt;= n;i++) for (int j = 0; j &lt;= m; j++) { dp[i][j] = 0; } for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { if (str1[i - 1] == str2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; path[i][j] = 'y'; } else { dp[i][j] = 0; path[i][j] = 'n'; } } for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { if (ans &lt; dp[i][j]) { ans = dp[i][j]; indexi = i; indexj = j; } } cout &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; indexi &lt;&lt; ' ' &lt;&lt; indexj &lt;&lt; endl; printComStr(indexi, indexj);} 2、最长公共子序列区分一下，最长公共子序列不同于最长公共子串，序列是保持子序列字符串的下标在str1和str2中的下标顺序是递增的，该字符串在原串中并不一定是连续的。同样的我们可以假设dp[i][j]表示为字符串str1的前i个字符和字符串str2的前j个字符的最长公共子序列的长度。状态转移方程如下： 1234dp[0][j] = 0; (0&lt;=j&lt;=m)dp[i][0] = 0; (0&lt;=i&lt;=n)dp[i][j] = dp[i-1][j-1] +1; (str1[i-1] == str2[j-1])dp[i][j] = max{dp[i][j-1],dp[i-1][j]}; (str1[i-1] != str2[j-1]) 详细代码请看最长公共子序列。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#define MAXSIZE 101char str1[MAXSIZE];char str2[MAXSIZE];//'l'表示dp[i][j] = dp[i][j] = dp[i - 1][j];//‘q’表示dp[i][j] = dp[i][j] = dp[i - 1][j];//'u'表示dp[i][j] = dp[i][j - 1];char path[MAXSIZE][MAXSIZE];int dp[MAXSIZE][MAXSIZE];void printLCS(int i, int j){ if (i == 0 || j == 0) return; if (path[i][j] == 'q') { printLCS(i - 1, j - 1); cout &lt;&lt; str1[i-1] &lt;&lt; ' '; } else if (path[i][j] == 'u') printLCS(i - 1, j); else printLCS(i, j - 1); } int main(){ int n, m; cin &gt;&gt; str1 &gt;&gt; str2; n = strlen(str1); m = strlen(str2); //初始化 for (int i = 0; i &lt; n;i++) for (int j = 0; j &lt; m; j++) dp[i][j] = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { if (str1[i - 1] == str2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; path[i][j] = 'q'; } else { if (dp[i - 1][j] &gt;= dp[i][j - 1]) { dp[i][j] = dp[i - 1][j]; path[i][j] = 'u'; } else { dp[i][j] = dp[i][j - 1]; path[i][j] = 'l'; } } } cout &lt;&lt; dp[n][m] &lt;&lt; endl; printLCS(n, m); return 0;} 3、最长递增子序列（最长递减子序列）因为两者的思路都是一样的，所以只给出最长递增子序列的状态转移方程。假设有序列{a1,a2,…,an}，我们求其最长递增子序列长度。按照递推求解的思想，我们用F[i]代表若递增子序列以ai结束时它的最长长度。当 i 较小，我们容易直接得出其值，如 F[1] = 1。那么，如何由已经求得的 F[i]值推得后面的值呢？假设，F[1]到F[x-1]的值都已经确定，注意到，以ax 结尾的递增子序列，除了长度为1的情况，其它情况中，ax都是紧跟在一个由 ai(i &lt; x)组成递增子序列之后。要求以ax结尾的最长递增子序列长度，我们依次比较 ax 与其之前所有的 ai(i &lt; x)， 若ai小于 ax，则说明ax可以跟在以ai结尾的递增子序列之后，形成一个新的递 增子序列。又因为以ai结尾的递增子序列最长长度已经求得，那么在这种情况下，由以 ai 结尾的最长递增子序列再加上 ax 得到的新的序列，其长度也可以确定，取所有这些长度的最大值，我们即能得到 F[x]的值。特殊的，当没有ai(i &lt; x)小 于ax， 那么以 ax 结尾的递增子序列最长长度为1。 即F[x] = max{1,F[i]+1|ai&lt;ax &amp;&amp; i&lt;x}。 详细代码请看最长递增子序列。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;const int MAXSIZE = 10;const int MIN = 0;int arr[] = { 1, 4, 3, 2, 6, 5 };int F[MAXSIZE];int main(){ int maxLen = MIN; memset(F, 0, MAXSIZE); F[0] = 1; for (int i = 1; i &lt; 6; i++) { for (int j = 0; j &lt; i; j++) { if (arr[i] &gt; arr[j] &amp;&amp; maxLen &lt; F[j]) { maxLen = F[j]; } } F[i] = maxLen + 1; } for (int k = 0; k &lt; 6; k++) cout &lt;&lt; F[k] &lt;&lt; ' '; cout &lt;&lt; endl;} 4、最大子序列和的问题假设有序列{a1,a2,…,an}，求子序列的和最大问题，我们用dp[i]表示以ai结尾的子序列的最大和。 12345dp[1] = a1; (a1&gt;=0 &amp;&amp; i == 1)dp[i] = dp[i-1]+ai; (ai&gt;=0 &amp;&amp; i&gt;=2)dp[i] = 0; (dp[i-1] + ai &lt;=0 &amp;&amp; i&gt;=2) 详细代码请看最大子序列的和。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100int a[MAXSIZE];int dp[MAXSIZE];int max = 0;int main(){ int n; cin &gt;&gt; n; memset(dp, 0, MAXSIZE); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) { if (dp[i-1] + a[i] &gt; 0) { dp[i] = dp[i - 1] + a[i]; } else { dp[i] = 0; } if (max &lt; dp[i]) max = dp[i]; } cout &lt;&lt; max &lt;&lt; endl; return 0;} 5、数塔问题（动态搜索）给定一个数组data[n][m]构成一个数塔求从最上面走到最低端经过的路径和最大。可以假设dp[i][j]表示走到第i行第j列位置处的最大值，那么可以推出状态转移方程： 1dp[i][j] = max{dp[i-1][j-1],dp[i-1][j]} + data[i][j]; 12345for(i=n-1;i&gt;=1;i--){ for(j=1;j&lt;=i;j++){ dp[i][j]=max{dp[i-1][j-1],dp[i-1][j]}+s[i][j] }} 6、（01）背包问题这是一个经典的动态规划问题，另外在贪心算法里也有背包问题，至于二者的区别在此就不做介绍了。 假设有N件物品和一个容量为V的背包。第i件物品的体积是v[i]，价值是c[i]，将哪些物品装入背包可使价值总和最大？ 每一种物品都有两种可能即放入背包或者不放入背包。可以用dp[i][j]表示第i件物品放入容量为j的背包所得的最大价值，则状态转移方程可以推出如下： 1dp[i][j]=max{dp[i-1][j-v[i]]+c[i],dp[i-1][j]}; 1234567891011for (int i = 1;i &lt;= N;i++) //枚举物品 { for (int j = 0;j &lt;= V;j++) //枚举背包容量 { f[i][j] = f[i - 1][j]; if (j &gt;= v[i]) { f[i][j] = Max(f[i - 1][j],f[i - 1][j - v[i]] + c[i]); } } } 说明 12345678901背包问题与背包问题的区别在于，01背包，物品的选择只有两种一种是拿，另一种是不拿，而背包问题在于，物品可以只取一部分。所以01背包问题不能用贪心算法解决。以dp[i][j]表示用i种物品，重量为j表示所取得的价值。对于第i种物品，如果第i种物品重量大于j，就证明第i种物品肯定不能取，这时的dp[i][j]=dp[i-1][j]如果第i种物品重量小于j，那就会出现两种情况，采用i的话，物品价值dp[i][j]=采用前面的i-1种物品，所占用的重量为j-i.getweight,所产生的价值+第i 种物品的价值，。如果不采用i，价值为dp[i-1][j]。换成数学表达式就是dp[i][j]=Math.max(dp[i-1][j-weight]+value,dp[i-1][j]);比如当i=5,j=10时，dp[5][10]就代表了所取得的最大价值。到这里我们就完成了任务的一半，接下为我们要寻找到底哪些物品放入了背包，从前面的表达式我们可以发现，当dp[i][j]=dp[i-1][j-weight]时，这时为i的物品就会放入背包，所以我们从结果，开始往回走，遇到这种情况，就说明有物品放入背包，然后物品数减1，重量减去为i的重量，继续，最后就能求出哪 些物品放入背包了。 JAVA代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Test { public static void main(String[] args) { int allweight=12; //总价值 int num=8; //物品 bao[] baos=new bao[num+1]; baos[1]=new bao(2, 13); baos[2]=new bao(1, 10); baos[3]=new bao(3, 24); baos[4]=new bao(2, 15); baos[5]=new bao(4, 28); baos[6]=new bao(5, 33); baos[7]=new bao(3, 20); baos[8]=new bao(1, 8); int[][] dp=new int[num+1][allweight+1]; //构成动态规划表 for(int i=0;i&lt;=num;i++) { for(int j=0;j&lt;=allweight;j++) { if(i==0||j==0) { dp[i][j]=0; }else { if (j&lt;baos[i].getWeight()) { dp[i][j]=dp[i-1][j]; }else { int value=baos[i].getValue(); int weight=baos[i].getWeight(); dp[i][j]=Math.max(dp[i-1][j-weight]+value,dp[i-1][j]); } } System.out.println(&quot;dp&quot;+&quot;[&quot;+i+&quot;]&quot;+&quot;[&quot;+j+&quot;]&quot;+dp[i][j]); } } int m=num; int n=allweight; int all=dp[m][n]; //寻找哪些物品放入背包 while(all&gt;=0) { if (m&gt;0&amp;&amp;dp[m][n]==dp[m-1][n]) { m=m-1; }else { System.out.println(baos[m]+&quot;加入背包&quot;); m=m-1; if (m==0) { return; }else { n=n-baos[m].getWeight(); all=all-baos[m].getWeight(); } } } }} 可以参照动态规划 - 0-1背包问题的算法优化、动态规划-完全背包问题、动态规划-多重背包问题、01背包问题 7、矩阵连乘（矩阵链问题）-参考《算法导论》例如矩阵链&lt;A1,A2,A3&gt;,它们的维数分别为10100,1005,550，那么如果顺序相乘即((A1A2)A3)，共需101005 + 10550 = 7500次乘法，如果按照(A1(A2A3))顺序相乘，却需做100550 + 10100*50 = 75000次乘法。两者之间相差了10倍，所以说矩阵链的相乘顺序也决定了计算量的大小。 我们用利用动态规划的方式(dp[i][j]表示第i个矩阵至第j个矩阵这段的最优解,还有对于两个矩阵A(i,j)B(j,k)则需要ij*k次乘法)，推出状态转移方程： 123dp[i][j] = 0; (i ==j，表示只有一个矩阵，计算次数为0)dp[i][j] = min{dp[i][k] + dp[k+1][j] + p[i-1]*p[k]*p[j]}; (i&lt;j &amp;&amp; i&lt;=k&lt;j) dp[1][n]即为最终求解. 123456789101112131415161718192021222324252627282930313233343536#define MAXSIZE 100int dp[MAXSIZE][MAXSIZE];//存储最小的就算次数int s[MAXSIZE][MAXSIZE];//存储断点，用在输出上面int i, j, tmp；for (int l = 2; l &lt;= n; l++){//j-i的长度,由于长度为1是相同的矩阵那么为0不用计算 for (i = 1; i &lt;= n - l + 1; i++){//由于j-i =l - 1 , 那么j的最大值为n，所以i上限为 n - l+1; j = i + l - 1;//由于j-i = l - 1 , 那么j = l+i-1 dp[i][j] = dp[i + 1][j] + r[i] * c[i] * c[j];//初始化，就是k = i； s[i][j] = i; for (k = i + 1; k &lt; j; k++){//循环枚举k i &lt; k &lt; j tmp = dp[i][k] + dp[k + 1][j] + r[i] * c[k] * c[j]; if (dp[i][j] &gt; tmp){ dp[i][j] = tmp;//更新为最小值 s[i][j] = k; } } }}//递归调用输出void output(int i, int j){ if (i == j){ printf(&quot;A%d&quot;, i);//当两个相等的时候就不用继续递归就输出A return;//返回上一层 } else{ printf(&quot;(&quot;); output(i, s[i][j]); printf(&quot; x &quot;); output(s[i][j] + 1, j); printf(&quot;)&quot;); }} 总结太难了，没事多来看看示例希望早日彻底吃透！ 参考文章:参考链接1参考链接2","link":"/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html"},{"title":"算法成长之路leetcode9-10","text":"9. Palindrome NumberDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example123456789101112131415161718Example 1:Input: 121Output: trueExample 2:Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.Example 3:Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome.Follow up:Coud you solve it without converting the integer to a string? Java 题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package algorithm;public class Leetcode9 { /** * 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 * * 示例 1: * * 输入: 121 * 输出: true * 示例 2: * * 输入: -121 * 输出: false * 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 * 示例 3: * * 输入: 10 * 输出: false * 解释: 从右向左读, 为 01 。因此它不是一个回文数。 * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/palindrome-number * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 * @param x * @return */ public static boolean isPalindrome(int x) { if (x &gt;= 0 &amp;&amp; x &lt; 10) { return true; } String source = x + &quot;&quot;; int length = source.length(); // mid中间位置1，mid1中间位置2 int mid, mid1; // 偶数 if (length % 2 == 0) { // 如 1221 偶数，中间位置分别为2，2 mid = length / 2 - 1; mid1 = mid + 1; } else { // 奇数时，212，中间位置分别是1，1 mid = length / 2; mid1 = mid; } // 确定中心位置向两边扩展是否相等，直到扩展完位置 while (mid &gt;= 0 &amp;&amp; source.charAt(mid) == source.charAt(mid1)) { mid = mid - 1; mid1 = mid1 + 1; } // 如果循环结束并且所有数都遍历完 if (mid == -1 &amp;&amp; mid1 == length) { return true; } else { return false; } } public static boolean isPalindrome1(int x) { // 特殊情况： // 如上所述，当 x &lt; 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) { return false; } // 一位一位反转的数 int revertedNumber = 0; // 如121 while (x &gt; revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; x /= 10; System.out.println(&quot;x=&quot; + x + &quot;,revertedNumber=&quot; + revertedNumber); } // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber / 10; } public static void main(String[] args) { /** * -1 * 121 * 222 * 2222 * 1221 * -12 */ System.out.println(isPalindrome(1221)); System.out.println(isPalindrome1(121)); }} 10. Regular Expression MatchingGiven an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’. ‘.’ Matches any single character.‘*’ Matches zero or more of the preceding element.The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z.p could be empty and contains only lowercase letters a-z, and characters like . or *. Example12345678910111213141516171819202122232425262728293031323334Example 1:Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.Example 2:Input:s = &quot;aa&quot;p = &quot;a&quot;Output: trueExplanation: '' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes &quot;aa&quot;.Example 3:Input:s = &quot;ab&quot;p = &quot;.&quot;Output: trueExplanation: &quot;.&quot; means &quot;zero or more (*) of any character (.)&quot;.Example 4:Input:s = &quot;aab&quot;p = &quot;cab&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.Example 5:Input:s = &quot;mississippi&quot;p = &quot;misisp*.&quot;Output: false JAVA 题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455package algorithm;public class Leetcode10 { /** * 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 * * '.' 匹配任意单个字符 * '*' 匹配零个或多个前面的那一个元素 * 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 * * 说明: * * s 可能为空，且只包含从 a-z 的小写字母。 * p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 * 示例 1: * * 输入: * s = &quot;aa&quot; * p = &quot;a&quot; * 输出: false * 解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 * 示例 2: * * 输入: * s = &quot;aa&quot; * p = &quot;a*&quot; * 输出: true * 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 &quot;aa&quot; 可被视为 'a' 重复了一次。 * 示例 3: * * 输入: * s = &quot;ab&quot; * p = &quot;.*&quot; * 输出: true * 解释: &quot;.*&quot; 表示可匹配零个或多个（'*'）任意字符（'.'）。 * 示例 4: * * 输入: * s = &quot;aab&quot; * p = &quot;c*a*b&quot; * 输出: true * 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 * 示例 5: * * 输入: * s = &quot;mississippi&quot; * p = &quot;mis*is*p*.&quot; * 输出: false * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/regular-expression-matching * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 * * * * 如果模式串中有星号，它会出现在第二个位置， * 即pattern[1] 。这种情况下，我们可以直接忽略模式串中这一部分， * 或者删除匹配串的第一个字符，前提是它能够匹配模式串当前位置字符，即 pattern[0] 。 * 如果两种操作中有任何一种使得剩下的字符串能匹配，那么初始时，匹配串和模式串就可以被匹配。 * * @param text * @param pattern * @return */ public static boolean isMatch(String text, String pattern) { // 递归回溯 if (pattern.isEmpty()) return text.isEmpty(); boolean first_match = (!text.isEmpty() &amp;&amp; (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));// 判断第一个是否相等 System.out.println(&quot;t=&quot;+text+&quot;,p=&quot;+pattern+&quot;,firstM=&quot;+first_match); if (pattern.length() &gt;= 2 &amp;&amp; pattern.charAt(1) == '*'){ // 长度&gt;=2 并且p第二个是* System.out.println(&quot;if1&quot;); return (isMatch(text, pattern.substring(2)) || // 直接忽略模式串中这一部分 如t=abc,p=a*. 直接忽略 a* (first_match &amp;&amp; isMatch(text.substring(1), pattern))); // 删除匹配串的第一个字符 } else { System.out.println(&quot;if2&quot;); return first_match &amp;&amp; isMatch(text.substring(1), pattern.substring(1));// 第一个匹配后，后面逐个匹配 } } /** * 状态 * 首先状态 dp 一定能自己想出来。 * dp[i][j] 表示 s 的前 ii 个是否能被 p 的前 jj 个匹配 * * 转移方程 * 怎么想转移方程？首先想的时候从已经求出了 dp[i-1][j-1] 入手，再加上已知 s[i]、p[j]，要想的问题就是怎么去求 dp[i][j]。 * * 已知 dp[i-1][j-1] 意思就是前面子串都匹配上了，不知道新的一位的情况。 * 那就分情况考虑，所以对于新的一位 p[j] s[i] 的值不同，要分情况讨论： * * 考虑最简单的 p[j] == s[i] : dp[i][j] = dp[i-1][j-1] * 然后从 p[j] 可能的情况来考虑，让 p[j]=各种能等于的东西。 * * p[j] == &quot;.&quot; : dp[i][j] = dp[i-1][j-1] * * p[j] ==&quot; * &quot;: * * 第一个难想出来的点：怎么区分 *∗ 的两种讨论情况 * 首先给了 *，明白 * 的含义是 匹配零个或多个前面的那一个元素，所以要考虑他前面的元素 p[j-1]。* 跟着他前一个字符走，前一个能匹配上 s[i]，* 才能有用，前一个都不能匹配上 s[i]，* 也无能为力，只能让前一个字符消失，也就是匹配 00 次前一个字符。 * 所以按照 p[j-1] 和 s[i] 是否相等，我们分为两种情况： * * 3.1 p[j-1] != s[i] : dp[i][j] = dp[i][j-2] * 这就是刚才说的那种前一个字符匹配不上的情况。 * 比如(ab, abc * )。遇到 * 往前看两个，发现前面 s[i] 的 ab 对 p[j-2] 的 ab 能匹配，虽然后面是 c*，但是可以看做匹配 00 次 c，相当于直接去掉 c *，所以也是 True。注意 (ab, abc**) 是 False。 * 3.2 p[j-1] == s[i] or p[j-1] == &quot;.&quot;： * * 前面那个字符，能匹配 s[i]，或者 * 前面那个字符是万能的 . * 因为 . * 就相当于 . .，那就只要看前面可不可以匹配就行。 * 比如 (##b , ###b *)，或者 ( ##b , ### . * ) 只看 ### 后面一定是能够匹配上的。 * 所以要看 b 和 b * 前面那部分 ## 的地方匹不匹配。 * 第二个难想出来的点：怎么判断前面是否匹配 * dp[i][j] = dp[i-1][j] // 多个字符匹配的情况 * or dp[i][j] = dp[i][j-1] // 单个字符匹配的情况 * or dp[i][j] = dp[i][j-2] // 没有匹配的情况 * 看 ### 匹不匹配，不是直接只看 ### 匹不匹配，要综合后面的 b b* 来分析 * 这三种情况是 oror 的关系，满足任意一种都可以匹配上，同时是最难以理解的地方： * * dp[i-1][j] 就是看 s 里 b 多不多， ### 和 ###b * 是否匹配，一旦匹配，s 后面再添个 b 也不影响，因为有 * 在，也就是 ###b 和 ###b *也会匹配。 * * dp[i][j-1] 就是去掉 * 的那部分，###b 和 ###b 是否匹配，比如 qqb qqb * * dp[i][j-2] 就是 去掉多余的 b *，p 本身之前的能否匹配，###b 和 ### 是否匹配，比如 qqb qqbb* 之前的 qqb qqb 就可以匹配，那多了的 b * 也无所谓，因为 b * 可以是匹配 00 次 b，相当于 b * 可以直接去掉了。 * * 三种满足一种就能匹配上。 * * 为什么没有 dp[i-1][j-2] 的情况？ 就是 ### 和 ### 是否匹配？因为这种情况已经是 dp[i][j-1] 的子问题。也就是 s[i]==p[j-1]，则 dp[i-1][j-2]=dp[i][j-1]。 * * 最后来个归纳： * 如果 p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1]； * 如果 p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1]； * 如果 p.charAt(j) == '*'： * 如果 p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty * 如果 p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.'： * dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a * or dp[i][j] = dp[i][j-1] // in this case, a* counts as single a * or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty * * 作者：kao-la-7 * 链接：https://leetcode-cn.com/problems/regular-expression-matching/solution/dong-tai-gui-hua-zen-yao-cong-0kai-shi-si-kao-da-b/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * @param s * @param p * @return */ public static boolean isMatch1(String s, String p) { // 动态规划 if (s == null || p == null) { return false; } boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]; dp[0][0] = true;//dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配 for (int i = 0; i &lt; p.length(); i++) { // here's the p's length, not s's if (p.charAt(i) == '*' &amp;&amp; dp[0][i - 1]) { dp[0][i + 1] = true; // here's y axis should be i+1 } } for (int i = 0; i &lt; s.length(); i++) { for (int j = 0; j &lt; p.length(); j++) { if (p.charAt(j) == '.' || p.charAt(j) == s.charAt(i)) {//如果是任意元素 或者是对于元素匹配 dp[i + 1][j + 1] = dp[i][j]; } if (p.charAt(j) == '*') { if (p.charAt(j - 1) != s.charAt(i) &amp;&amp; p.charAt(j - 1) != '.') {//如果前一个元素不匹配 且不为任意元素 dp[i + 1][j + 1] = dp[i + 1][j - 1]; } else { dp[i + 1][j + 1] = (dp[i + 1][j] || dp[i][j + 1] || dp[i + 1][j - 1]); /* dp[i][j] = dp[i-1][j] // 多个字符匹配的情况 or dp[i][j] = dp[i][j-1] // 单个字符匹配的情况 or dp[i][j] = dp[i][j-2] // 没有匹配的情况 */ } } } } return dp[s.length()][p.length()]; } // 官方解法-- enum Result { TRUE, FALSE } Result[][] memo; public boolean isMatch2(String text, String pattern) { // 自顶向下 官方 memo = new Result[text.length() + 1][pattern.length() + 1]; return dp(0, 0, text, pattern); } public boolean dp(int i, int j, String text, String pattern) { if (memo[i][j] != null) { return memo[i][j] == Result.TRUE; } boolean ans; if (j == pattern.length()) { ans = i == text.length(); } else { boolean first_match = (i &lt; text.length() &amp;&amp; (pattern.charAt(j) == text.charAt(i) || pattern.charAt(j) == '.')); if (j + 1 &lt; pattern.length() &amp;&amp; pattern.charAt(j + 1) == '*') { ans = (dp(i, j + 2, text, pattern) || first_match &amp;&amp; dp(i + 1, j, text, pattern)); } else { ans = first_match &amp;&amp; dp(i + 1, j + 1, text, pattern); } } memo[i][j] = ans ? Result.TRUE : Result.FALSE; return ans; } public boolean isMatch3(String text, String pattern) { //动态规划，自底向上 boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1]; dp[text.length()][pattern.length()] = true; for (int i = text.length(); i &gt;= 0; i--) { for (int j = pattern.length() - 1; j &gt;= 0; j--) { boolean first_match = (i &lt; text.length() &amp;&amp; (pattern.charAt(j) == text.charAt(i) || pattern.charAt(j) == '.')); if (j + 1 &lt; pattern.length() &amp;&amp; pattern.charAt(j + 1) == '*') { dp[i][j] = dp[i][j + 2] || first_match &amp;&amp; dp[i + 1][j]; } else { dp[i][j] = first_match &amp;&amp; dp[i + 1][j + 1]; } } } return dp[0][0]; } // 官方解法--- public static void main(String[] args) { // &quot;abc&quot;,&quot;a*.&quot; // &quot;abc&quot;,&quot;ab*.&quot; System.out.println(isMatch(&quot;abc&quot;,&quot;ab*.&quot;)); /** * log * t=abc,p=ab*.,firstM=true * if2 * t=bc,p=b*.,firstM=true * if1 * t=bc,p=.,firstM=true * if2 * t=c,p=b*.,firstM=false * if1 * t=c,p=.,firstM=true * if2 * true */ int cons[] = new int[]{1,2,3}; System.out.println(getLeastCoinAmount(3,cons)); } /** * * 常见DP小问题 参考自 https://www.cnblogs.com/fefjay/p/7541760.html * * 动态规划算法是一种比较灵活的算法，针对具体的问题要具体分析，其宗旨就是要找出要解决问题的状态， * 然后逆向转化为求解子问题，最终回到已知的初始态，然后再顺序累计各个子问题的解从而得到最终问题的解。 * * 关键点就是找到状态转移方程和初始边界条件，说白了就是要找到“递推公式”和初始值，然后计算时保存每一步中间结果，最后累加判断得到结果。 */ /** * 0.求数组最值 * 求数组最值方法很多，这里使用动态规划的思想来尝试处理，以便更好地理解DP的思想。为了方便这里假设数组a[i]大小为n，要找n个数当中的最大值。 * * 设dp[i]表示第0...i个数的最大值，dp[i-1]表示第0...i-1个数的最大值，所以求前i个数的最大值时， * 已经知道前i-1个是的最大值是dp[i-1]，那么只需要比较dp[i-1]和第i个数谁大就知道了，即dp[i] = max(dp[-1], a[i])。 */ public int max(int[] a){ int len = a.length; int[] dp = new int[len]; dp[0] = a[0]; for(int i=1; i&lt;len; i++){ dp[i] = (dp[i-1] &gt; a[i]) ? dp[i-1] : a[i]; } return dp[len-1]; } /** * 1.求最大公共子序列长度 * 给定一个字符串，想要删掉某些字符使得最后剩下的字符构成一个回文串（左右对称的字符串，如abcba）， * 问最少删掉多少个字符可获得一个最长回文串。 */ /** * 本题求回文串最大长度就转化为求两个字符串的最长公共子序列（不一定连续） * 策略：字符串可以看做是字符序列，即字符数组。 * 比如有序列A=a0,a1,a2...an；有序列B=b0,b1,b2,b3...bm；设A序列和B序列的公共子序列为C=c0,c1,c2,c3...ck。 * 设L[][]为公共子序列C的长度，L[i][j]的i、j分别表示A、B序列的字符下标，L[i][j]含义是A序列a0、a1、a2...ai和B序列b0、b1、b2、 * ...bj的公共子序列的长度。 * * 1）如果A序列的i字符和B序列的j字符相等，那么就有ck=ai=bj，公共子序列C的长度L[i][j]=L[i-1][j-1]+1。 * 2）如果A序列的i字符和B序列的j字符不相等，若ai != ck则C为a0...ai-1和b0...bj的最长子序列，若bj != ck则C为a0...ai和b0...bj-1的最长子序列， * 所以此时公共子序列长度为L[i][j] = max(L[i][j-1], L[i-1][j])。 */ public static int lcs(String s){ if (s == null ) { return -1; } String rs = new StringBuilder(s).reverse().toString(); char[] chars1 = s.toCharArray(); char[] chars2 = rs.toCharArray();//获得反序的字符串 int n = chars1.length; int[][] dp = new int[n+1][n+1]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if(chars1[i] == chars2[j]){ dp[i][j] = dp[i-1][j-1] + 1; }else { dp[i][j] = dp[i][j-1] &gt; dp[i-1][j] ? dp[i][j-1] : dp[i-1][j]; } } } return n - dp[n][n]; } /** * 2.硬币凑钱问题 * 只有面值为1元、3元、5元的硬币，数量足够。现在要凑够n元，求需要的最少硬币枚数。 * * @param n 目标总钱数 * @param coins 硬币数组【1，3，5】 * @return 返回凑够n元需要的最少硬币数 */ public static int getLeastCoinAmount(int n, int[] coins){ if (coins == null || n &lt; 0) { return -1; } if (n == 0){ return 0; } int[] dp = new int[n+1]; //dp[i]=j表示凑够i元最少需要j枚硬币。数组长度设为（n+1）保证可以访问dp[n]。 dp[0] = 0; for (int i = 1; i &lt;= n; i++) { dp[i] = Integer.MAX_VALUE; } int coinValue = 0; for (int i = 1; i &lt;= n; i++) {//问题规模从小到大，直到达到目标面值 for (int j = 0; j &lt; coins.length; j++) {//遍历所有面值的硬币，j表示硬币面值的下标 coinValue = coins[j]; if (i - coinValue &gt;= 0 &amp;&amp; 1 + dp[i-coinValue] &lt; dp[i]){ //当前方案的硬币数更少，则使用当前方案 dp[i] = 1 + dp[i-coins[j]]; } } } return dp[n]; } /** * 3.最长非降子序列 * 一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。 */ /** * * 定义d(i)表示前i个数中&quot;以A[i]结尾&quot;的最长非降子序列的长度。 * 对序列A1...Ai,找到的最长子序列长度d[i]分两种情况： * （1）包含最后一个数Ai,即d[i]=max{d[j]+1}(1&lt;=j&lt;i且Aj&lt;=Ai)，满足条件的Aj可能会有多个，选最大的d[j]，如果Aj都大于Ai则d[j]=0； * （2）不含最后一个数,即d[i]=d[i-1] * * 综上：d[i] = max{d[i-1], max{d[j]+1}} */ public static int longestIncreasingSubsequence(int[] a){ if (a == null) { return -1; } if (a.length &lt; 1){ return 0; } int len = a.length; int[] dp = new int[len];//dp[i]系统自动初始化为0 dp[0] = 1; for (int i = 1; i &lt; len; i++) {//迭代，求序列0...len-1的最长子序列长度 for (int j = 0; j &lt; i; j++) {//寻找Ai之前的序列，看是否有不大于Ai的数字Aj if (a[j] &lt;= a[i] &amp;&amp; dp[i] &lt; dp[j] + 1){//假设最长子序列包含最后一个数 dp[i] = dp[j] + 1; } } //寻找Ai之前的序列如果Ai都小于Aj，此时dp[i]并没有被修改仍为初始值0。所以包含最后一个数的最长子序列就只有最后一个数自身，长1 dp[i] = Math.max(1, dp[i]); //至此，已经求出了包含最后一个数的最长子序列的长度，和不包含最后一个数的最长子序列长度比较，取最大值为当前的最大长度 dp[i] = Math.max(dp[i], dp[i-1]); } return dp[len-1]; } /** * 4.经典01背包问题 * 01背包问题：一个承重（或体积）为W的背包，可选物品有n个，第i个物品分别重w[i]和价值v[i]， * 每个物品只能拿或不拿，求背包可放物品的最大价值。 */ /** * * 策略：这里的关键制约因素是背包只能承重w，而且每放入一个物品其承重就会减少。 * 因此定义maxValue=V[i][j]，数组表示目前可选物品有i个：0、1...i-1，背包承重（剩余的存放重量）为j的最大价值。 * 现在假设已经知道了(i-1)个物品且剩余承重为j的最大价值V[i-1][j]，那么考虑准备放入第i个物品的情况： * （1）如果第i个物品的重量大于背包的剩余承重w_i&gt;j，显然放不下了，所以此时V[i][j]=V[i-1][j]; * (2)w_i&lt;=j，显然可以放下第i个物品，物品可以放得下，但是一定要装进来吗？如果装进的物品价值较低且较重，无疑会影响后续物品的装入情况。 * 所以还要考虑要不要放进来的子问题，V[i][j]=max{vi+V[i-1][j-wi], V[i-1][j]}。 * * @param W * @param n * @param w * @param v * @return */ public static int knapsack(int W, int n, int[] w, int[] v){ if ( W &lt; 1 || n &lt; 1 || w == null || v == null) { return -1; } int[][] dp = new int[n+1][W+1]; //可选的物品最多可以有n个，所以行数设为n+1。最大承重是W，所以列设为W+1。 int index = 0; for (int i = 1; i &lt;= n; i++) { //物品数肯定是从1开始。dp[0][j]系统初始化为0. index = i-1; for (int j = 1; j &lt;= W ; j++) {//能装进的重量肯定是从1开始。dp[i][0]系统初始化为0. if (w[index] &gt; j){ dp[i][j] = dp[i-1][j]; }else { dp[i][j] = Math.max(dp[i - 1][j - w[index]] + v[index], dp[i - 1][j]); } } } //找出是哪些物品放入背包 boolean[] isTaken = new boolean[n];//标记是否放入背包里 for (int i = n; i &gt; 0 ; i--) { if (dp[i][W] != dp[i-1][W]){ isTaken[i-1] = true;//装入 W -= w[i-1];//装入之后背包的承重减少 System.out.println(i-1); } } return dp[n][W];//返回n个物品承重为W时的最大价值 }}","link":"/Algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode9-10.html"},{"title":"博客中gitalk最新评论的获取","text":"博客中，对于网友的评论以及每篇文章的评论数还是很重要的。但是基于静态的页面想要存储动态的评论数据是比较难的，一般博客主题中都内置了评论插件，但是博客主题中对于最新评论的支持显示还是很少的，至少目前我是没怎么发现。博客 Powered by Hexo &amp; Icarus，采用Gitalk评论，再次感谢此三位作者的辛勤码代码，才有了以下的内容。基于此背景基础上，聊聊最新评论的实现。 博客的使用， Hexo &amp; Icarus，采用Gitalk评论 的使用自行百度了。 使用场景 最新评论列表 最热文章列表（基于评论数判断是否最热，也比较片面，但是侧面也能反映，问题不大） 使用方法主要参考自官方文档 目前主要用到两个方法，一个是获取仓库下所有的issue，每个issue节点下有相关的评论数，以及对应issue下的评论的url;还有一个是根据issue下评论的URL获取相应的所有的评论 方法1：List issues for a repository1GET /orgs/:org/issues 参数列表 Name Type Description milestone integer or string If an integer is passed, it should refer to a milestone by its number field. If the string * is passed, issues with any milestone are accepted. If the string none is passed, issues without milestones are returned. state string Indicates the state of the issues to return. Can be either open, closed, or all. Default: open assignee string Can be the name of a user. Pass in none for issues with no assigned user, and * for issues assigned to any user. creator string The user that created the issue. mentioned string A user that’s mentioned in the issue. labels string A list of comma separated label names. Example: bug,ui,@high sort string What to sort results by. Can be either created, updated, comments. Default: created direction string The direction of the sort. Can be either asc or desc. Default: desc since string Only issues updated at or after this time are returned. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. 以上参数，主要用到 sort 排序，page页数，per_page每页数量，其余的参数看个人需要使用。注意文档中的说明，排序的字段和返回的稍许不太一样。 方法2：List comments on an issue1GET /repos/:owner/:repo/issues/:issue_number/comments Issue Comments are ordered by ascending ID. 排序根据 ascending (上升的，增长的；升（序）的)ID.也就是说，从老到新。这个比较坑，对于我们获取最新评论来说。 参数如下 Name Type Description since string Only comments updated at or after this time are returned. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. 根据尝试以及以上参数，试出不支持排序，但是支持分页，page,per_page参数，对于我们获取最新的评论来说可以根据评论数，算出分页数，拿到最后一条，即最新一条 123456//如果只有一页int page = 1;int per_page = 1;// 如果超出一页的话int page = 2;int per_page = commentsNumber-1;//commentsNumber:评论数 js代码中使用实例核心代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var timesSet = [];var timesBodyMap = {};var timesSetMap = {};var resultArr = [];// 方法1：sort=comments可以按评论数排序，此处更适合按更新时间排序,可以根据updated排序，但是0条评论的也会出来，所以此处还是根据评论数排序全部查出来，过滤掉0条评论的，拿到每个issue下最新的一条评论详情和时间，根据时间内存排序// per_page 每页数量，根据需求配置$.getJSON(&quot;https://api.github.com/repos/{用户名}/{仓库}/issues?per_page=100&amp;sort=comments&quot;, function (result) { $.each(result, function (i, item) { var commentsCount = item.comments; if (commentsCount &gt; 0) { $.ajaxSettings.async = false; // 此处保证是最后一条，api没有排序参数，只能分页取最后一条，保证最少的数据量传输，快速处理 var page = 2; var pageSize = commentsCount - 1; if (commentsCount == 1) { page = 1; pageSize = 1; } // 方法2：的使用 $.getJSON(item.comments_url + &quot;?page=&quot; + page + &quot;&amp;per_page=&quot; + pageSize, function (commentResult) { var item1 = commentResult[0]; var contentStr = item1.body.trim(); if (contentStr.length &gt; 50) { contentStr = contentStr.substr(0, 60); contentStr += &quot;...&quot;; } timesSet.push(new Date(item1.created_at).getTime()); timesBodyMap[item1.created_at] = { &quot;title&quot;: item.title.substr(0, item.title.indexOf(&quot;-&quot;) - 1), &quot;url&quot;: item.body.substr(0, item.body.indexOf(&quot;\\n&quot;) - 1), &quot;content&quot;: contentStr, &quot;date&quot;: item1.created_at, &quot;userName&quot;: item1[&quot;user&quot;].login, &quot;userUrl&quot;: item1[&quot;user&quot;].html_url, &quot;commentCount&quot;: commentsCount }; timesSetMap[new Date(item1.created_at).getTime()] = item1.created_at; }); } });});// 排序if (timesSet.length &gt; 0) { timesSet.sort();}// 根据需要取10条if (timesSet.length &gt; 10) { for (var i = timesSet.length - 1; i &gt;= 0 &amp;&amp; resultArr.length &lt; 10; i--) { resultArr.push(timesBodyMap[timesSetMap[timesSet[i]]]); }}else { for (var i = timesSet.length - 1; i &gt;= 0; i--) { resultArr.push(timesBodyMap[timesSetMap[timesSet[i]]]); }} 方法1：请求接口地址示例1https://api.github.com/repos/removeif/blog_comment/issues?per_page=100&amp;sort=comments 返回结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566[ { &quot;url&quot;: &quot;https://api.github.com/repos/removeif/blog_comment/issues/3&quot;, &quot;repository_url&quot;: &quot;https://api.github.com/repos/removeif/blog_comment&quot;, &quot;labels_url&quot;: &quot;https://api.github.com/repos/removeif/blog_comment/issues/3/labels{/name}&quot;, &quot;comments_url&quot;: &quot;https://api.github.com/repos/removeif/blog_comment/issues/3/comments&quot;, &quot;events_url&quot;: &quot;https://api.github.com/repos/removeif/blog_comment/issues/3/events&quot;, &quot;html_url&quot;: &quot;https://github.com/removeif/blog_comment/issues/3&quot;, &quot;id&quot;: 458985510, &quot;node_id&quot;: &quot;MDU6SXNzdWU0NTg5ODU1MTA=&quot;, &quot;number&quot;: 3, &quot;title&quot;: &quot;留言板 - 辣椒の酱&quot;, &quot;user&quot;: { &quot;login&quot;: &quot;removeif&quot;, &quot;id&quot;: 10427139, &quot;node_id&quot;: &quot;MDQ6VXNlcjEwNDI3MTM5&quot;, &quot;avatar_url&quot;: &quot;https://avatars1.githubusercontent.com/u/10427139?v=4&quot;, &quot;gravatar_id&quot;: &quot;&quot;, &quot;url&quot;: &quot;https://api.github.com/users/removeif&quot;, &quot;html_url&quot;: &quot;https://github.com/removeif&quot;, &quot;followers_url&quot;: &quot;https://api.github.com/users/removeif/followers&quot;, &quot;following_url&quot;: &quot;https://api.github.com/users/removeif/following{/other_user}&quot;, &quot;gists_url&quot;: &quot;https://api.github.com/users/removeif/gists{/gist_id}&quot;, &quot;starred_url&quot;: &quot;https://api.github.com/users/removeif/starred{/owner}{/repo}&quot;, &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/removeif/subscriptions&quot;, &quot;organizations_url&quot;: &quot;https://api.github.com/users/removeif/orgs&quot;, &quot;repos_url&quot;: &quot;https://api.github.com/users/removeif/repos&quot;, &quot;events_url&quot;: &quot;https://api.github.com/users/removeif/events{/privacy}&quot;, &quot;received_events_url&quot;: &quot;https://api.github.com/users/removeif/received_events&quot;, &quot;type&quot;: &quot;User&quot;, &quot;site_admin&quot;: false }, &quot;labels&quot;: [ { &quot;id&quot;: 1416043904, &quot;node_id&quot;: &quot;MDU6TGFiZWwxNDE2MDQzOTA0&quot;, &quot;url&quot;: &quot;https://api.github.com/repos/removeif/blog_comment/labels/3306ea6632b94cc388b40cef9dda4a8f&quot;, &quot;name&quot;: &quot;3306ea6632b94cc388b40cef9dda4a8f&quot;, &quot;color&quot;: &quot;0e8a16&quot;, &quot;default&quot;: false }, { &quot;id&quot;: 1415994590, &quot;node_id&quot;: &quot;MDU6TGFiZWwxNDE1OTk0NTkw&quot;, &quot;url&quot;: &quot;https://api.github.com/repos/removeif/blog_comment/labels/Gitalk&quot;, &quot;name&quot;: &quot;Gitalk&quot;, &quot;color&quot;: &quot;5319e7&quot;, &quot;default&quot;: false } ], &quot;state&quot;: &quot;open&quot;, &quot;locked&quot;: false, &quot;assignee&quot;: null, &quot;assignees&quot;: [ ], &quot;milestone&quot;: null, &quot;comments&quot;: 33, &quot;created_at&quot;: &quot;2019-06-21T03:06:53Z&quot;, &quot;updated_at&quot;: &quot;2019-09-12T10:37:34Z&quot;, &quot;closed_at&quot;: null, &quot;author_association&quot;: &quot;OWNER&quot;, &quot;body&quot;: &quot;https://removeif.github.io/message/\\r\\n\\r\\n留言板信息。&quot; }, {...} ] 方法2：请求接口地址示例1https://api.github.com/repos/removeif/blog_comment/issues/3/comments?per_page=32&amp;page=2 返回结果 123456789101112131415161718192021222324252627282930313233[ { &quot;url&quot;: &quot;https://api.github.com/repos/removeif/blog_comment/issues/comments/530767913&quot;, &quot;html_url&quot;: &quot;https://github.com/removeif/blog_comment/issues/3#issuecomment-530767913&quot;, &quot;issue_url&quot;: &quot;https://api.github.com/repos/removeif/blog_comment/issues/3&quot;, &quot;id&quot;: 530767913, &quot;node_id&quot;: &quot;MDEyOklzc3VlQ29tbWVudDUzMDc2NzkxMw==&quot;, &quot;user&quot;: { &quot;login&quot;: &quot;removeif&quot;, &quot;id&quot;: 10427139, &quot;node_id&quot;: &quot;MDQ6VXNlcjEwNDI3MTM5&quot;, &quot;avatar_url&quot;: &quot;https://avatars1.githubusercontent.com/u/10427139?v=4&quot;, &quot;gravatar_id&quot;: &quot;&quot;, &quot;url&quot;: &quot;https://api.github.com/users/removeif&quot;, &quot;html_url&quot;: &quot;https://github.com/removeif&quot;, &quot;followers_url&quot;: &quot;https://api.github.com/users/removeif/followers&quot;, &quot;following_url&quot;: &quot;https://api.github.com/users/removeif/following{/other_user}&quot;, &quot;gists_url&quot;: &quot;https://api.github.com/users/removeif/gists{/gist_id}&quot;, &quot;starred_url&quot;: &quot;https://api.github.com/users/removeif/starred{/owner}{/repo}&quot;, &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/removeif/subscriptions&quot;, &quot;organizations_url&quot;: &quot;https://api.github.com/users/removeif/orgs&quot;, &quot;repos_url&quot;: &quot;https://api.github.com/users/removeif/repos&quot;, &quot;events_url&quot;: &quot;https://api.github.com/users/removeif/events{/privacy}&quot;, &quot;received_events_url&quot;: &quot;https://api.github.com/users/removeif/received_events&quot;, &quot;type&quot;: &quot;User&quot;, &quot;site_admin&quot;: false }, &quot;created_at&quot;: &quot;2019-09-12T10:37:34Z&quot;, &quot;updated_at&quot;: &quot;2019-09-12T10:37:34Z&quot;, &quot;author_association&quot;: &quot;OWNER&quot;, &quot;body&quot;: &quot;&gt; 哇 大佬你博客弄的好厉害啊 可以指点指点吗\\n&gt;&gt; @xuelangjing 还好吧😂，简简单单的，可以多看下网页上的源码，有什么问题可以讨论讨论哦&quot; }] 博客中目前有两个页面使用,根据个人的需要放到各自的位置吧。 首页热门推荐 还有个最新评论页： 扩展一个方法上面的实例程序，每个issue（因为我的每个issue关联一个文章链接）只取了一条最新的评论，假如每个issue下有两个都是最新的评论，而我也不管是不是同一个issue下的评论，获取所有的最新评论，还有一个方法比较好用。 List comments in a repository1GET /repos/:owner/:repo/issues/comments By default, Issue Comments are ordered by ascending ID. 和上面一样，但是以下参数就不一样了 Name Type Description sort string Either created or updated. Default: created direction string Either asc or desc. Ignored without the sort parameter. since string Only comments updated at or after this time are returned. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. 多了排序字段和排序方式，也有per和per_page，这是相当的有用啊 扩展方法：请求接口地址示例1https://api.github.com/repos/removeif/blog_comment/issues/comments?sort=updated&amp;direction=desc&amp;per_page=10&amp;page=1 返回结果 123456789101112131415161718192021222324252627282930313233343536[ { &quot;url&quot;: &quot;https://api.github.com/repos/removeif/blog_comment/issues/comments/530767913&quot;, &quot;html_url&quot;: &quot;https://github.com/removeif/blog_comment/issues/3#issuecomment-530767913&quot;, &quot;issue_url&quot;: &quot;https://api.github.com/repos/removeif/blog_comment/issues/3&quot;, &quot;id&quot;: 530767913, &quot;node_id&quot;: &quot;MDEyOklzc3VlQ29tbWVudDUzMDc2NzkxMw==&quot;, &quot;user&quot;: { &quot;login&quot;: &quot;removeif&quot;, &quot;id&quot;: 10427139, &quot;node_id&quot;: &quot;MDQ6VXNlcjEwNDI3MTM5&quot;, &quot;avatar_url&quot;: &quot;https://avatars1.githubusercontent.com/u/10427139?v=4&quot;, &quot;gravatar_id&quot;: &quot;&quot;, &quot;url&quot;: &quot;https://api.github.com/users/removeif&quot;, &quot;html_url&quot;: &quot;https://github.com/removeif&quot;, &quot;followers_url&quot;: &quot;https://api.github.com/users/removeif/followers&quot;, &quot;following_url&quot;: &quot;https://api.github.com/users/removeif/following{/other_user}&quot;, &quot;gists_url&quot;: &quot;https://api.github.com/users/removeif/gists{/gist_id}&quot;, &quot;starred_url&quot;: &quot;https://api.github.com/users/removeif/starred{/owner}{/repo}&quot;, &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/removeif/subscriptions&quot;, &quot;organizations_url&quot;: &quot;https://api.github.com/users/removeif/orgs&quot;, &quot;repos_url&quot;: &quot;https://api.github.com/users/removeif/repos&quot;, &quot;events_url&quot;: &quot;https://api.github.com/users/removeif/events{/privacy}&quot;, &quot;received_events_url&quot;: &quot;https://api.github.com/users/removeif/received_events&quot;, &quot;type&quot;: &quot;User&quot;, &quot;site_admin&quot;: false }, &quot;created_at&quot;: &quot;2019-09-12T10:37:34Z&quot;, &quot;updated_at&quot;: &quot;2019-09-12T10:37:34Z&quot;, &quot;author_association&quot;: &quot;OWNER&quot;, &quot;body&quot;: &quot;&gt; 哇 大佬你博客弄的好厉害啊 可以指点指点吗\\n&gt;&gt; @xuelangjing 还好吧😂，简简单单的，可以多看下网页上的源码，有什么问题可以讨论讨论哦&quot; }, { ... } ] 总结此扩展方法优点：对于不在乎issue数量，只在乎最新评论的就比较适用，能够精准拿出前10条，很赞不足：一个issue下多个最新评论，如果想要显示的最新评论列表还包括文章标题，看起来可能不太好看，很多重复，但是看个人需要吧 注意事项，采坑环节 对应接口的请求限制，目前接口有请求的限制，所以使用中不能频繁请求，调试的时候一会儿又限制，一会儿又限制比较麻烦，限制十几分钟之后就解除了。 对于页面中，一般很多个地方可能都需要展示这个列表，所以不能每次都去请求，必须缓存起来，一般缓存到本地，我的是存的cookie中，十分钟去请求一次，所以调好后一般不会出现限制情况。但是马上评论了的就看不到，有10分钟的延迟，不过也还好。 对于如果issue以及评论太多的情况，尽量的少请求，比如上面的分页优化，取最后一条。以及页面中请求时做出异步请求的方式，不要阻止其他元素的渲染。 本人主要做后端，对前端的set/排序不太熟悉，上面实现排序代码比较繁琐😂，如果有什么更好的方法，麻烦也告知一下，互相学习共同进步。","link":"/Blog/%E5%8D%9A%E5%AE%A2%E4%B8%ADgitalk%E6%9C%80%E6%96%B0%E8%AF%84%E8%AE%BA%E7%9A%84%E8%8E%B7%E5%8F%96.html"},{"title":"英语语法-基本语法","text":"五种句型学习语法：分析句子=&gt;理清句子成分=&gt;理清句子关系 句子基本结构：主语部分+谓语部分（名词+动词） 五种句型： 主 谓 表 I am a Webaholic 主 谓 Internet dating hurts 主 谓 宾 I like chatting online 主 谓 间宾 主宾 Chatting on the internet brings me a lot of fun 主 谓 宾 宾补 We can call Internet addicts a Webaholic 关键在于谓语动词：动词构成了一个句子的骨架 1 主语+系动词+主语补足语（表语） 系动词（Linking Verb） 作用：无具体动作，仅起连接作用； 后面所接成分：说明主语特点性质特征 种类：be动词（am is are） ​ look sound smell taste feel seem appear become turn 表语：名词 or 形容词 2 主语+谓语（+状语） 不及物动词（Intransitive Verb）vi 特点：主语自身可以完成，不需要作用对象 习惯：带状语（修饰动作的成分） 3 主语+谓语+宾语 及物动词（Transitive Verb）vt 作用；：说明主语动作作用对象（宾语：主语动作承受对象） 4 主语+谓语+间宾+直宾 双宾动词（Dative Verb） 特点：后面成分有人（间接宾语[接受者]）又有物（直接宾语[承受者]） 5 主语+谓语+宾语+宾语补足语 宾补动词（Factitive Verb） 6 区分双宾语和复合宾语 在间接宾语后加上be动词，若能成句，则是补足语。 动词种类 句型 Linking verb 主+系+表 Intransitive Verb 主+谓 Transitive Verb 主+谓+宾 Transitive Verb with direct object and indirect object 主+谓+间宾+直宾 Transitive Verb with direct object and object complement 主+谓+宾+宾补 动词分类1 实义动词（Notional Verb） 特点： 词义：完整 作用：能独立充当谓语 分类：助动词和情态动词以外的动词 2 助动词（Auxiliary Verb） 特点： 词义：不完整 作用：无法独立充当谓语 ​ 必须和实义动词连用，构成各种时态、语态、语气、否定、疑问 分类： Be: am, is, are, was, were, been, being Do: does, did Have: has, had, having 助动词 变化形式 功能 例句 Be am, is, are, was, were, been, being 帮助构成进行时态 I am studying grammar.He is playing football. 帮助构成被动语态 I was cheated. Do Does, did 帮助实义动词构成否定 I do not like English. 帮助实义动词构成疑问 Do you like English? Have Has, had, having 帮助构成完成时态 I have studied English for 3 years be do have可作实义动词又可作助动词 例句 词义 词性及作用 be I am a student “是” 系动词, 作谓语 I am studying grammar 无词义 助动词, 构成进行时 have I have two brothers “有” 实义动词, 作谓语 I have studied English for 3 years 无词义 助动词, 构成完成时 do I often do my homework at home “做” 实义动词, 作谓语 I do not like English 无词义 助动词, 构成否定 3 情态动词(Modal Verb) 特点： 词义：有词义，表示可能、建议、愿望、必要、允许、能力、怀疑、表示说话者对某种行为或状态的看法或态度 作用：无法独立充当谓语，必须和实义动词一起构成复合谓语 常见： can/could may/might must shall/should will/would have to ought to used to need/dare 句子的变化1 陈述句否定 谓语动词含有助动词或情态动词 变形：助动词或情态动词后 + not ​ 例：He is a teacher. He is not a teacher. ​ I can swim. I cannot swim. ​ He will come to the party he will not come to the party 谓语动词是实义动词 变形：借助助动词do not来构成，第三人称用does + not + 动词原形，过去式did + not ​ 例：I like English. I do not like English. ​ He likes English.. He does not like English. ​ There are some dogs. There aren’t any dogs. 否定的缩写 I am Am not Null We/You/They are Are not Aren’t She/He/It is Is not Isn’t I/He/She/It was Was not Wasn’t We/You/They were Were not Weren’t I/You/We/They do Do not Don’t He/She/It does Does not Doesn’t Did Did not Didn’t I/You/We/They have Have not Haven’t He/She/It has Has not Hasn’ Had Had not Hadn’t 情态动词 Will Will not Won’t Would Would not Wouldn’t Shall Shall not Shan’t Should Should not Shouldn’t Can Cannot Can’t Could Could not Couldn’t May May not Null Might Might not Mightn’t Must Must not Mustn’t 其他词变化：and-&gt;or already-&gt;yet both-&gt;either some-&gt;any 祈使句： 祈使句前+don’t Don’t open the door. 不定式： 不定式前+not She asks the boy not to play in the street. 2 一般疑问句 谓语动词含有助动词或情态动词 变形：助动词 or 情态动词移至句首 ​ 例：He is a teacher. Is he a teacher? Yes, he is/No, he isn’t 谓语动词是实义动词 变形：加do does did于句首，实义动词变原形 ​ 例：He likes English. Does he like English? Yes, he does/No, he doesn’t. ​ I like English. Do you like English? Yes, I do/No, I don’t. 3 特殊疑问句 不接名词连用的疑问句 对人提问：who ​ He can sing in English. Who can sing in English. ​ I saw him at the party last night. Who did you see at the party last night? 对事或物：what ​ I like English. What do you like? ​ I am studying English grammar. What are you doing? ​ I am studying English grammar. What are you studying? ​ I’d like to go swimming tomorrow. What would you like to do tomorrow? 对时间提问：when ​ I was born in 1980. When were you born? 对地点提问：where ​ He lives in Beijing. Where does he live? 对方式提问：how ​ He goes to school by bus. How does he go to school? 对原因提问：why ​ I often study at the library because it’s quiet. Why do you often study at the library? 接名词连用的疑问词 Which： ​ Could you lend me your pen? ​ Sure. I have two pens. This pen has black ink. That pen has red ink. ​ Which pen/Which one/Which do you want? ​ That red one. Thanks. ​ Which也可不接名词。这时which用作代词。 Whose： ​ 必须接名词 ​ This is his book. Whose book is this? ​ I borrowed Jack’s car last night. Whose car did you borrow last night? How用法详解 单独使用：对动作方式的提问 ​ How do you go to work? ​ I drive/ By car/I take a taxi/I take a bus/By bus. ​ How did he break his leg? ​ He fell off the ladder. 和形容词 or 副词连用 ​ How old are you? ​ How tall is he? ​ How big is your new house? ​ How far is it from your home to school? ​ How well does he speak English? ​ How quickly can you get here? 对频率提问：how often/how many times? I write to my parents once a month. How often do you write to your parents? I go shopping twice a week. How often do you go shopping?/How many times a week do you go shopping? 其他频率短语 Every Once a —&gt; day/week/month/year Twice a Three times 一般时态和现在时态The present simple tense is used to express a general truth or fact, or an action that occurs regularly or habitually. Generally, the present simple tense verb conveys a sense of permanence. Truth or fact The sun rises in the east and sets in the west. The earth moves around the sun. An action that occurs regularly or habitually I often spend two hours reading English in the morning. Classes begin at nine in the morning 1.事实 The world is round. 2.经常性，习惯性动作或状态 He doesn’t work hard. (1)常连用频率副词(助动词后，实义动词前) ​ always frequently usually sometimes generally occasionally often ​ never seldom rarely 3.以there或here开头句子中，表正在发生的短暂动作 Here comes your wife= your wife is coming. There goes our bus; we’ll have to wait for the next one. 4.条件状语(if unless)，时间状语(when as soon as before after )从句中，表示将来动作 Please let me know when he comes back. What are you going to do when you leave school? I’ll be glad if she comes over to visit me. The past simple tense is used to express a completed action which took place eat a specified time in the past. The specified time is either stated or implied. A completed action I saw him in the library yesterday morning. I began to learn English ten years ago. A past action that occurred regularly or habitually I slept for eight hours last night. She lived in our town for three years,but now she is living in Beijing. 1.过去动作或状态 He was late for school this morning. I bought this computer three years ago. 2.过去一段时间一直持续或反复发生的动作 I lived in the country for ten years. He used to do morning exercises. He took a walk after supper when he was alive. The future simple tense is used to express an action that will occur at some time in the future. Will or Be Going To can be used to express sort of certainty. According to the weather report, it will be windy tomorrow.说话人认为将要发生 According to the weather report, it is going to be windy tomorrow.根据明显迹象判断 Be Going To is used to express a definite plan. I have bought a computer and I’m going to learn the computer science. Will is used to express a willingness. The telephone is ringing; I will answer it. Will(说话时做出的决定) Be Going To(对话前做出的决定) 进行时态时态构成 助动词+进行分词 be+doing 意义 该时刻(具体时间，另一个具体活动背景下)，活动正在进行 现在进行时 1.说话此刻正在进行 What program are you watching? He is not available now. He is talking on another phone. 2.现阶段正在持续的动作 what are you doing these days? I am learning the usage of verb tenses. 3.最近的将来已定的安排(计划 安排做) What are you doing on Saturday night? I’m doing some shopping with Jane. I am taking a makeup test tomorrow. 4.与always forever continually constantly等连用，表示抱怨，厌烦 Jack is always borrowing money and forgetting to pay you back. He’s continually asking me for money. 过去进行时1.过去特定时刻发生的事情 I was discussing my thesis with my director at this time last night. What were you doing at 10 o’clock last night? I was having dinner with my friends 2.过去进行时(背景)+一般过去时(背景下发生的短暂动作或状态) The phone rang while I was having my bath, as usual. I was watching TV when the phone rang. 将来进行时(will be doing)1.将来某特定时刻活动正在进行 I’ll be lying on a beach in Sanya this time tomorrow. Don’t telephone after eight tomorrow. I’ll be having a meeting. 名词名词短语(名词与它前面的修饰语) These red roses are for you. I have three close friends. I really need a new computer. 1.功能 ​ 主语 宾语(介词不能单独使用，后面所接宾语) 表语 2.修饰语 ​ 限定词: 泛指，特指，定量，不定量(these three a the my that)，冠 词(a an the) ​ 形容词: red close new best small 3.位置 ​ 限定词在形容词前: 限定词+形容词+名词: three red roses. 名词可数与不可数名词分类 专有名词 Paris, the United States, Bill Gates 普通名词​ 可数名词 ​ 个体名词 student tree hospital house piano ​ 集体名词 team committee police group family ​ 不可数名词 ​ 物质名词 paper water cotton air ​ 抽象名词 birth happiness evolution technology hope ​ 简单名词 story student teacher ​ 复合名词 girlfriend roommate mother-in-law 相对性 paper ​ I need some paper to write a letter(纸 不可数) ​ I have a term paper to write on weekends(论文 可数) ​ I bought a paper(报纸 可数) ​ room(空间 不可数; 房间 可数) 可数名词与不可数名词比较 可数名词: 前面可以+ a or an or 数词(two) 不可数名词: 不可+ 变形及读音 1.末尾+s(清辅音s 浊辅音z) 2.-s -x -ch -sh结尾+es读[iz] 若ch发音为[k]时+s (stomach/stomachs) 3.辅音字母+y: 变y-&gt;ies 读[iz]; 元音字母+y: 直接+s 读[z] 4.特殊变化 ​ 1)o结尾 读[z] ​ potato/potatoes tomato/tomatoes hero/heroes piano/pianos photo/photos radio/radios ​ 2)f或fe结尾 f, fe-&gt;ves 读[s] or 直接+读[s] ​ half/halves knife/knives leaf/leaves life/lives ​ belief/beliefs chief/chiefs cliff/cliffs proof/proofs roof/roofs ​ 3)单复数同形 ​ aircraft deer giraffe sheep ​ 4)man/woman 构成的复合名词(都变) ​ man teacher/men teachers woman pilot/women pilots ​ 5)名词+介词或介词短语构成的复合名词(名词变) ​ passer-by/passers-by looker-on/lookers-on 不可数名词1.物质名词不可数​ beer blood coffee cream gasoline honey juice milk oil tea water wine ​ bread butter cheese ice ice-cream meat beef chicken fish chalk copper cotton glass gold iron ​ air fog oxygen smoke 2.抽象名词​ advice anger beauty confidence fun happiness health honesty informaation love luch peace 3.总称名词不可数​ furniture fruit jewelry luggage equipment poetry machinery 不可数名词的度量 1.piece ​ advice bread baggage chalk equipment furniture information jewelry luggage music news 2.bottle cup drop glass ​ beer blood coffee milk tea water wine 3.else ​ a loaf of bread a tube of toothpaste a pack of cigarette a slice of meat 名词所有格 1.单数名词后+’s 2.复数名词后+s’ ;复数型名词后+’s ​ her friends’ money ​ the children’s Day 3.复合名词后+’s ​ my father-in-law’ s company ​ everyone else’ s viewpoints ​ Henry the Eighth’ s wives ​ the President of America’ s secretary 4.and连接的并列名词: 共有情况: 最后+’s ; 各自所有情况: 每个名词后+’s 5.重量 度量 价值 ​ two pounds’ weight a ton’s weight a ton’ s steel two dollars’ worth of sugar 6.省略 ​ 1)前文以出现，避免重复 ​ This bike is mine, not Michael’s ​ 2)表示店铺或教堂(要加the) ​ at the baker’s at the butcher’s at the chemist’s at the doctor’s ​ 3)人名后的所有格省去名词表示住宅 ​ go to my sister’s I called at my uncle’s yesterday. 7.of所有格的其他关系 ​ 1)主谓关系 ​ the visitor’s departure the teacher’s request the growth of agriculture ​ 2)动宾关系 ​ the children’s education the boy’s punishment the discussion of the plan 英语学习-语法系列github仓库，欢迎收藏star 参考文章:参考链接","link":"/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html"},{"title":"Vim基本入门操作","text":"简介 Vim（Vi[Improved]）编辑器是功能强大的跨平台文本文件编辑工具，继承自Unix系统的Vi编辑器，支持Linux/Mac OS X/Windows系统，利用它可以建立、修改文本文件。进入Vim编辑程序，可以在终端输入下面的命令： 1$vim [filename] 其中filename是要编辑器的文件的路径名。如果文件不存在，它将为你建立一个新文件。Vim编辑程序有三种操作模式，分别称为 编辑模式、插入模式 和 命令模式，当运行Vim时，首先进入编辑模式。 编辑模式Vim编辑方式的主要用途是在被编辑的文件中移动光标的位置。一旦光标移到到所要的位置，就可以进行剪切和粘贴正文块，删除正文和插入新的正文。当完成所有的编辑工作后，需要保存编辑器结果，退出编辑程序回到终端，可以发出ZZ命令，连续按两次大写的Z键。 跳转如果键盘上有上、下、左、右箭头的导航键，就由这些键来完成光标的移动。另外，可以用下面的键完成同样的 按字符移动 功能： 1234k 上移；j 下移；h 左移；l 右移。 上面这４个键将光标位置每次移动一行或一个 字符 。Vim还提供稍大范围移动光标的命令： 12ctrl+f 在文件中前移一页（相当于 page down）；ctrl+b 在文件中后移一页（相当于 page up）； 更大范围的移动：gg 起始位置, G最后一行,g_本行最后 123456789101112* 当光标停留在一个单词上，* 键会在文件内搜索该单词，并跳转到下一处；# 当光标停留在一个单词上，# 在文件内搜索该单词，并跳转到上一处；(/) 移动到 前/后 句 的开始；{/} 跳转到 当前/下一个 段落 的开始。g_ 到本行最后一个不是 blank 字符的位置。fa 到下一个为 a 的字符处，你也可以fs到下一个为s的字符。t, 到逗号前的第一个字符。逗号可以变成其它字符。3fa 在当前行查找第三个出现的 a。F/T 和 f 和 t 一样，只不过是相反方向;gg 将光标定位到文件第一行起始位置；G 将光标定位到文件最后一行起始位置；NG或Ngg 将光标定位到第 N 行的起始位置。 在屏幕中找到需要的 一页 时，可以用下面的命令快速移动光标：H起始行，M中间行，L最后行 123H 将光标移到屏幕上的起始行（或最上行）；M 将光标移到屏幕中间；L 将光标移到屏幕最后一行。 同样需要注意字母的大小写。H 和 L 命令还可以加数字。如 2H 表示将光标移到屏幕的第２行，3L 表示将光标移到屏幕的倒数第3行。 当将光标移到所要的行是，行内移动 光标可以用下面的命令来实现：&amp;末尾，^行头 123456w 右移光标到下一个字的开头；e 右移光标到一个字的末尾；b 左移光标到前一个字的开头；0 数字０，左移光标到本行的开始；$ 右移光标，到本行的末尾；^ 移动光标，到本行的第一个非空字符。 2.2 搜索匹配和许多先进的编辑器一样，Vim 提供了强大的字符串搜索功能。要查找文件中指定字或短语出现的位置，可以用Vim直接进行搜索，而不必以手工方式进行。搜索方法是：键入字符 / ，后面跟以要搜索的字符串，然后按回车键。编辑程序执行正向搜索（即朝文件末尾方向），并在找到指定字符串后，将光标停到该字符串的开头；键入 n 命令可以继续执行搜索，找出这一字符串下次出现的位置。用字符 ? 取代 / ，可以实现反向搜索。例如：/str ，n下次出现，n上次出现 1234/str1 正向搜索字符串 str1；n 继续搜索，找出 str1 字符串下次出现的位置；N 继续搜索，找出 str1 字符串上一次出现的位置；?str2 反向搜索字符串 str2 。 无论搜索方向如何，当到达文件末尾或开头时，搜索工作会循环到文件的另一端并继续执行。 Vim中执行搜索匹配最强大的地方是结合 正则表达式 来搜索，后续将会介绍。 2.3 替换和删除Vim常规的删除命令是 d、 x (前者删除 行 ，后者删除 字符 ),结合Vim的其他特性可以实现基础的删除功能。将光标定位于文件内指定位置后，可以用其他字符来替换光标所指向的字符，或从当前光标位置删除一个或多个字符或一行、多行。例如： 123456789101112131415rc 用 c 替换光标所指向的当前字符；nrc 用 c 替换光标所指向的前 n 个字符；5rA 用 A 替换光标所指向的前 5 个字符；x 删除光标所指向的当前字符；nx 删除光标所指向的前 n 个字符；3x 删除光标所指向的前 3 个字符；dw 删除光标右侧的字；ndw 删除光标右侧的 n 个字；3dw 删除光标右侧的 3 个字；db 删除光标左侧的字；ndb 删除光标左侧的 n 个字；5db 删除光标左侧的 5 个字；dd 删除光标所在行，并去除空隙；ndd 删除（剪切） n 行内容，并去除空隙；3dd 删除（剪切） 3 行内容，并去除空隙； 其他常用的删除命令有：d$删到行尾，d0删到行首，J合并下行 123d$ 从当前光标起删除字符直到行的结束；d0 从当前光标起删除字符直到行的开始；J 删除本行的回车符（CR），并和下一行合并。 Vim常规的替换命令有 c 和 s ，结合Vim的其他特性可以实现基础的替换功能，不过替换命令执行以后，通常会由 编辑模式 进入 插入模式 ： 12345678910111213s 用输入的正文替换光标所指向的字符；S 删除当前行，并进入插入模式；ns 用输入的正文替换光标右侧 n 个字符；nS 删除当前行在内的 n 行，并进入插入模式；cw 用输入的正文替换光标右侧的字；cW 用输入的正文替换从光标到行尾的所有字符（同 c$ )；ncw 用输入的正文替换光标右侧的 n 个字；cb 用输入的正文替换光标左侧的字；ncb 用输入的正文替换光标左侧的 n 个字；cd 用输入的正文替换光标的所在行；ncd 用输入的正文替换光标下面的 n 行；c$ 用输入的正文替换从光标开始到本行末尾的所有字符；c0 用输入的正文替换从本行开头到光标的所有字符。 2.4 复制粘贴从正文中删除的内容（如字符、字或行）并没有真正丢失，而是被剪切并复制到了一个内存缓冲区中。用户可将其粘贴到正文中的指定位置。完成这一操作的命令是：p粘到后面，P粘到前面 12p 小写字母 p，将缓冲区的内容粘贴到光标的后面；P 大写字母 P，将缓冲区的内容粘贴到光标的前面。 如果缓冲区的内容是字符或字，直接粘贴在光标的前面或后面；如果缓冲区的内容为整行正文，执行上述粘贴命令将会粘贴在当前光标所在行的上一行或下一行。 注意上述两个命令中字母的大小写。Vim 编辑器经常以一对大、小写字母（如 p 和 P）来提供一对相似的功能。通常，小写命令在光标的后面进行操作，大写命令在光标的前面进行操作。 有时需要复制一段正文到新位置，同时保留原有位置的内容。这种情况下，首先应当把指定内容复制（而不是剪切）到内存缓冲区。完成这一操作的命令是：yy 复制一行，nyy 复制n行 12345yy 复制当前行到内存缓冲区；nyy 复制 n 行内容到内存缓冲区；5yy 复制 5 行内容到内存缓冲区；“+y 复制 1 行到操作系统的粘贴板；“+nyy 复制 n 行到操作系统的粘贴板。 2.5 撤销和重复在编辑文档的过程中，为消除某个错误的编辑命令造成的后果，可以用撤消命令。另外，如果用户希望在新的光标位置重复前面执行过的编辑命令，可用重复命令。u撤销前一条，.重复最后一条命令 12u 撤消前一条命令的结果；. 重复最后一条修改正文的命令。 3. 插入模式3.1 进入插入模式在编辑模式下正确定位光标之后，可用以下命令切换到插入模式：i左，a右，o下一行，O上一行，I光标开头，A末尾 123456i 在光标左侧插入正文a 在光标右侧插入正文o 在光标所在行的下一行增添新行O 在光标所在行的上一行增添新行I 在光标所在行的开头插入A 在光标所在行的末尾插入 3.2 退出插入模式退出插入模式的方法是，按 ESC 键或组合键 Ctrl+[ ，退出插入模式之后，将会进入编辑模式 。 4. 命令模式在Vim的命令模式下，可以使用复杂的命令。在编辑模式下键入 : ，光标就跳到屏幕最后一行，并在那里显示冒号，此时已进入命令模式。命令模式又称 末行模式 ，用户输入的内容均显示在屏幕的最后一行，按回车键，Vim 执行命令。 4.1 打开、保存、退出在已经启动的Vim中打开一个文件需要用 :e 命令： 1:e path_to_file/filename 保存当前编辑的文件需要用 :w 命令（单词 write 的缩写）： 1:w 将当前文件另存为 file_temp 则： 1:w file_temp 在编辑模式下可以用 ZZ 命令退出Vim编辑程序，该命令保存对正文所作的修改，覆盖原始文件。如果只需要退出编辑程序，而不打算保存编辑的内容，可用下面的命令： 12: q 在未作修改的情况下退出；: q! 放弃所有修改，退出编辑程序。 保存并退出则可以讲两条命令结合起来使用（注意命令顺序，先保存，后退出）： 1:wq 4.2 行号与文件编辑中的每一行正文都有自己的行号，用下列命令可以移动光标到指定行（效果与 编辑模式 下的 ngg 或 nG 相同）： 1: n 将光标移到第 n 行 命令模式下，可以规定命令操作的行号范围。数值用来指定绝对行号；字符“.”表示光标所在行的行号；字符符“$”表示正文最后一行的行号；简单的表达式，例如“.+5”表示当前行往下的第 5 行。例如： 1234567:345 将光标移到第 345 行:345w file 将第 345 行写入 file 文件:3,5w file 将第 3 行至第 5 行写入 file 文件:1,.w file 将第 1 行至当前行写入 file 文件:.,$w file 将当前行至最后一行写入 file 文件:.,.+5w file 从当前行开始将 6 行内容写入 file 文件:1,$w file 将所有内容写入 file 文件，相当于 :w file 命令 在命令模式下，允许从文件中读取正文，或将正文写入文件。例如： 12345678:w 将编辑的内容写入原始文件，用来保存编辑的中间结果:wq 将编辑的内容写入原始文件并退出编辑程序（相当于 ZZ 命令）:w file 将编辑的内容写入 file 文件，保持原有文件的内容不变:a,bw file 将第 a 行至第 b 行的内容写入 file 文件:r file 读取 file 文件的内容，插入当前光标所在行的后面:e file 编辑新文件 file 代替原有内容:f file 将当前文件重命名为 file:f 打印当前文件名称和状态，如文件的行数、光标所在的行号等 4.3 字符串搜索在 编辑模式 讲过字符串的搜索，此处的 命令模式 也可以进行字符串搜索，给出一个字符串，可以通过搜索该字符串到达指定行。如果希望进行正向搜索，将待搜索的字符串置于两个 / 之间；如果希望反向搜索，则将字符串放在两个 ? 之间。例如： 1234:/str/ 正向搜索，将光标移到下一个包含字符串 str 的行:?str? 反向搜索，将光标移到上一个包含字符串 str 的行:/str/w file 正向搜索，并将第一个包含字符串 str 的行写入 file 文件:/str1/,/str2/w file 正向搜索，并将包含字符串 str1 的行至包含字符串 str2 的行写 4.4 Vim中的正则表达式当给Vim指定搜索字符串时，可以包含具有特殊含义的字符。包含这些特殊字符的搜索字符串称为正则表达式（Regular Expressions）。例如，要搜索一行正文，这行正文的开头包含 struct 字。下面的命令做不到这一点： 1:/struct/ 因为它只找出在行中任意位置包含 struct的第一行，并不一定在行的开始包含 struct 。解决问题的办法是在搜索字符串前面加上特殊字符^： 1:/^struct/ ^ 字符比较每行开头的字符串。所以上面的命令表示：找出以字符串 struct 开头的行。 也可以用类似办法在搜索字符串后面加上表示行的末尾的特殊字符 $ 来找出位于行末尾的字： 1:/^struct/ 下表给出大多数特殊字符和它们的含义： 12345678910^ 放在字符串前面，匹配行首的字；$ 放在字符串后面，匹配行尾的字；\\&lt; 匹配一个字的字头；\\&gt; 匹配一个字的字尾；. 匹配任何单个正文字符；[str] 匹配 str 中的任何单个字符；[^str] 匹配任何不在 str 中的单个字符；[a-b] 匹配 a 到 b 之间的任一字符；* 匹配前一个字符的 0 次或多次出现；\\ 转义后面的字符。 简单介绍这么多，正则表达式知识可以参考 《正则表达式30分钟入门》:http://deerchao.net/tutorials/regex/regex.htm 另外，进阶的Vim正则表达式还有对Magic 模式的介绍，可以参考 《Vim正则表达式详解》: http://blog.csdn.net/salc3k/article/details/8222397 4.5 正文替换利用 :s 命令可以实现字符串的替换。具体的用法包括： 123456:%s/str1/str2/ 用字符串 str2 替换行中首次出现的字符串 str1:s/str1/str2/g 用字符串 str2 替换行中所有出现的字符串 str1:.,$ s/str1/str2/g 用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1:1,$ s/str1/str2/g 用字符串 str2 替换正文中所有出现的字符串 str1:g/str1/s//str2/g 功能同上:m,ns/str1/str2/g 将从m行到n行的str1替换成str2 从上述替换命令可以看到： 1`g` 放在命令末尾，表示对搜索字符串的每次出现进行替换,不止匹配每行中的第一次出现；不加 `g`，表示只对搜索字符串的首次出现进行替换；`g` 放在命令开头，表示对正文中所有包含搜索字符串的行进行替换操作; 1`s` 表示后面跟着一串替换的命令； 1`%` 表示替换范围是所有行，即全文。 另外一个实用的命令，在Vim中统计当前文件中字符串 str1 出现的次数，可用替换命令的变形： 1:%s/str1/&amp;/gn 4.6 删除正文在命令模式下，同样可以删除正文中的内容。例如： 12345678:d 删除光标所在行:3d 删除 3 行:.,$d 删除当前行至正文的末尾:/str1/,/str2/d 删除从字符串 str1 到 str2 的所有行:g/^\\(.*\\)$\\n\\1$/d 删除连续相同的行，保留最后一行:g/\\%(^\\1$\\n\\)\\@&lt;=\\(.*\\)$/d 删除连续相同的行，保留最开始一行:g/^\\s*$\\n\\s*$/d 删除连续多个空行，只保留一行空行:5,20s/^#//g 删除5到20行开头的 # 注释 总之，Vim的初级删除命令是用 d ，高级删除命令可以用 正则替换 的方式执行。 4.7 恢复文件Vim 在编辑某个文件时，会另外生成一个临时文件，这个文件的名称通常以 . 开头，并以 .swp 结尾。Vim 在正常退出时，该文件被删除，若意外退出，而没有保存文件的最新修改内容，则可以使用恢复命令 :recover 来恢复文件，也可以在启动Vim时用 -r 选项。 4.8 选项设置为控制不同的编辑功能，Vim 提供了很多内部选项。利用 :set 命令可以设置选项。基本语法为： 1:set option 设置选项 option 常见的功能选项包括： 123456autoindent 设置该选项，则正文自动缩进ignorecase 设置该选项，则忽略规则表达式中大小写字母的区别number 设置该选项，则显示正文行号ruler 设置该选项，则在屏幕底部显示光标所在行、列的位置tabstop 设置按 Tab 键跳过的空格数。例如 :set tabstop=n，n 默认值为 8mk 将选项保存在当前目录的 .exrc 文件中 4.9 Shell切换当处于编辑的对话过程中时，可能需要执行一些Linux命令。如果需要保存当前的结果，退出编辑程序，再执行所需的Linux命令，然后再回头继续编辑过程，就显得十分累赘。如果能在编辑的环境中运行Linux命令就要省事得多。在Vim中，可以用下面的命令来做到这一点： 1:!shell_command 执行完 shell_command 后回到Vim 这称为Shell切换。它允许执行任何可以在标准的Shell提示符下执行的命令。当这条命令执行完毕，控制返回给编辑程序。又可以继续编辑对话过程。 4.10 分屏与标签页分屏普通的Vim模式，打开一个Vim程序只能查看一个文件，如果想同时查看多个文件，就需要用到Vim分屏与标签页功能。 Vim的分屏，主要有两种方式：上下分屏（水平分屏）和左右分屏（垂直分屏），在命令模式分别敲入以下命令即可： :sp 上下分屏,:vsp左右分屏 12:split（可用缩写 :sp） 上下分屏；:vsplit（可用缩写 :vsp） 左右分屏。 另外，也可以在终端里启动vim时就开启分屏操作： 12vim -On file1 file2... 打开 file1 和 file2 ，垂直分屏vim -on file1 file2... 打开 file1 和 file2 ，水平分屏 理论上，一个Vim窗口，可以分为多个Vim屏幕，切换屏幕需要用键盘快捷键，命令分别有： 1234Ctrl+w+h 切换到当前分屏的左边一屏；Ctrl+w+l 切换到当前分屏的右边一屏；Ctrl+w+j 切换到当前分屏的下方一屏；Ctrl+w+k 切换到当前分屏的上方一屏。 即键盘上的h,j,k,l 四个Vim专用方向键，配合Ctrl键和w键（window的缩写），就能跳转到目标分屏。另外，也可以直接按 Ctrl+w+w 来跳转分屏，不过跳转方向则是在当前Vim窗口所有分屏中，按照逆时针方向跳转。 下面是改变尺寸的一些操作，主要是高度，对于宽度你可以使用 [Ctrl+W &lt;] 或是 [Ctrl+W &gt;] ，但这可能需要最新的版本才支持。 123Ctrl+W = 让所有的屏都有一样的高度；Ctrl+W + 增加高度；Ctrl+W - 减少高度。 标签页Vim的标签（Tab）页，类似浏览器的标签页，一个标签页打开一个Vim的窗口，一个Vim的窗口可以支持N个分屏。 在Vim中新建一个标签的命令是： 1:tabnew 如果要在新建标签页的同时打开一个文件，则可以在命令后面直接附带文件路径： 1:tabnew filename Vim中的每个标签页有一个唯一的数字序号，第一个标签页的序号是0，从左向右依次加一。关于标签页有一系列操作命令，简介如下： 1234567891011121314:tN[ext] 跳转到上一个匹配的标签:tabN[ext] 跳到上一个标签页:tabc[lose] 关闭当前标签页:tabdo 为每个标签页执行命令:tabe[dit] 在新标签页里编辑文件:tabf[ind] 寻找 'path' 里的文件，在新标签页里编辑之:tabfir[st] 转到第一个标签页:tabl[ast] 转到最后一个标签页:tabm[ove] N 把标签页移到序号为N位置:tabnew [filename] 在新标签页里编辑文件:tabn[ext] 转到下一个标签页:tabo[nly] 关闭所有除了当前标签页以外的所有标签页:tabp[revious] 转到前一个标签页:tabr[ewind] 转到第一个标签页 4.11 与外部工具集成Vim可以与许多外部程序集成，功能十分强大，比如 diff , ctags , sort , xxd 等等，下面选取几个简单介绍一下。 diffLinux命令 diff 用来对比两个文件的内容，不过对比结果显示在终端里，可读性比较差。结合Vim，在终端里可以直接输入命令 vimdiff，后面跟两个文件名作为参数： 1vimdiff file1 file2 即可在Vim里分屏显示两个文件内容的对比结果，对文件内容差异部分进行高亮标记，还可以同步滚动两个文件内容，更可以实时修改文件内容，方便程度和用户体验大大提高。 1vimdiff a.txt b.txt 如果直接给 -d 选项是一样的 1vim -d a.txt b.txt 除了在终端里开启vimdiff 功能，也可以在打开Vim后，在Vim的命令模式输入相关命令来开启 vimdiff 功能： 1:diffsplit abc.txt 如果你现在已经开启了一个文件，想Vim帮你区分你的文件跟 abc.txt 有什么区别，可以在Vim中用 diffsplit 的方式打开第二个文件，这个时 候Vim会用 split（分上下两屏）的方式开启第二个文件，并且通过颜色，fold来显示两个文件的区别 这样Vim就会用颜色帮你区分开2个文件的区别。如果文件比较大（源码）重复的部分会帮你折叠起来。 1:diffpatch filename 通过 :diffpatch 你的patch的文件名，就可以以当前文件加上你的patch来显示。vim会split一个新的屏，显示patch后的信息并且用颜色标明区别。 如果不喜欢上下对比，喜欢左右（比较符合视觉）可以在前面加 vert ，例如： 12:vert diffsplit abc.txt:vert diffpatch abc.txt 看完diff，用 :only 回到原本编辑的文件，觉得diff的讨厌颜色还是在哪里，只要用 :diffoff 关闭就好了。 还有个常用的diff中的就是 :diffu ,这个是 :diffupdate 的简写，更新的时候用。 Vim的diff功能显示效果如下所示： sortLinux命令 sort 可以对文本内容进行按行中的字符比较、排序，但在终端里使用 sort 命令处理文件，并不能实时查看文件内容。具体用法请自查手册。 xxdvim+xxd 是Linux下最常用的二进制文本编辑工具，xxd其实是Vim外部的一个转换程序，随Vim一起发布，在Vim里调用它来编辑二进制文本非常方便。 首先以二进制模式在终端里打开一个文件： 1vim -b filename Vim 的 -b 选项是告诉 Vim 打开的是一个二进制文件，不指定的话，会在后面加上 0x0a ，即一个换行符。 然后在Vim的命令模式下键入： 1:%!xxd 即可看到二进制模式显示出来的文本，看起来像这样： 1230000000: 1f8b 0808 39d7 173b 0203 7474 002b 4e49 ....9..;..tt.+NI 0000010: 4b2c 8660 eb9c ecac c462 eb94 345e 2e30 K,......b..4^.0 0000020: 373b 2731 0b22 0ca6 c1a2 d669 1035 39d9 7;'1.&quot;.....i.59 然后就可以在二进制模式下编辑该文件，编辑后保存，然后用下面命令从二进制模式转换到普通模式： 1:%!xxd -r 另外，也可以调整二进制的显示模式，默认是 2 个字节为一组，可以通过 g 参数调整每组字节数： 123:%!xxd -g 1 表示每1个字节为1组 :%!xxd -g 2 表示每2个字节为1组(默认) :%!xxd -g 4 表示每4个字节为1组 5. Vim配置最初安装的Vim功能、特性支持比较少，用起来比较费劲，想要稍微“好用”一点，需做一些初步的配置。Vim的配置主要分为Vim本身特性的配置和外部插件的配置两部分。 Vim的配置是通常是存放在用户主目录的 .vimrc 的隐藏文件中的。就Vim本身特性来说，基础的配置有编程语言语法高亮、缩进设置、行号显示、搜索高亮、TAB键设置、字体设置、Vim主题设置等等，稍微高级一些的有编程语言缩进、自动补全设置等，具体配置项可以自行查资料，全面详细的配置项介绍可以参考： 《Vim Options》： http://vimcdoc.sourceforge.net/doc/options.html#%27completeopt%27 6. Vim插件Vim“编辑器之神”的称号并不是浪得虚名，然而，这个荣誉的背后，或许近半的功劳要归功于强大的插件支持特性，以及社区开发的各种各样功能强大的插件。 平时开发人员常用插件主要是目录（文件）查看和管理、编程语言缩进与自动补全、编程语言Docs支持、函数跳转、项目管理等等，简单配置可以参考下面： 《Vim插件简单介绍》： http://blog.segmentfault.com/xuelang/1190000000630547 《手把手教你把Vim改装成一个IDE编程环境(图文)》： http://blog.csdn.net/wooin/article/details/1858917 《将Vim改造为强大的IDE》： http://www.cnblogs.com/zhangsf/archive/2013/06/13/3134409.html 当然，这些插件都是拜Vim本身的插件支持特性所赐。Vim为了支持丰富的第三方插件，自身定义了一套简单的脚本开发语言，供程序员自行开发自己所需要的插件，插件开发介绍可以参考： 《Writing Vim Plugins》： http://stevelosh.com/blog/2011/09/writing-vim-plugins/ 7. Vim完整文档 Vim官方文档：http://vimdoc.sourceforge.net/ Vim中文用户手册7_3.pdf ：http://pan.baidu.com/s/1jGzbTBo 文章来源 .","link":"/Git/Vim%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C.html"},{"title":"MyBatis二级缓存","text":"摘要我们在上一篇文章介绍了 MyBatis 的一级缓存的作用，如何开启，一级缓存的本质是什么，一级缓存失效的原因是什么？MyBatis 只有一级缓存吗？来找找答案吧！ MyBatis 二级缓存介绍 上一篇文章中我们介绍到了 MyBatis 一级缓存其实就是 SqlSession 级别的缓存，什么是 SqlSession 级别的缓存呢？一级缓存的本质是什么呢？以及一级缓存失效的原因？我希望你在看下文之前能够回想起来这些内容。 MyBatis 一级缓存最大的共享范围就是一个SqlSession内部，那么如果多个 SqlSession 需要共享缓存，则需要开启二级缓存，开启二级缓存后，会使用 CachingExecutor 装饰 Executor，进入一级缓存的查询流程前，先在CachingExecutor 进行二级缓存的查询，具体的工作流程如下所示 当二级缓存开启后，同一个命名空间(namespace) 所有的操作语句，都影响着一个 共同的 cache，也就是二级缓存被多个 SqlSession 共享，是一个全局的变量。当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。 二级缓存开启条件 二级缓存默认是不开启的，需要手动开启二级缓存，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的。开启二级缓存的条件也是比较简单，通过直接在 MyBatis 配置文件中通过 1&lt;settings&gt; &lt;setting name = &quot;cacheEnabled&quot; value = &quot;true&quot; /&gt;&lt;/settings&gt; 来开启二级缓存，还需要在 Mapper 的xml 配置文件中加入 标签 设置 cache 标签的属性 cache 标签有多个属性，一起来看一些这些属性分别代表什么意义 eviction: 缓存回收策略，有这几种回收策略 LRU - 最近最少回收，移除最长时间不被使用的对象 FIFO - 先进先出，按照缓存进入的顺序来移除它们 SOFT - 软引用，移除基于垃圾回收器状态和软引用规则的对象 WEAK - 弱引用，更积极的移除基于垃圾收集器和弱引用规则的对象 默认是 LRU 最近最少回收策略 flushinterval 缓存刷新间隔，缓存多长时间刷新一次，默认不清空，设置一个毫秒值 readOnly: 是否只读；true 只读 ，MyBatis 认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。MyBatis 为了加快获取数据，直接就会将数据在缓存中的引用交给用户。不安全，速度快。**读写(默认)**：MyBatis 觉得数据可能会被修改 size : 缓存存放多少个元素 type: 指定自定义缓存的全类名(实现Cache 接口即可) blocking：若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。 探究二级缓存 我们继续以 MyBatis 一级缓存文章中的例子为基础，搭建一个满足二级缓存的例子，来对二级缓存进行探究，例子如下(对 一级缓存的例子部分源码进行修改)： Dept.java //存放在共享缓存中数据进行序列化操作和反序列化操作 //因此数据对应实体类必须实现【序列化接口】并提供 无参数的构造方法 1public class Dept implements Serializable myBatis-config.xml 在myBatis-config 中添加开启二级缓存的条件 1&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; DeptDao.xml 还需要在 Mapper 对应的xml中添加 cache 标签，表示对哪个mapper 开启缓存 对应的二级缓存测试类如下： 12345678910111213141516171819202122232425262728293031323334353637public class MyBatisSecondCacheTest { private SqlSession sqlSession; SqlSessionFactory factory; @Before public void start() throws IOException { InputStream is = Resources.getResourceAsStream(&quot;myBatis-config.xml&quot;); SqlSessionFactoryBuilder builderObj = new SqlSessionFactoryBuilder(); factory = builderObj.build(is); sqlSession = factory.openSession(); } @After public void destory(){ if(sqlSession!=null){ sqlSession.close(); } } @Test public void testSecondCache(){ //会话过程中第一次发送请求，从数据库中得到结果 //得到结果之后，mybatis自动将这个查询结果放入到当前用户的一级缓存 DeptDao dao = sqlSession.getMapper(DeptDao.class); Dept dept = dao.findByDeptNo(1); System.out.println(&quot;第一次查询得到部门对象 = &quot;+dept); //触发MyBatis框架从当前一级缓存中将Dept对象保存到二级缓存 sqlSession.commit(); // 改成 sqlSession.close(); 效果相同 SqlSession session2 = factory.openSession(); DeptDao dao2 = session2.getMapper(DeptDao.class); Dept dept2 = dao2.findByDeptNo(1); System.out.println(&quot;第二次查询得到部门对象 = &quot;+dept2); }} 测试二级缓存效果，提交事务，sqlSession 查询完数据后，sqlSession2相同的查询是否会从缓存中获取数据。 测试结果如下： 通过结果可以得知，首次执行的SQL语句是从数据库中查询得到的结果，然后第一个 SqlSession 执行提交，第二个 SqlSession 执行相同的查询后是从缓存中查取的。 用一下这幅图能够比较直观的反映两次 SqlSession 的缓存命中 二级缓存失效的条件 与一级缓存一样，二级缓存也会存在失效的条件的，下面我们就来探究一下哪些情况会造成二级缓存失效 第一次SqlSession 未提交 SqlSession 在未提交的时候，SQL 语句产生的查询结果还没有放入二级缓存中，这个时候 SqlSession2 在查询的时候是感受不到二级缓存的存在的，修改对应的测试类，结果如下： 1234567891011121314@Testpublic void testSqlSessionUnCommit(){ //会话过程中第一次发送请求，从数据库中得到结果 //得到结果之后，mybatis自动将这个查询结果放入到当前用户的一级缓存 DeptDao dao = sqlSession.getMapper(DeptDao.class); Dept dept = dao.findByDeptNo(1); System.out.println(&quot;第一次查询得到部门对象 = &quot;+dept); //触发MyBatis框架从当前一级缓存中将Dept对象保存到二级缓存 SqlSession session2 = factory.openSession(); DeptDao dao2 = session2.getMapper(DeptDao.class); Dept dept2 = dao2.findByDeptNo(1); System.out.println(&quot;第二次查询得到部门对象 = &quot;+dept2);} 产生的输出结果： 更新对二级缓存影响 与一级缓存一样，更新操作很可能对二级缓存造成影响，下面用三个 SqlSession来进行模拟，第一个 SqlSession 只是单纯的提交，第二个 SqlSession 用于检验二级缓存所产生的影响，第三个 SqlSession 用于执行更新操作，测试如下： 1234567891011121314151617181920212223242526@Testpublic void testSqlSessionUpdate(){ SqlSession sqlSession = factory.openSession(); SqlSession sqlSession2 = factory.openSession(); SqlSession sqlSession3 = factory.openSession(); // 第一个 SqlSession 执行更新操作 DeptDao deptDao = sqlSession.getMapper(DeptDao.class); Dept dept = deptDao.findByDeptNo(1); System.out.println(&quot;dept = &quot; + dept); sqlSession.commit(); // 判断第二个 SqlSession 是否从缓存中读取 DeptDao deptDao2 = sqlSession2.getMapper(DeptDao.class); Dept dept2 = deptDao2.findByDeptNo(1); System.out.println(&quot;dept2 = &quot; + dept2); // 第三个 SqlSession 执行更新操作 DeptDao deptDao3 = sqlSession3.getMapper(DeptDao.class); deptDao3.updateDept(new Dept(1,&quot;ali&quot;,&quot;hz&quot;)); sqlSession3.commit(); // 判断第二个 SqlSession 是否从缓存中读取 dept2 = deptDao2.findByDeptNo(1); System.out.println(&quot;dept2 = &quot; + dept2);} 对应的输出结果如下 ​ 探究多表操作对二级缓存的影响 现有这样一个场景，有两个表，部门表dept（deptNo,dname,loc）和 部门数量表deptNum（id,name,num），其中部门表的名称和部门数量表的名称相同，通过名称能够联查两个表可以知道其坐标(loc)和数量(num)，现在我要对部门数量表的 num 进行更新，然后我再次关联dept 和 deptNum 进行查询，你认为这个 SQL 语句能够查询到的 num 的数量是多少？来看一下代码探究一下 12345678public class DeptNum { private int id; private String name; private int num; get and set...} 12345678910111213141516171819202122public class DeptVo { private Integer deptNo; private String dname; private String loc; private Integer num; public DeptVo(Integer deptNo, String dname, String loc, Integer num) { this.deptNo = deptNo; this.dname = dname; this.loc = loc; this.num = num; } public DeptVo(String dname, Integer num) { this.dname = dname; this.num = num; } get and set... toString()...} 12345678910public interface DeptDao { // ...其他方法 DeptVo selectByDeptVo(String name); DeptVo selectByDeptVoName(String name); int updateDeptVoNum(DeptVo deptVo);} 12345678910111213&lt;select id=&quot;selectByDeptVo&quot; resultType=&quot;com.mybatis.beans.DeptVo&quot;&gt; select d.deptno,d.dname,d.loc,dn.num from dept d,deptNum dn where dn.name = d.dname and d.dname = #{name}&lt;/select&gt;&lt;select id=&quot;selectByDeptVoName&quot; resultType=&quot;com.mybatis.beans.DeptVo&quot;&gt; select * from deptNum where name = #{name}&lt;/select&gt;&lt;update id=&quot;updateDeptVoNum&quot; parameterType=&quot;com.mybatis.beans.DeptVo&quot;&gt; update deptNum set num = #{num} where name = #{dname}&lt;/update&gt; DeptNum 数据库初始值： 12345678910111213141516171819202122/** * 探究多表操作对二级缓存的影响 */@Testpublic void testOtherMapper(){ // 第一个mapper 先执行联查操作 SqlSession sqlSession = factory.openSession(); DeptDao deptDao = sqlSession.getMapper(DeptDao.class); DeptVo deptVo = deptDao.selectByDeptVo(&quot;ali&quot;); System.out.println(&quot;deptVo = &quot; + deptVo); // 第二个mapper 执行更新操作 并提交 SqlSession sqlSession2 = factory.openSession(); DeptDao deptDao2 = sqlSession2.getMapper(DeptDao.class); deptDao2.updateDeptVoNum(new DeptVo(&quot;ali&quot;,1000)); sqlSession2.commit(); sqlSession2.close(); // 第一个mapper 再次进行查询,观察查询结果 deptVo = deptDao.selectByDeptVo(&quot;ali&quot;); System.out.println(&quot;deptVo = &quot; + deptVo);} 测试结果如下： 在对DeptNum 表执行了一次更新后，再次进行联查，发现数据库中查询出的还是 num 为 1050 的值，也就是说，实际上 1050 -&gt; 1000 ，最后一次联查实际上查询的是第一次查询结果的缓存，而不是从数据库中查询得到的值，这样就读到了脏数据。 解决办法 如果是两个mapper命名空间的话，可以使用 &lt;cache-ref&gt;来把一个命名空间指向另外一个命名空间，从而消除上述的影响，再次执行，就可以查询到正确的数据 二级缓存源码解析 源码模块主要分为两个部分：二级缓存的创建和二级缓存的使用，首先先对二级缓存的创建进行分析： 二级缓存的创建 二级缓存的创建是使用 Resource 读取 XML 配置文件开始的 1234InputStream is = Resources.getResourceAsStream(&quot;myBatis-config.xml&quot;);SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();factory = builder.build(is); 读取配置文件后，需要对XML创建 Configuration并初始化 123XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);return build(parser.parse()); 调用 parser.parse() 解析根目录 /configuration 下面的标签，依次进行解析 123456789public Configuration parse() { if (parsed) { throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;); } parsed = true; parseConfiguration(parser.evalNode(&quot;/configuration&quot;)); return configuration;} 12345678910111213141516171819202122private void parseConfiguration(XNode root) { try { //issue #117 read properties first propertiesElement(root.evalNode(&quot;properties&quot;)); Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;)); loadCustomVfs(settings); typeAliasesElement(root.evalNode(&quot;typeAliases&quot;)); pluginElement(root.evalNode(&quot;plugins&quot;)); objectFactoryElement(root.evalNode(&quot;objectFactory&quot;)); objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;)); reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;)); settingsElement(settings); // read it after objectFactory and objectWrapperFactory issue #631 environmentsElement(root.evalNode(&quot;environments&quot;)); databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;)); typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;)); mapperElement(root.evalNode(&quot;mappers&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e); }} 其中有一个二级缓存的解析就是 12mapperElement(root.evalNode(&quot;mappers&quot;)); 然后进去 mapperElement 方法中 123XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); mapperParser.parse(); 继续跟 mapperParser.parse() 方法 123456789101112public void parse() { if (!configuration.isResourceLoaded(resource)) { configurationElement(parser.evalNode(&quot;/mapper&quot;)); configuration.addLoadedResource(resource); bindMapperForNamespace(); } parsePendingResultMaps(); parsePendingCacheRefs(); parsePendingStatements();} 这其中有一个 configurationElement 方法，它是对二级缓存进行创建，如下 12345678910111213141516171819private void configurationElement(XNode context) { try { String namespace = context.getStringAttribute(&quot;namespace&quot;); if (namespace == null || namespace.equals(&quot;&quot;)) { throw new BuilderException(&quot;Mapper's namespace cannot be empty&quot;); } builderAssistant.setCurrentNamespace(namespace); cacheRefElement(context.evalNode(&quot;cache-ref&quot;)); cacheElement(context.evalNode(&quot;cache&quot;)); parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;)); resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;)); sqlElement(context.evalNodes(&quot;/mapper/sql&quot;)); buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing Mapper XML. Cause: &quot; + e, e); }} 有两个二级缓存的关键点 123cacheRefElement(context.evalNode(&quot;cache-ref&quot;));cacheElement(context.evalNode(&quot;cache&quot;)); 也就是说，mybatis 首先进行解析的是 cache-ref 标签，其次进行解析的是 cache 标签。 根据上面我们的 — 多表操作对二级缓存的影响 一节中提到的解决办法，采用 cache-ref 来进行命名空间的依赖能够避免二级缓存，但是总不能每次写一个 XML 配置都会采用这种方式吧，最有效的方式还是避免多表操作使用二级缓存 然后我们再来看一下cacheElement(context.evalNode(“cache”)) 这个方法 123456789101112131415private void cacheElement(XNode context) throws Exception { if (context != null) { String type = context.getStringAttribute(&quot;type&quot;, &quot;PERPETUAL&quot;); Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type); String eviction = context.getStringAttribute(&quot;eviction&quot;, &quot;LRU&quot;); Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction); Long flushInterval = context.getLongAttribute(&quot;flushInterval&quot;); Integer size = context.getIntAttribute(&quot;size&quot;); boolean readWrite = !context.getBooleanAttribute(&quot;readOnly&quot;, false); boolean blocking = context.getBooleanAttribute(&quot;blocking&quot;, false); Properties props = context.getChildrenAsProperties(); builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props); }} 认真看一下其中的属性的解析，是不是感觉很熟悉？这不就是对 cache 标签属性的解析吗？！！！ 上述最后一句代码 12builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props); 123456789101112131415161718192021public Cache useNewCache(Class&lt;? extends Cache&gt; typeClass, Class&lt;? extends Cache&gt; evictionClass, Long flushInterval, Integer size, boolean readWrite, boolean blocking, Properties props) { Cache cache = new CacheBuilder(currentNamespace) .implementation(valueOrDefault(typeClass, PerpetualCache.class)) .addDecorator(valueOrDefault(evictionClass, LruCache.class)) .clearInterval(flushInterval) .size(size) .readWrite(readWrite) .blocking(blocking) .properties(props) .build(); configuration.addCache(cache); currentCache = cache; return cache; } 这段代码使用了构建器模式，一步一步构建Cache 标签的所有属性，最终把 cache 返回。 二级缓存的使用 在 mybatis 中，使用 Cache 的地方在 CachingExecutor中，来看一下 CachingExecutor 中缓存做了什么工作，我们以查询为例 1234567891011121314151617181920212223@Overridepublic &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException { // 得到缓存 Cache cache = ms.getCache(); if (cache != null) { // 如果需要的话刷新缓存 flushCacheIfRequired(ms); if (ms.isUseCache() &amp;&amp; resultHandler == null) { ensureNoOutParams(ms, parameterObject, boundSql); @SuppressWarnings(&quot;unchecked&quot;) List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key); if (list == null) { list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); tcm.putObject(cache, key, list); // issue #578 and #116 } return list; } } // 委托模式，交给SimpleExecutor等实现类去实现方法。 return delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);} 其中，先从 MapperStatement 取出缓存。只有通过,或@CacheNamespace,@CacheNamespaceRef标记使用缓存的Mapper.xml或Mapper接口（同一个namespace，不能同时使用）才会有二级缓存。 如果缓存不为空，说明是存在缓存。如果cache存在，那么会根据sql配置(&lt;insert&gt;,&lt;select&gt;,&lt;update&gt;,&lt;delete&gt;的flushCache属性来确定是否清空缓存。 12flushCacheIfRequired(ms); 然后根据xml配置的属性useCache来判断是否使用缓存(resultHandler一般使用的默认值，很少会null)。 12if (ms.isUseCache() &amp;&amp; resultHandler == null) 确保方法没有Out类型的参数，mybatis不支持存储过程的缓存，所以如果是存储过程，这里就会报错。 12345678910private void ensureNoOutParams(MappedStatement ms, Object parameter, BoundSql boundSql) { if (ms.getStatementType() == StatementType.CALLABLE) { for (ParameterMapping parameterMapping : boundSql.getParameterMappings()) { if (parameterMapping.getMode() != ParameterMode.IN) { throw new ExecutorException(&quot;Caching stored procedures with OUT params is not supported. Please configure useCache=false in &quot; + ms.getId() + &quot; statement.&quot;); } } }} 然后根据在 TransactionalCacheManager 中根据 key 取出缓存，如果没有缓存，就会执行查询，并且将查询结果放到缓存中并返回取出结果，否则就执行真正的查询方法。 1234567List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);if (list == null) { list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); tcm.putObject(cache, key, list); // issue #578 and #116}return list; 是否应该使用二级缓存？ 那么究竟应该不应该使用二级缓存呢？先来看一下二级缓存的注意事项： 缓存是以namespace为单位的，不同namespace下的操作互不影响。 insert,update,delete操作会清空所在namespace下的全部缓存。 通常使用MyBatis Generator生成的代码中，都是各个表独立的，每个表都有自己的namespace。 多表操作一定不要使用二级缓存，因为多表操作进行更新操作，一定会产生脏数据。 如果你遵守二级缓存的注意事项，那么你就可以使用二级缓存。 但是，如果不能使用多表操作，二级缓存不就可以用一级缓存来替换掉吗？而且二级缓存是表级缓存，开销大，没有一级缓存直接使用 HashMap 来存储的效率更高，所以二级缓存并不推荐使用。 文章来源.","link":"/MySQL/MyBatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html"},{"title":"mysql-b+Tree索引","text":"索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。索引最形象的比喻就是图书的目录了。注意这里的大量，数据量大了索引才显得有意义，如果我想要在 [1,2,3,4] 中找到 4 这个数据，直接对全数据检索也很快，没有必要费力气建索引再去查找。 索引在 MySQL 数据库中分三类： B+ 树索引 Hash 索引 全文索引 我们今天要介绍的是工作开发中最常接触到的 InnoDB 存储引擎中的 B+ 树索引。要介绍 B+ 树索引，就不得不提二叉查找树，平衡二叉树和 B 树这三种数据结构。B+ 树就是从他们仨演化来的。 二叉查找树首先，让我们先看一张图： 从图中可以看到，我们为 user 表（用户信息表）建立了一个二叉查找树的索引。 图中的圆为二叉查找树的节点，节点中存储了键（key）和数据（data）。键对应 user 表中的 id，数据对应 user 表中的行数据。 二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。 如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下： 将根节点作为当前节点，把 12 与当前节点的键值 10 比较，12 大于 10，接下来我们把当前节点&gt;的右子节点作为当前节点。 继续把 12 和当前节点的键值 13 比较，发现 12 小于 13，把当前节点的左子节点作为当前节点。 把 12 和当前节点的键值 12 对比，12 等于 12，满足条件，我们从当前节点中取出 data，即 id=12，name=xm。 利用二叉查找树我们只需要 3 次即可找到匹配的数据。如果在表中一条条的查找的话，我们需要 6 次才能找到。 平衡二叉树上面我们讲解了利用二叉查找树可以快速的找到数据。但是，如果上面的二叉查找树是这样的构造： 这个时候可以看到我们的二叉查找树变成了一个链表。如果我们需要查找 id=17 的用户信息，我们需要查找 7 次，也就相当于全表扫描了。 导致这个现象的原因其实是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。 为了解决这个问题，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树了。 平衡二叉树又称 AVL 树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1。 下面是平衡二叉树和非平衡二叉树的对比： 由平衡二叉树的构造我们可以发现第一张图中的二叉树其实就是一棵平衡二叉树。 平衡二叉树保证了树的构造是平衡的，当我们插入或删除数据导致不满足平衡二叉树不平衡时，平衡二叉树会进行调整树上的节点来保持平衡。具体的调整方式这里就不介绍了。 平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。 B 树因为内存的易失性。一般情况下，我们都会选择将 user 表中的数据和索引存储在磁盘这种外围设备中。 但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量减少从磁盘中读取数据的次数。 另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。 如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。 如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块。 我们都知道平衡二叉树可是每个节点只存储一个键值和数据的。那说明什么？说明每个磁盘块仅仅存储一个键值和数据！那如果我们要存储海量的数据呢？ 可以想象到二叉树的节点将会非常多，高度也会极其高，我们查找数据时也会进行很多次磁盘 IO，我们查找数据的效率将会极低！ 为了解决平衡二叉树的这个弊端，我们应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的 B 树。 B 树（Balance Tree）即为平衡树的意思，下图即是一棵 B 树： 图中的 p 节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有，因为图的美观性，被省略了。 图中的每个节点称为页，页就是我们上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以我们这里叫做页更符合 MySQL 中索引的底层数据结构。 从上图可以看出，B 树相对于平衡二叉树，每个节点存储了更多的键值（key）和数据（data），并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的 B 树为 3 阶 B 树，高度也会很低。 基于这个特性，B 树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。 假如我们要查找 id=28 的用户信息，那么我们在上图 B 树中查找的流程如下： 先找到根节点也就是页 1，判断 28 在键值 17 和 35 之间，那么我们根据页 1 中的指针 p2 找到页 3。 将 28 和页 3 中的键值相比较，28 在 26 和 30 之间，我们根据页 3 中的指针 p2 找到页 8。 将 28 和页 8 中的键值相比较，发现有匹配的键值 28，键值 28 对应的用户信息为（28，bv）。 B+ 树B+ 树是对 B 树的进一步优化。让我们先来看下 B+ 树的结构图： 根据上图我们来看下 B+ 树和 B 树有什么不同： ①B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。 之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。 如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。 另外，B+ 树的阶数是等于键值的数量的，如果我们的 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据。 一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。 ②因为 B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。 那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。 有心的读者可能还发现上图 B+ 树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。 其实上面的 B 树我们也可以对各个节点加上链表。这些不是它们之前的区别，是因为在 MySQL 的 InnoDB 存储引擎中，索引就是这样存储的。 也就是说上图中的 B+ 树索引就是 InnoDB 中 B+ 树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。 通过上图可以看到，在 InnoDB 中，我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。 MyISAM 中的 B+ 树索引实现与 InnoDB 中的略有不同。在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。 聚集索引 VS 非聚集索引在上节介绍 B+ 树索引的时候，我们提到了图中的索引其实是聚集索引的实现方式。 那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。 这里我们着重介绍 InnoDB 中的聚集索引和非聚集索引： ①聚集索引（聚簇索引）：以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。 这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。 这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引。 ②非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。 非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。 明白了聚集索引和非聚集索引的定义，我们应该明白这样一句话：数据即索引，索引即数据。 1234567891011121314151617Innodb的存储索引是基于B+tree，理所当然，聚集索引也是基于B+tree。与非聚集索引的区别则是，聚集索引既存储了索引，也存储了行值。当一个表有一个聚集索引，它的数据是存储在索引的叶子页（leaf pages）。因此innodb也能理解为基于索引的表。Innodb如何选择一个聚集索引，对于Innodb，主键毫无疑问是一个聚集索引。但是当一个表没有主键，或者没有一个索引，Innodb会如何处理呢。请看如下规则1. 如果一个主键被定义了，那么这个主键就是作为聚集索引2. 如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引3. 如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，改列的值会随着数据的插入自增。还有一个需要注意的是：次级索引的叶子节点并不存储行数据的物理地址。而是存储的该行的主键值。所以：一次级索引包含了两次查找。一次是查找次级索引自身。然后查找主键（聚集索引）现在应该明白了吧，建立自增主键的原因是：Innodb中的每张表都会有一个聚集索引，而聚集索引又是以物理磁盘顺序来存储的，自增主键会把数据自动向后插入，避免了插入过程中的聚集索引排序问题。聚集索引的排序，必然会带来大范围的数据的物理移动，这里面带来的磁盘IO性能损耗是非常大的。 而如果聚集索引上的值可以改动的话，那么也会触发物理磁盘上的移动，于是就可能出现page分裂，表碎片横生。 利用聚集索引和非聚集索引查找数据前面我们讲解 B+ 树索引的时候并没有去说怎么在 B+ 树中进行数据的查找，主要就是因为还没有引出聚集索引和非聚集索引的概念。 下面我们通过讲解如何通过聚集索引以及非聚集索引查找数据表中数据的方式介绍一下 B+ 树索引查找数据方法。 利用聚集索引查找数据 还是这张 B+ 树索引图，现在我们应该知道这就是聚集索引，表中的数据存储在其中。 现在假设我们要查找 id&gt;=18 并且 id&lt;40 的用户数据。对应的 sql 语句为： MySQL 1select * from user where id&gt;=18 and id &lt;40 其中 id 为主键，具体的查找过程如下： ①一般根节点都是常驻内存的，也就是说页 1 已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。 从内存中读取到页 1，要查找这个 id&gt;=18 and id &lt;40 或者范围值，我们首先需要找到 id=18 的键值。 从页 1 中我们可以找到键值 18，此时我们需要根据指针 p2，定位到页 3。 ②要从页 3 中查找数据，我们就需要拿着 p2 指针去磁盘中进行读取页 3。 从磁盘中读取页 3 后将页 3 放入内存中，然后进行查找，我们可以找到键值 18，然后再拿到页 3 中的指针 p1，定位到页 8。 ③同样的页 8 页不在内存中，我们需要再去磁盘中将页 8 读取到内存中。 将页 8 读取到内存中后。因为页中的数据是链表进行连接的，而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值 18。 此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值 18 对应的数据。 因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页 8 中的键值依次进行遍历查找并匹配满足条件的数据。 我们可以一直找到键值为 22 的数据，然后页 8 中就没有数据了，此时我们需要拿着页 8 中的 p 指针去读取页 9 中的数据。 ④因为页 9 不在内存中，就又会加载页 9 到内存中，并通过和页 8 中一样的方式进行数据的查找，直到将页 12 加载到内存中，发现 41 大于 40，此时不满足条件。那么查找到此终止。 最终我们找到满足条件的所有数据，总共 12 条记录： (18,kl), (19,kl), (22,hj), (24,io), (25,vg) , (29,jk), (31,jk) , (33,rt) , (34,ty) , (35,yu) , (37,rt) , (39,rt) 。 下面看下具体的查找流程图 利用非聚集索引查找数据 读者看到这张图的时候可能会蒙，这是啥东西啊？怎么都是数字。如果有这种感觉，请仔细看下图中红字的解释。 什么？还看不懂？那我再来解释下吧。首先，这个非聚集索引表示的是用户幸运数字的索引（为什么是幸运数字？一时兴起想起来的:-)），此时表结构是这样的。 在叶子节点中，不再存储所有的数据了，存储的是键值和主键。对于叶子节点中的 x-y，比如 1-1。左边的 1 表示的是索引的键值，右边的 1 表示的是主键值。 如果我们要找到幸运数字为 33 的用户信息，对应的 sql 语句为： 1select * from user where luckNum=33 查找的流程跟聚集索引一样，这里就不详细介绍了。我们最终会找到主键值 47，找到主键后我们需要再到聚集索引中查找具体对应的数据信息，此时又回到了聚集索引的查找流程。 下面看下具体的查找流程图： 总结本篇文章从二叉查找树，详细说明了为什么 MySQL 用 B+ 树作为数据的索引，以及在 InnoDB 中数据库如何通过 B+ 树索引来存储数据以及查找数据。 我们一定要记住这句话：数据即索引，索引即数据。 参考文章:参考链接","link":"/MySQL/mysql-b-Tree%E7%B4%A2%E5%BC%95.html"},{"title":"mysql高性能优化规范方法","text":"数据库命令规范 所有数据库对象名称必须使用小写字母并用下划线分割 所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来） 数据库对象的命名要能做到见名识意，并且最后不要超过32个字符 临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低） 数据库基本设计规范所有表必须使用Innodb存储引擎没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）。 Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。 数据库和表的字符集统一使用UTF8兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储emoji表情的需要，字符集需要采用utf8mb4字符集。 所有表和字段都需要添加注释使用comment从句添加表和列的备注，从一开始就进行数据字典的维护 尽量控制单表数据量的大小，建议控制在500万以内。500万并不是Mysql数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。 可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小 谨慎使用Mysql分区表分区表在物理上表现为多个文件，在逻辑上表现为一个表； 谨慎选择分区键，跨分区查询效率可能更低； 建议采用物理分表的方式管理大数据。 尽量做到冷热数据分离，减小表的宽度Mysql限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节。 减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO）； 更有效的利用缓存，避免读入无用的冷数据； 经常一起使用的列放到一个表中（避免更多的关联操作）。 禁止在表中建立预留字段预留字段的命名很难做到见名识义。 预留字段无法确认存储的数据类型，所以无法选择合适的类型。 对预留字段类型的修改，会对表进行锁定。 禁止在数据库中存储图片，文件等大的二进制数据通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。 通常存储于文件服务器，数据库只存储文件地址信息 禁止在线上做数据库压力测试禁止从开发环境，测试环境直接连接生产环境数据库 数据库字段设计规范优先选择符合存储需要的最小的数据类型原因： 列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多，索引的性能也就越差。 方法： 将字符串转换成数字类型存储，如：将IP地址转换成整形数据mysql提供了两个方法来处理ip地址 inet_aton 把ip转为无符号整型(4-8位) inet_ntoa 把整型的ip转为地址 插入数据前，先用inet_aton把ip地址转为整型，可以节省空间，显示数据时，使用inet_ntoa把整型的ip地址转为地址显示即可。 对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储原因： 无符号相对于有符号可以多出一倍的存储空间 12SIGNED INT -2147483648~2147483647UNSIGNED INT 0~4294967295 VARCHAR(N)**中的N代表的是字符数，而不是字节数，使用UTF8存储255个汉字 Varchar(255)=765个字节。过大的长度会消耗更多的内存。** 避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据建议把BLOB或是TEXT列分离到单独的扩展表中Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。 如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。 TEXT或BLOB类型只能使用前缀索引因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的 避免使用ENUM类型修改ENUM值需要使用ALTER语句 ENUM类型的ORDER BY操作效率低，需要额外操作 禁止使用数值作为ENUM的枚举值 尽可能把所有列定义为NOT NULL原因： 索引NULL列需要额外的空间来保存，所以要占用更多的空间 进行比较和计算时要对NULL值做特别的处理 使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07 TIMESTAMP 占用4字节和INT相同，但比INT可读性高 超出TIMESTAMP取值范围的使用DATETIME类型存储 经常会有人用字符串存储日期型的数据（不正确的做法） 缺点1：无法用日期函数进行计算和比较 缺点2：用字符串存储日期要占用更多的空间 同财务相关的金额类数据必须使用decimal类型 非精准浮点：float,double 精准浮点：decimal Decimal类型为精准浮点数，在计算时不会丢失精度 占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节 可用于存储比bigint更大的整型数据 索引设计规范限制每张表上的索引数量，建议单张表索引不超过5个索引并不是越多越好！索引可以提高效率同样可以降低效率。 索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。 因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能。 禁止给表中的每一列都建立单独的索引5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。 每个Innodb表必须有个主键Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。 Innodb是按照主键索引的顺序来组织表的 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长） 主键建议使用自增ID值 常见索引列建议 出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列 包含在ORDER BY、GROUP BY、DISTINCT中的字段 并不要将符合1和2中的字段的列都建立一个索引， 通常将1、2中的字段建立联合索引效果更好 多表join的关联列 如何选择索引列的顺序建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数） 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好） 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引） 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间） 重复索引示例：primary key(id)、index(id)、unique index(id) 冗余索引示例：index(a,b,c)、index(a,b)、index(a) 对于频繁的查询优先考虑使用覆盖索引覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引 覆盖索引的好处： 避免Innodb表进行索引的二次查询Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。 而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。 可以把随机IO变成顺序IO加快查询效率由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。 索引SET规范尽量避免使用外键约束 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引 外键可用于保证数据的参照完整性，但建议在业务端实现 外键会影响父表和子表的写操作从而降低性能 数据库SQL开发规范建议使用预编译语句进行数据库操作预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题。 只传参数，比传递SQL语句更高效。 相同语句可以一次解析，多次使用，提高处理效率。 避免数据类型的隐式转换隐式转换会导致索引失效如: 1select name,phone from customer where id = '111'; 充分利用表上已经存在的索引s避免使用双%号的查询条件。如：a like '%123%'，（如果无前置%,只有后置%，是可以用到列上的索引的） 一个SQL只能利用到复合索引中的一列进行范围查询。如：有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到。 在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧，使用left join 或 not exists来优化not in 操作，因为not in 也通常会使用索引失效。 数据库设计时，应该要对以后扩展进行考虑程序连接不同的数据库使用不同的账号，进制跨库查询 为数据库迁移和分库分表留出余地 降低业务耦合度 避免权限过大而产生的安全风险 禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询原因： 消耗更多的CPU和IO以网络带宽资源 无法使用覆盖索引 可减少表结构变更带来的影响 禁止使用不含字段列表的INSERT语句如： 1insert into values ('a','b','c'); 应使用： 1insert into t(c1,c2,c3) values ('a','b','c'); 避免使用子查询，可以把子查询优化为join操作通常子查询在in子句中，且b中为简单SQL(不包含union、group by、order by、limit从句)时,才可以把子查询转化为关联查询进行优化。 子查询性能差的原因： 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。 避免使用JOIN关联太多的表对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置。 在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。 如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。 同时对于关联操作来说，会产生临时表操作，影响查询效率，Mysql最多允许关联61个表，建议不超过5个。 减少同数据库的交互次数数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。 对应同一列进行or判断时，使用in代替orin 的值不要超过500个，in 操作可以更有效的利用索引，or大多数情况下很少能利用到索引。 禁止使用order by rand() 进行随机排序order by rand()**会把表中所有符合条件**的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的CPU和IO及内存资源。 推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。 WHERE从句中禁止对列进行函数转换和计算对列进行函数转换或计算时会导致无法使用索引 不推荐： 1where date(create_time)='20190101' 推荐： 1where create_time &gt;= '20190101' and create_time &lt; '20190102' 在明显不会有重复值时使用UNION ALL 而不是UNION UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作 UNION ALL 不会再对结果集进行去重操作 拆分复杂的大SQL为多个小SQL 大SQL逻辑上比较复杂，需要占用大量CPU进行计算的SQL MySQL中，一个SQL只能使用一个CPU进行计算 SQL拆分后可以通过并行执行来提高处理效率 数据库操作行为规范超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作大批量操作可能会造成严重的主从延迟 主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况 binlog日志为row格式时会产生大量的日志 大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。 避免产生大事务操作 大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响。 特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批 对于大表使用pt-online-schema-change修改表结构 避免大表修改产生的主从延迟 避免在对表字段进行修改时进行锁表 对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。 pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个DDL操作，分解成多个小的批次进行。 禁止为程序使用的账号赋予super权限 当达到最大连接数限制时，还运行1个有super权限的用户连接 super权限只能留给DBA处理问题的账号使用 对于程序连接数据库账号，遵循权限最小原则 程序使用数据库账号只能在一个DB下使用，不准跨库 程序使用的账号原则上不准有drop权限 文章来源 .","link":"/MySQL/mysql%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E6%96%B9%E6%B3%95.html"},{"title":"一次数据库的死锁问题排查过程","text":"摘要某天晚上，同事正在发布，突然线上大量报警，很多是关于数据库死锁的，报警提示信息如下： 现象某天晚上，同事正在发布，突然线上大量报警，很多是关于数据库死锁的，报警提示信息如下： 123456789{&quot;errorCode&quot;:&quot;SYSTEM_ERROR&quot;,&quot;errorMsg&quot;:&quot;nested exception is org.apache.ibatis.exceptions.PersistenceException: Error updating database. Cause: ERR-CODE: [TDDL-4614][ERR_EXECUTE_ON_MYSQL] Deadlock found when trying to get lock; The error occurred while setting parameters\\n### SQL: update fund_transfer_stream set gmt_modified=now(),state = ? where fund_transfer_order_no = ? and seller_id = ? and state = 'NEW' 通过报警，我们基本可以定位到发生死锁的数据库以及数据库表。先来介绍下本文案例中涉及到的数据库相关信息。 背景情况我们使用的数据库是Mysql 5.7，引擎是InnoDB，事务隔离级别是READ-COMMITED。 数据库版本查询方法： 1SELECT version(); 引擎查询方法： 1show create table fund_transfer_stream; 建表语句中会显示存储引擎信息，形如：ENGINE=InnoDB 事务隔离级别查询方法： 1select @@tx_isolation; 事务隔离级别设置方法（只对当前Session生效）： 1set session transaction isolation level read committed; PS：注意，如果数据库是分库的，以上几条SQL语句需要在单库上执行，不要在逻辑库执行。 发生死锁的表结构及索引情况（隐去了部分无关字段和索引）： 1234567891011121314CREATE TABLE `fund_transfer_stream` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键', `gmt_create` datetime NOT NULL COMMENT '创建时间', `gmt_modified` datetime NOT NULL COMMENT '修改时间', `pay_scene_name` varchar(256) NOT NULL COMMENT '支付场景名称', `pay_scene_version` varchar(256) DEFAULT NULL COMMENT '支付场景版本', `identifier` varchar(256) NOT NULL COMMENT '唯一性标识', `seller_id` varchar(64) NOT NULL COMMENT '卖家Id', `state` varchar(64) DEFAULT NULL COMMENT '状态', `fund_transfer_order_no` varchar(256) DEFAULT NULL COMMENT '资金平台返回的状态', PRIMARY KEY (`id`),UNIQUE KEY `uk_scene_identifier` (KEY `idx_seller` (`seller_id`), KEY `idx_seller_transNo` (`seller_id`,`fund_transfer_order_no`(20)) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='资金流水'; 该数据库共有三个索引，1个聚簇索引（主键索引），2个非聚簇索（非主键索引）引。 聚簇索引： 1PRIMARY KEY (`id`) 非聚簇索引： 123KEY `idx_seller` (`seller_id`),KEY `idx_seller_transNo` (`seller_id`,`fund_transfer_order_no`(20)) 以上两个索引，其实idx_seller_transNo已经覆盖到了idx_seller，由于历史原因，因为该表以seller_id分表，所以是先有的idx_seller，后有的idx_seller_transNo 死锁日志当数据库发生死锁时，可以通过以下命令获取死锁日志： 12show engine innodb status 发生死锁，第一时间查看死锁日志，得到死锁日志内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243Transactions deadlock detected, dumping detailed information.2019-03-19T21:44:23.516263+08:00 5877341 [Note] InnoDB: *** (1) TRANSACTION:TRANSACTION 173268495, ACTIVE 0 sec fetching rowsmysql tables in use 1, locked 1LOCK WAIT 304 lock struct(s), heap size 41168, 6 row lock(s), undo log entries 1MySQL thread id 5877358, OS thread handle 47356539049728, query id 557970181 11.183.244.150 fin_instant_app updatingupdate `fund_transfer_stream` set `gmt_modified` = NOW(), `state` = 'PROCESSING' where ((`state` = 'NEW') AND (`seller_id` = '38921111') AND (`fund_transfer_order_no` = '99010015000805619031958363857'))2019-03-19T21:44:23.516321+08:00 5877341 [Note] InnoDB: *** (1) HOLDS THE LOCK(S):RECORD LOCKS space id 173 page no 13726 n bits 248 index idx_seller_transNo of table `xxx`.`fund_transfer_stream` trx id 173268495 lock_mode X locks rec but not gapRecord lock, heap no 168 PHYSICAL RECORD: n_fields 3; compact format; info bits 02019-03-19T21:44:23.516565+08:00 5877341 [Note] InnoDB: *** (1) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 173 page no 12416 n bits 128 index PRIMARY of table `xxx`.`fund_transfer_stream` trx id 173268495 lock_mode X locks rec but not gap waitingRecord lock, heap no 56 PHYSICAL RECORD: n_fields 17; compact format; info bits 02019-03-19T21:44:23.517793+08:00 5877341 [Note] InnoDB: *** (2) TRANSACTION:TRANSACTION 173268500, ACTIVE 0 sec fetching rows, thread declared inside InnoDB 81mysql tables in use 1, locked 1302 lock struct(s), heap size 41168, 2 row lock(s), undo log entries 1MySQL thread id 5877341, OS thread handle 47362313119488, query id 557970189 11.131.81.107 fin_instant_app updatingupdate `fund_transfer_stream_0056` set `gmt_modified` = NOW(), `state` = 'PROCESSING' where ((`state` = 'NEW') AND (`seller_id` = '38921111') AND (`fund_transfer_order_no` = '99010015000805619031957477256'))2019-03-19T21:44:23.517855+08:00 5877341 [Note] InnoDB: *** (2) HOLDS THE LOCK(S):RECORD LOCKS space id 173 page no 12416 n bits 128 index PRIMARY of table `fin_instant_0003`.`fund_transfer_stream_0056` trx id 173268500 lock_mode X locks rec but not gapRecord lock, heap no 56 PHYSICAL RECORD: n_fields 17; compact format; info bits 02019-03-19T21:44:23.519053+08:00 5877341 [Note] InnoDB: *** (2) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 173 page no 13726 n bits 248 index idx_seller_transNo of table `fin_instant_0003`.`fund_transfer_stream_0056` trx id 173268500 lock_mode X locks rec but not gap waitingRecord lock, heap no 168 PHYSICAL RECORD: n_fields 3; compact format; info bits 02019-03-19T21:44:23.519297+08:00 5877341 [Note] InnoDB: *** WE ROLL BACK TRANSACTION (2) 简单解读一下死锁日志，可以得到以下信息： 1、导致死锁的两条SQL语句分别是： 123update `fund_transfer_stream_0056` set `gmt_modified` = NOW(), `state` = 'PROCESSING' where ((`state` = 'NEW') AND (`seller_id` = '38921111') AND (`fund_transfer_order_no` = '99010015000805619031957477256')) 和 1234update `fund_transfer_stream_0056` set `gmt_modified` = NOW(), `state` = 'PROCESSING' where ((`state` = 'NEW') AND (`seller_id` = '38921111') AND (`fund_transfer_order_no` = '99010015000805619031958363857')) 2、事务1，持有索引idx_seller_transNo的锁，在等待获取PRIMARY的锁。 3、事务2，持有PRIMARY的锁，在等待获取idx_seller_transNo的锁。 4、因事务1和事务2之间发生循环等待，故发生死锁。 5、事务1和事务2当前持有的锁均为：lock_mode X locks rec but not gap 两个事务对记录加的都是X 锁，No Gap锁，即对当行记录加锁，并为加间隙锁。 X锁：排他锁、又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。 与之对应的是S锁：共享锁，又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。 Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。 详见：https://www.cnblogs.com/zhoujinyi/p/3435982.html 、 https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html 问题排查根据我们目前已知的数据库相关信息，以及死锁的日志，我们基本可以做一些简单的判定。 首先，此次死锁一定是和Gap锁以及Next-Key Lock没有关系的。因为我们的数据库隔离级别是RC（READ-COMMITED）的，这种隔离级别是不会添加Gap锁的。前面的死锁日志也提到这一点。 然后，就要翻代码了，看看我们的代码中事务到底是怎么做的。核心代码及SQL如下： 123456@Transactional(rollbackFor = Exception.class)public int doProcessing(String sellerId, Long id, String fundTransferOrderNo) { fundTreansferStreamDAO.updateFundStreamId(sellerId, id, fundTransferOrderNo); return fundTreansferStreamDAO.updateStatus(sellerId, fundTransferOrderNo, FundTransferStreamState.PROCESSING.name());} 该代码的目的是先后修改同一条记录的两个不同字段，updateFundStreamId SQL： 1234update fund_transfer_stream set gmt_modified=now(),fund_transfer_order_no = #{fundTransferOrderNo} where id = #{id} and seller_id = #{sellerId} updateStatus SQL： 12345update fund_transfer_stream set gmt_modified=now(),state = #{state} where fund_transfer_order_no = #{fundTransferOrderNo} and seller_id = #{sellerId} and state = 'NEW' 可以看到，我们的同一个事务中执行了两条Update语句，这里分别查看下两条SQL的执行计划： updateFundStreamId执行的时候使用到的是PRIMARY索引。 updateStatus执行的时候使用到的是idx_seller_transNo索引。 通过执行计划，我们发现updateStatus其实是有两个索引可以用的，执行的时候真正使用的是idx_seller_transNo索引。这是因为MySQL查询优化器是基于代价（cost-based）的查询方式。因此，在查询过程中，最重要的一部分是根据查询的SQL语句，依据多种索引，计算查询需要的代价，从而选择最优的索引方式生成查询计划。 我们查询执行计划是在死锁发生之后做的，事后查询的执行计划和发绳死锁那一刻的索引使用情况并不一定相同的。但是，我们结合死锁日志，也可以定位到以上两条SQL语句执行的时候使用到的索引。即updateFundStreamId执行的时候使用到的是PRIMARY索引，updateStatus执行的时候使用到的是idx_seller_transNo索引。 有了以上这些已知信息，我们就可以开始排查死锁原因及其背后的原理了。通过分析死锁日志，再结合我们的代码以及数据库建表语句，我们发现主要问题出在我们的idx_seller_transNo索引上面： 1KEY `idx_seller_transNo` (`seller_id`,`fund_transfer_order_no`(20)) 索引创建语句中，我们使用了前缀索引，为了节约索引空间，提高索引效率，我们只选择了fund_transfer_order_no字段的前20位作为索引值。 因为fund_transfer_order_no只是普通索引，而非唯一性索引。又因为在一种特殊情况下，会有同一个用户的两个fund_transfer_order_no的前20位相同，这就导致两条不同的记录的索引值一样（因为seller_id 和fund_transfer_order_no(20)都相同 ）。 就如本文中的例子，发生死锁的两条记录的fund_transfer_order_no字段的值：99010015000805619031958363857和99010015000805619031957477256这两个就是前20位相同的。 那么为什么fund_transfer_order_no的前20位相同会导致死锁呢？ 加锁原理我们就拿本次的案例来看一下MySql数据库加锁的原理是怎样的，本文的死锁背后又发生了什么。 我们在数据库上模拟死锁场景，执行顺序如下： 事务1 事务2 执行结果 begin update fund_transfer_stream set gmt_modified=now(),fund_transfer_order_no = ‘99010015000805619031958363857’ where id = 1 and seller_id = 3111095611; 执行成功 begin update fund_transfer_stream set gmt_modified=now(),fund_transfer_order_no = ‘99010015000805619031957477256’ where id = 2 and seller_id = 3111095611; 执行成功 update fund_transfer_stream set gmt_modified = NOW(), state = ‘PROCESSING’ where ((state = ‘NEW’) AND (seller_id = ‘3111095611’) AND (fund_transfer_order_no = ‘99010015000805619031958363857’)); 阻塞 update fund_transfer_stream set gmt_modified = NOW(), state = ‘PROCESSING’ where ((state = ‘NEW’) AND (seller_id = ‘3111095611’) AND (fund_transfer_order_no = ‘99010015000805619031957477256’)); 死锁 我们知道，在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 主键索引的叶子节点存的是整行数据。在InnoDB中，主键索引也被称为聚簇索引（clustered index） 非主键索引的叶子节点的内容是主键的值，在InnoDB中，非主键索引也被称为非聚簇索引（secondary index） 所以，本文的示例中涉及到的索引结构（索引是B+树，简化成表格了）如图： 死锁的发生与否，并不在于事务中有多少条SQL语句，死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。那么接下来就看下上面的例子中两个事务的加锁顺序是怎样的： 下图是分解图，每一条SQL执行的时候加锁情况： 结合以上两张图，我们发现了导致死锁的原因： 事务1执行update1占用PRIMARY = 1的锁 ——&gt; 事务2执行update1 占有PRIMARY = 2的锁； 事务1执行update2占有idx_seller_transNo = (3111095611，99010015000805619031)的锁，尝试占有PRIMARY = 2锁失败（阻塞）； 事务2执行update2尝试占有idx_seller_transNo = (3111095611，99010015000805619031)的锁失败（死锁）； 事务在以非主键索引为where条件进行Update的时候，会先对该非主键索引加锁，然后再查询该非主键索引对应的主键索引都有哪些，再对这些主键索引进行加锁。） 解决方法至此，我们分析清楚了导致死锁的根本原理以及其背后的原理。那么这个问题解决起来就不难了。 可以从两方面入手，分别是修改索引和修改代码（包含SQL语句）。 修改索引：只要我们把前缀索引 idx_seller_transNo中fund_transfer_order_no的前缀长度修改下就可以了。比如改成50。即可避免死锁。 但是，改了idx_seller_transNo的前缀长度后，可以解决死锁的前提条件是update语句真正执行的时候，会用到fund_transfer_order_no索引。如果MySQL查询优化器在代价分析之后，决定使用索引 KEY idx_seller(seller_id)，那么还是会存在死锁问题。原理和本文类似。 所以，根本解决办法就是改代码： 123* 所有update都通过主键ID进行。* 在同一个事务中，避免出现多条update语句修改同一条记录。 总结与思考在死锁发生之后的一周内，我几乎每天都会抽空研究一会，问题早早的就定位到了，修改方案也有了，但是其中原理一直没搞清楚。 前前后后做过很多中种推断及假设，又都被自己一次次推翻。最终还是要靠实践来验证自己的想法。于是我自己在本地安装了数据库，实战的做了些测试，并实时查看数据库锁情况。show engine innodb status ;可以查看锁情况。最终才搞清楚原理。 简单说几点思考： 1、遇到问题，不要猜！！！亲手复现下问题，然后再来分析。 2、不要忽略上下文！！！我刚开始就是只关注死锁日志，一直忽略了代码中的事务其实还执行了另外一条SQL语句（updateFundStreamId）。 3、理论知识再充足，关键时刻不一定想的起来！！！ 4、坑都是自己埋的！！！ 参考资料：MySQL 加锁处理分析 innodb 事务隔离级别 《MySql实战45讲》 MySQL中的行级锁,表级锁,页级锁 查看原文","link":"/MySQL/%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B.html"},{"title":"一千行 MySQL 学习笔记(转载)","text":"摘要以下为本人初学 MySQL 时做的笔记，也从那时起没再更新过，但还是囊括了基本的知识点，有时还翻出来查查。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044/* Windows服务 */-- 启动MySQL net start mysql-- 创建Windows服务 sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)/* 连接与断开服务器 */mysql -h 地址 -P 端口 -u 用户名 -p 密码SHOW PROCESSLIST -- 显示哪些线程正在运行SHOW VARIABLES -- 显示系统变量信息/* 数据库操作 */ -------------------- 查看当前数据库 SELECT DATABASE();-- 显示当前时间、用户名、数据库版本 SELECT now(), user(), version();-- 创建库 CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项 数据库选项： CHARACTER SET charset_name COLLATE collation_name-- 查看已有库 SHOW DATABASES[ LIKE 'PATTERN']-- 查看当前库信息 SHOW CREATE DATABASE 数据库名-- 修改库的选项信息 ALTER DATABASE 库名 选项信息-- 删除库 DROP DATABASE[ IF EXISTS] 数据库名 同时删除该数据库相关的目录及其目录内容/* 表的操作 */ -------------------- 创建表 CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 TEMPORARY 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT 'string']-- 表选项 -- 字符集 CHARSET = charset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 ENGINE = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同 常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive 不同的引擎在保存表的结构和数据时采用不同的方式 MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引 InnoDB表文件含义：.frm表定义，表空间数据和日志文件 SHOW ENGINES -- 显示存储引擎的状态信息 SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息 -- 自增起始数 AUTO_INCREMENT = 行数 -- 数据文件目录 DATA DIRECTORY = '目录' -- 索引文件目录 INDEX DIRECTORY = '目录' -- 表注释 COMMENT = 'string' -- 分区选项 PARTITION BY ... (详细见手册)-- 查看所有表 SHOW TABLES[ LIKE 'pattern'] SHOW TABLES FROM 表名-- 查看表机构 SHOW CREATE TABLE 表名 （信息更详细） DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE 'PATTERN'] SHOW TABLE STATUS [FROM db_name] [LIKE 'pattern']-- 修改表 -- 修改表本身的选项 ALTER TABLE 表名 表的选项 eg: ALTER TABLE 表名 ENGINE=MYISAM; -- 对表进行重命名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库） -- RENAME可以交换两个表名 -- 修改表的字段机构（13.1.2. ALTER TABLE语法） ALTER TABLE 表名 操作名 -- 操作名 ADD[ COLUMN] 字段定义 -- 增加字段 AFTER 字段名 -- 表示增加在该字段名后面 FIRST -- 表示增加在第一个 ADD PRIMARY KEY(字段名) -- 创建主键 ADD UNIQUE [索引名] (字段名)-- 创建唯一索引 ADD INDEX [索引名] (字段名) -- 创建普通索引 DROP[ COLUMN] 字段名 -- 删除字段 MODIFY[ COLUMN] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) CHANGE[ COLUMN] 原字段名 新字段名 字段属性 -- 支持对字段名修改 DROP PRIMARY KEY -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性) DROP INDEX 索引名 -- 删除索引 DROP FOREIGN KEY 外键 -- 删除外键-- 删除表 DROP TABLE[ IF EXISTS] 表名 ...-- 清空表数据 TRUNCATE [TABLE] 表名-- 复制表结构 CREATE TABLE 表名 LIKE 要复制的表名-- 复制表结构和数据 CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名-- 检查表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ...-- 优化表 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...-- 修复表 REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]-- 分析表 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] .../* 数据操作 */ -------------------- 增 INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...] -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ REPLACE 与 INSERT 完全一样，可互换。 INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]-- 查 SELECT 字段列表 FROM 表名[ 其他子句] -- 可来自多个表的多个字段 -- 其他子句可以不使用 -- 字段列表可以用*代替，表示所有字段-- 删 DELETE FROM 表名[ 删除条件子句] 没有条件子句，则会删除全部-- 改 UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]/* 字符集编码 */ -------------------- MySQL、数据库、表、字段均可设置编码-- 数据编码与客户端编码不需一致SHOW VARIABLES LIKE 'character_set_%' -- 查看所有字符集编码项 character_set_client 客户端向服务器发送数据时使用的编码 character_set_results 服务器端将结果返回给客户端所使用的编码 character_set_connection 连接层编码SET 变量名 = 变量值 SET character_set_client = gbk; SET character_set_results = gbk; SET character_set_connection = gbk;SET NAMES GBK; -- 相当于完成以上三个设置-- 校对集 校对集用以排序 SHOW CHARACTER SET [LIKE 'pattern']/SHOW CHARSET [LIKE 'pattern'] 查看所有字符集 SHOW COLLATION [LIKE 'pattern'] 查看所有校对集 CHARSET 字符集编码 设置字符集编码 COLLATE 校对集编码 设置校对集编码/* 数据类型（列类型） */ ------------------1. 数值类型-- a. 整型 ---------- 类型 字节 范围（有符号位） tinyint 1字节 -128 ~ 127 无符号位：0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 bigint 8字节 int(M) M表示总位数 - 默认存在符号位，unsigned 属性修改 - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改 例：int(5) 插入一个数'123'，补填后为'00123' - 在满足要求的情况下，越小越好。 - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。-- b. 浮点型 ---------- 类型 字节 范围 float(单精度) 4字节 double(双精度) 8字节 浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。 不同于整型，前后均会补填0. 定义浮点型时，需指定总位数和小数位数。 float(M, D) double(M, D) M表示总位数，D表示小数位数。 M和D的大小会决定浮点数的范围。不同于整型的固定范围。 M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。 支持科学计数法表示。 浮点数表示近似值。-- c. 定点数 ---------- decimal -- 可变长度 decimal(M, D) M也表示总位数，D表示小数位数。 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。 将浮点数转换为字符串来保存，每9位数字保存为4个字节。2. 字符串类型-- a. char, varchar ---------- char 定长字符串，速度快，但浪费空间 varchar 变长字符串，速度慢，但节省空间 M表示能存储的最大长度，此长度是字符数，非字节数。 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。 一条有效记录最大不能超过65535个字节。 utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3-- b. blob, text ---------- blob 二进制字符串（字节字符串） tinyblob, blob, mediumblob, longblob text 非二进制字符串（字符字符串） tinytext, text, mediumtext, longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值-- c. binary, varbinary ---------- 类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。 char, varchar, text 对应 binary, varbinary, blob.3. 日期时间类型 一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155datetime YYYY-MM-DD hh:mm:sstimestamp YY-MM-DD hh:mm:ss YYYYMMDDhhmmss YYMMDDhhmmss YYYYMMDDhhmmss YYMMDDhhmmssdate YYYY-MM-DD YY-MM-DD YYYYMMDD YYMMDD YYYYMMDD YYMMDDtime hh:mm:ss hhmmss hhmmssyear YYYY YY YYYY YY4. 枚举和集合-- 枚举(enum) ----------enum(val1, val2, val3...) 在已知的值中进行单选。最大数量为65535. 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。 表现为字符串类型，存储却是整型。 NULL值的索引是NULL。 空字符串错误值的索引值是0。-- 集合（set） ----------set(val1, val2, val3...) create table tab ( gender set('男', '女', '无') ); insert into tab values ('男, 女'); 最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。 当创建表时，SET成员值的尾部空格将自动被删除。/* 选择类型 */-- PHP角度1. 功能满足2. 存储空间尽量小，处理效率更高3. 考虑兼容问题-- IP存储 ----------1. 只需存储，可用字符串2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned 1) PHP函数转换 ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。 利用sprintf函数格式化字符串 sprintf(&quot;%u&quot;, ip2long('192.168.3.134')); 然后用long2ip将整型转回IP字符串 2) MySQL函数转换(无符号整型，UNSIGNED) INET_ATON('127.0.0.1') 将IP转为整型 INET_NTOA(2130706433) 将整型转为IP/* 列属性（列约束） */ ------------------1. PRIMARY 主键 - 能唯一标识记录的字段，可以作为主键。 - 一个表只能有一个主键。 - 主键具有唯一性。 - 声明字段时，用 primary key 标识。 也可以在字段列表之后声明 例：create table tab ( id int, stu varchar(10), primary key (id)); - 主键字段的值不能为null。 - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));2. UNIQUE 唯一索引（唯一约束） 使得某字段的值也不能重复。3. NULL 约束 null不是数据类型，是列的一个属性。 表示当前列是否可以为null，表示什么都没有。 null, 允许为空。默认。 not null, 不允许为空。 insert into tab values (null, 'val'); -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null4. DEFAULT 默认值属性 当前字段的默认值。 insert into tab values (default, 'val'); -- 此时表示强制使用默认值。 create table tab ( add_time timestamp default current_timestamp ); -- 表示将当前时间的时间戳设为默认值。 current_date, current_time5. AUTO_INCREMENT 自动增长约束 自动增长必须为索引（主键或unique） 只能存在一个字段为自动增长。 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;6. COMMENT 注释 例：create table tab ( id int ) comment '注释内容';7. FOREIGN KEY 外键约束 用于限制主表与从表数据完整性。 alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id); -- 将表t1的t1_id外键关联到表t2的id字段。 -- 每个外键都有一个名字，可以通过 constraint 指定 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。 MySQL中，可以对InnoDB引擎使用外键约束： 语法： foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择： 1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。 2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。 3. restrict，拒绝父表删除和更新。 注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。/* 建表规范 */ ------------------ -- Normal Format, NF - 每个表保存一个实体信息 - 每个具有一个ID字段作为主键 - ID主键 + 原子表 -- 1NF, 第一范式 字段不能再分，就满足第一范式。 -- 2NF, 第二范式 满足第一范式的前提下，不能出现部分依赖。 消除符合主键就可以避免部分依赖。增加单列关键字。 -- 3NF, 第三范式 满足第二范式的前提下，不能出现传递依赖。 某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。 将一个实体信息的数据放在一个表内实现。/* SELECT */ ------------------SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMITa. select_expr -- 可以用 * 表示所有字段。 select * from tb; -- 可以使用表达式（计算公式、函数调用、字段也是个表达式） select stu, 29+25, now() from tb; -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。 - 使用 as 关键字，也可省略 as. select stu+10 as add10 from tb;b. FROM 子句 用于标识查询来源。 -- 可以为表起别名。使用as关键字。 SELECT * FROM tb1 AS tt, tb2 AS bb; -- from子句后，可以同时出现多个表。 -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。 SELECT * FROM tb1, tb2; -- 向优化符提示如何选择索引 USE INDEX、IGNORE INDEX、FORCE INDEX SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3; SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;c. WHERE 子句 -- 从from获得的数据源中进行筛选。 -- 整型1表示真，0表示假。 -- 表达式由运算符和运算数组成。 -- 运算数：变量（字段）、值、函数返回值 -- 运算符： =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||, in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor is/is not 加上ture/false/unknown，检验某个值的真假 &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较d. GROUP BY 子句, 分组子句 GROUP BY 字段/别名 [排序方式] 分组后会进行排序。升序：ASC，降序：DESC 以下[合计函数]需配合 GROUP BY 使用： count 返回不同的非NULL值数目 count(*)、count(字段) sum 求和 max 求最大值 min 求最小值 avg 求平均值 group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。e. HAVING 子句，条件子句 与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。 where 不可以使用合计函数。一般需用合计函数才会用 having SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。f. ORDER BY 子句，排序子句 order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：ASC，降序：DESC 支持多个字段的排序。g. LIMIT 子句，限制结果数量子句 仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。 limit 起始位置, 获取条数 省略第一个参数，表示从索引0开始。limit 获取条数h. DISTINCT, ALL 选项 distinct 去除重复记录 默认为 all, 全部记录/* UNION */ ------------------ 将多个select查询的结果组合成一个结果集合。 SELECT ... UNION [ALL|DISTINCT] SELECT ... 默认 DISTINCT 方式，即所有返回的行都是唯一的 建议，对每个SELECT查询加上小括号包裹。 ORDER BY 排序时，需加上 LIMIT 进行结合。 需要各select查询的字段数量一样。 每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。/* 子查询 */ ------------------ - 子查询需用括号包裹。-- from型 from后要求是一个表，必须给子查询结果取个别名。 - 简化每个查询内的条件。 - from型需将结果生成一个临时表格，可用以原表的锁定的释放。 - 子查询返回一个表，表型子查询。 select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;-- where型 - 子查询返回一个值，标量子查询。 - 不需要给子查询取别名。 - where子查询内的表，不能直接用以更新。 select * from tb where money = (select max(money) from tb); -- 列子查询 如果子查询结果返回的是一列。 使用 in 或 not in 完成查询 exists 和 not exists 条件 如果子查询返回数据，则返回1或0。常用于判断条件。 select column1 from t1 where exists (select * from t2); -- 行子查询 查询条件是一个行。 select * from t1 where (id, gender) in (select id, gender from t2); 行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...) 行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。 -- 特殊运算符 != all() 相当于 not in = some() 相当于 in。any 是 some 的别名 != some() 不等同于 not in，不等于其中某一个。 all, some 可以配合其他运算符一起使用。/* 连接查询(join) */ ------------------ 将多个表的字段进行连接，可以指定连接条件。-- 内连接(inner join) - 默认就是内连接，可省略inner。 - 只有数据存在时才能发送连接。即连接结果不能出现空行。 on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真） 也可用where表示连接条件。 还有 using, 但需字段名相同。 using(字段名) -- 交叉连接 cross join 即，没有条件的内连接。 select * from tb1 cross join tb2;-- 外连接(outer join) - 如果数据不存在，也会出现在连接结果中。 -- 左外连接 left join 如果数据不存在，左表记录会出现，而右表为null填充 -- 右外连接 right join 如果数据不存在，右表记录会出现，而左表为null填充-- 自然连接(natural join) 自动判断连接条件完成连接。 相当于省略了using，会自动查找相同字段名。 natural join natural left join natural right joinselect info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;/* 导入导出 */ ------------------select * into outfile 文件地址 [控制格式] from 表名; -- 导出表数据load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据 生成的数据默认的分隔符是制表符 local未指定，则数据文件必须在服务器上 replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理-- 控制格式fields 控制字段格式默认：fields terminated by '\\t' enclosed by '' escaped by '\\\\' terminated by 'string' -- 终止 enclosed by 'char' -- 包裹 escaped by 'char' -- 转义 -- 示例： SELECT a,b,a+b INTO OUTFILE '/tmp/result.text' FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '&quot;' LINES TERMINATED BY '\\n' FROM test_table;lines 控制行格式默认：lines terminated by '\\n' terminated by 'string' -- 终止/* INSERT */ ------------------select语句获得的数据可以用insert插入。可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。 或者使用set语法。 INSERT INTO tbl_name SET field=value,...；可以一次性使用多个值，采用(), (), ();的形式。 INSERT INTO tbl_name VALUES (), (), ();可以在列值指定时，使用表达式。 INSERT INTO tbl_name VALUES (field_value, 10+10, now());可以使用一个特殊值 DEFAULT，表示该列使用默认值。 INSERT INTO tbl_name VALUES (field_value, DEFAULT);可以通过一个查询的结果，作为需要插入的值。 INSERT INTO tbl_name SELECT ...;可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。 INSERT INTO tbl_name VALUES/SET/SELECT ON DUPLICATE KEY UPDATE 字段=值, …;/* DELETE */ ------------------DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count]按照条件删除。where指定删除的最多记录数。limit可以通过排序条件删除。order by + limit支持多表删除，使用类似连接语法。delete from 需要删除数据多表1，表2 using 表连接操作 条件。/* TRUNCATE */ ------------------TRUNCATE [TABLE] tbl_name清空数据删除重建表区别：1，truncate 是删除表再创建，delete 是逐条删除2，truncate 重置auto_increment的值。而delete不会3，truncate 不知道删除了几条，而delete知道。4，当被用于带分区的表时，truncate 会保留分区/* 备份与还原 */ ------------------备份，将数据的结构与表内数据保存起来。利用 mysqldump 指令完成。-- 导出mysqldump [options] db_name [tables]mysqldump [options] ---database DB1 [DB2 DB3...]mysqldump [options] --all--database1. 导出一张表 mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)2. 导出多张表 mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)3. 导出所有表 mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)4. 导出一个库 mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)可以-w携带WHERE条件-- 导入1. 在登录mysql的情况下： source 备份文件2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件/* 视图 */ ------------------什么是视图： 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。 视图具有表结构文件，但不存在数据文件。 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。 视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。-- 创建视图CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement - 视图名必须唯一，同时不能与表重名。 - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。 - 可以指定视图执行的算法，通过ALGORITHM指定。 - column_list如果存在，则数目必须等于SELECT语句检索的列数-- 查看结构 SHOW CREATE VIEW view_name-- 删除视图 - 删除视图后，数据依然存在。 - 可同时删除多个视图。 DROP VIEW [IF EXISTS] view_name ...-- 修改视图结构 - 一般不修改视图，因为不是所有的更新视图都会映射到表上。 ALTER VIEW view_name [(column_list)] AS select_statement-- 视图作用 1. 简化业务逻辑 2. 对客户端隐藏真实的表结构-- 视图算法(ALGORITHM) MERGE 合并 将视图的查询语句，与外部查询需要先合并再执行！ TEMPTABLE 临时表 将视图执行完毕后，形成临时表，再做外层查询！ UNDEFINED 未定义(默认)，指的是MySQL自主去选择相应的算法。/* 事务(transaction) */ ------------------事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 - 支持连续SQL的集体成功或集体撤销。 - 事务是数据库在数据晚自习方面的一个功能。 - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。 - InnoDB被称为事务安全型引擎。-- 事务开启 START TRANSACTION; 或者 BEGIN; 开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。-- 事务提交 COMMIT;-- 事务回滚 ROLLBACK; 如果部分操作发生问题，映射到事务开启前。-- 事务的特性 1. 原子性（Atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 2. 一致性（Consistency） 事务前后数据的完整性必须保持一致。 - 事务开始和结束时，外部数据一致 - 在整个事务过程中，操作是连续的 3. 隔离性（Isolation） 多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。 4. 持久性（Durability） 一个事务一旦被提交，它对数据库中的数据改变就是永久性的。-- 事务的实现 1. 要求是事务支持的表类型 2. 执行一组相关的操作前开启事务 3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。-- 事务的原理 利用InnoDB的自动提交(autocommit)特性完成。 普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。 而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。-- 注意 1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。 2. 事务不能被嵌套-- 保存点 SAVEPOINT 保存点名称 -- 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点-- InnoDB自动提交特性设置 SET autocommit = 0|1; 0表示关闭自动提交，1表示开启自动提交。 - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。 - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是， SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接) 而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)/* 锁表 */表锁定只用于防止其它客户端进行不正当地读取和写入MyISAM 支持表锁，InnoDB 支持行锁-- 锁定 LOCK TABLES tbl_name [AS alias]-- 解锁 UNLOCK TABLES/* 触发器 */ ------------------ 触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象 监听：记录的增加、修改、删除。-- 创建触发器CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt 参数： trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。 trigger_event指明了激活触发程序的语句的类型 INSERT：将新行插入表时激活触发程序 UPDATE：更改某一行时激活触发程序 DELETE：从表中删除某一行时激活触发程序 tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。 trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构-- 删除DROP TRIGGER [schema_name.]trigger_name可以使用old和new代替旧的和新的数据 更新操作，更新前是old，更新后是new. 删除操作，只有old. 增加操作，只有new.-- 注意 1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。-- 字符连接函数concat(str1,str2,...])concat_ws(separator,str1,str2,...)-- 分支语句if 条件 then 执行语句elseif 条件 then 执行语句else 执行语句end if;-- 修改最外层语句结束符delimiter 自定义结束符号 SQL语句自定义结束符号delimiter ; -- 修改回原来的分号-- 语句块包裹begin 语句块end-- 特殊的执行1. 只要添加记录，就会触发程序。2. Insert into on duplicate key update 语法会触发： 如果没有重复记录，会触发 before insert, after insert; 如果有重复记录并更新，会触发 before insert, before update, after update; 如果有重复记录但是没有发生更新，则触发 before insert, before update3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert/* SQL编程 */ --------------------// 局部变量 ------------ 变量声明 declare var_name[,...] type [default value] 这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。-- 赋值 使用 set 和 select into 语句为变量赋值。 - 注意：在函数内是可以使用全局变量（用户自定义的变量）--// 全局变量 ------------ 定义、赋值set 语句可以定义并为变量赋值。set @var = value;也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。select @var:=20;select @v1:=id, @v2=name from t1 limit 1;select * from tbl_name where @var:=30;select into 可以将表中查询获得的数据赋给变量。 -| select max(height) into @max_height from tb;-- 自定义变量名为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。@var=10; - 变量被定义后，在整个会话周期都有效（登录到退出）--// 控制结构 ------------ if语句if search_condition then statement_list [elseif search_condition then statement_list]...[else statement_list]end if;-- case语句CASE value WHEN [compare-value] THEN result[WHEN [compare-value] THEN result ...][ELSE result]END-- while循环[begin_label:] while search_condition do statement_listend while [end_label];- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。 -- 退出循环 退出整个循环 leave 退出当前循环 iterate 通过退出的标签决定退出哪个循环--// 内置函数 ------------ 数值函数abs(x) -- 绝对值 abs(-10.9) = 10format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46ceil(x) -- 向上取整 ceil(10.1) = 11floor(x) -- 向下取整 floor (10.1) = 10round(x) -- 四舍五入去整mod(m, n) -- m%n m mod n 求余 10%3=1pi() -- 获得圆周率pow(m, n) -- m^nsqrt(x) -- 算术平方根rand() -- 随机数truncate(x, d) -- 截取d位小数-- 时间日期函数now(), current_timestamp(); -- 当前日期时间current_date(); -- 当前日期current_time(); -- 当前时间date('yyyy-mm-dd hh:ii:ss'); -- 获取日期部分time('yyyy-mm-dd hh:ii:ss'); -- 获取时间部分date_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); -- 格式化时间unix_timestamp(); -- 获得unix时间戳from_unixtime(); -- 从时间戳获得时间-- 字符串函数length(string) -- string长度，字节char_length(string) -- string的字符个数substring(str, position [,length]) -- 从str的position开始,取length个字符replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_strinstr(string ,substring) -- 返回substring首次在string中出现的位置concat(string [,...]) -- 连接字串charset(str) -- 返回字串字符集lcase(string) -- 转换成小写left(string, length) -- 从string2中的左边起取length个字符load_file(file_name) -- 从文件读取内容locate(substring, string [,start_position]) -- 同instr,但可指定开始位置lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为lengthltrim(string) -- 去除前端空格repeat(string, count) -- 重复count次rpad(string, length, pad) --在str后用pad补充,直到长度为lengthrtrim(string) -- 去除后端空格strcmp(string1 ,string2) -- 逐字符比较两字串大小-- 流程函数case when [condition] then result [when [condition] then result ...] [else result] end 多分支if(expr1,expr2,expr3) 双分支。-- 聚合函数count()sum();max();min();avg();group_concat()-- 其他常用函数md5();default();--// 存储函数，自定义函数 ------------ 新建 CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型 函数体 - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。 - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。 - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。 - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。 - 多条语句应该使用 begin...end 语句块包含。 - 一定要有 return 返回值语句。-- 删除 DROP FUNCTION [IF EXISTS] function_name;-- 查看 SHOW FUNCTION STATUS LIKE 'partten' SHOW CREATE FUNCTION function_name;-- 修改 ALTER FUNCTION function_name 函数选项--// 存储过程，自定义功能 ------------ 定义存储存储过程 是一段代码（过程），存储在数据库中的sql组成。一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。-- 创建CREATE PROCEDURE sp_name (参数列表) 过程体参数列表：不同于函数的参数列表，需要指明参数类型IN，表示输入型OUT，表示输出型INOUT，表示混合型注意，没有返回值。/* 存储过程 */ ------------------存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。调用：CALL 过程名-- 注意- 没有返回值。- 只能单独调用，不可夹杂在其他语句中-- 参数IN|OUT|INOUT 参数名 数据类型IN 输入：在调用过程中，将数据输入到过程体内部的参数OUT 输出：在调用过程中，将过程体处理完的结果返回到客户端INOUT 输入输出：既可输入，也可输出-- 语法CREATE PROCEDURE 过程名 (参数列表)BEGIN 过程体END/* 用户和权限管理 */ -------------------- root密码重置1. 停止MySQL服务2. [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp; [Windows] mysqld --skip-grant-tables3. use mysql;4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;;5. FLUSH PRIVILEGES;用户信息表：mysql.user-- 刷新权限FLUSH PRIVILEGES;-- 增加用户CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 'user_name'@'192.168.1.1' - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD-- 重命名用户RENAME USER old_user TO new_user-- 设置密码SET PASSWORD = PASSWORD('密码') -- 为当前用户设置密码SET PASSWORD FOR 用户名 = PASSWORD('密码') -- 为指定用户设置密码-- 删除用户DROP USER 用户名-- 分配权限/添加用户GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] 'password'] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 GRANT ALL PRIVILEGES ON `pms`.* TO 'pms'@'%' IDENTIFIED BY 'pms0817';-- 查看权限SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();-- 撤消权限REVOKE 权限列表 ON 表名 FROM 用户名REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限-- 权限层级-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv 当使用REVOKE时，您必须指定与被授权列相同的列。-- 权限列表ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限ALTER -- 允许使用ALTER TABLEALTER ROUTINE -- 更改或取消已存储的子程序CREATE -- 允许使用CREATE TABLECREATE ROUTINE -- 创建已存储的子程序CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLECREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。CREATE VIEW -- 允许使用CREATE VIEWDELETE -- 允许使用DELETEDROP -- 允许使用DROP TABLEEXECUTE -- 允许用户运行已存储的子程序FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILEINDEX -- 允许使用CREATE INDEX和DROP INDEXINSERT -- 允许使用INSERTLOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLESPROCESS -- 允许使用SHOW FULL PROCESSLISTREFERENCES -- 未被实施RELOAD -- 允许使用FLUSHREPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）SELECT -- 允许使用SELECTSHOW DATABASES -- 显示所有数据库SHOW VIEW -- 允许使用SHOW CREATE VIEWSHUTDOWN -- 允许使用mysqladmin shutdownSUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。UPDATE -- 允许使用UPDATEUSAGE -- “无权限”的同义词GRANT OPTION -- 允许授予权限/* 表维护 */-- 分析和存储表的关键字分布ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...-- 检查一个或多个表是否有错误CHECK TABLE tbl_name [, tbl_name] ... [option] ...option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}-- 整理数据文件的碎片OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] .../* 杂项 */ ------------------1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！2. 每个库目录存在一个保存当前数据库的选项文件db.opt。3. 注释： 单行注释 # 注释内容 多行注释 /* 注释内容 */ 单行注释 -- 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)4. 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 \\'5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\\G&quot;, &quot;\\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。6. SQL对大小写不敏感7. 清除已有语句：\\c","link":"/MySQL/%E4%B8%80%E5%8D%83%E8%A1%8C-MySQL-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BD%AC%E8%BD%BD.html"}],"tags":[{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"分治算法","slug":"分治算法","link":"/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"贪心算法","slug":"贪心算法","link":"/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"递归回溯","slug":"递归回溯","link":"/tags/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"反转整数","slug":"反转整数","link":"/tags/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"name":"字符串转整数","slug":"字符串转整数","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"name":"最长回文","slug":"最长回文","link":"/tags/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87/"},{"name":"Z字变换","slug":"Z字变换","link":"/tags/Z%E5%AD%97%E5%8F%98%E6%8D%A2/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"最优解","slug":"最优解","link":"/tags/%E6%9C%80%E4%BC%98%E8%A7%A3/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"rebase","slug":"rebase","link":"/tags/rebase/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"调试代码","slug":"调试代码","link":"/tags/%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"grammar","slug":"grammar","link":"/tags/grammar/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"gpg sign","slug":"gpg-sign","link":"/tags/gpg-sign/"},{"name":"工具教程","slug":"工具教程","link":"/tags/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"},{"name":"博客统计插件","slug":"博客统计插件","link":"/tags/%E5%8D%9A%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%8F%92%E4%BB%B6/"},{"name":"icarus主题配置","slug":"icarus主题配置","link":"/tags/icarus%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"name":"hexo主题","slug":"hexo主题","link":"/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"like","slug":"like","link":"/tags/like/"},{"name":"模糊查询","slug":"模糊查询","link":"/tags/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/"},{"name":"like优化","slug":"like优化","link":"/tags/like%E4%BC%98%E5%8C%96/"},{"name":"慢sql","slug":"慢sql","link":"/tags/%E6%85%A2sql/"},{"name":"索引","slug":"索引","link":"/tags/%E7%B4%A2%E5%BC%95/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"中心扩展","slug":"中心扩展","link":"/tags/%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"mybatis","slug":"mybatis","link":"/tags/mybatis/"},{"name":"b+tree","slug":"b-tree","link":"/tags/b-tree/"},{"name":"聚簇索引","slug":"聚簇索引","link":"/tags/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"},{"name":"死锁排查","slug":"死锁排查","link":"/tags/%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5/"},{"name":"sql优化","slug":"sql优化","link":"/tags/sql%E4%BC%98%E5%8C%96/"}],"categories":[{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"基础工具类","slug":"基础工具类","link":"/categories/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"develop","slug":"develop","link":"/categories/develop/"},{"name":"English","slug":"English","link":"/categories/English/"},{"name":"Git","slug":"基础工具类/Git","link":"/categories/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E7%B1%BB/Git/"},{"name":"grammar","slug":"English/grammar","link":"/categories/English/grammar/"},{"name":"git","slug":"develop/git","link":"/categories/develop/git/"},{"name":"工具教程","slug":"工具教程","link":"/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"主题工具","slug":"工具教程/主题工具","link":"/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E4%B8%BB%E9%A2%98%E5%B7%A5%E5%85%B7/"},{"name":"博客统计插件","slug":"工具教程/博客统计插件","link":"/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%8F%92%E4%BB%B6/"},{"name":"mysql","slug":"数据库/mysql","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"},{"name":"Vim","slug":"基础工具类/Vim","link":"/categories/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E7%B1%BB/Vim/"},{"name":"mybatis","slug":"数据库/mybatis","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis/"}]}